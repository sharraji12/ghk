<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Version Updated -->
    <title>Gemini Chat + Mock Test (v10.3 - Token Config, YT URL, Code Blocks)</title> <!-- Version Updated -->
    <script>
        // MathJax Configuration
        window.MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']], displayMath: [['$$', '$$'], ['\\[', '\\]']] },
            svg: { fontCache: 'global' },
            options: { skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
    <!-- <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-storage-compat.js"></script> -->

    <!-- Google Generative AI SDK (Loaded as Module) -->
    <script type="module">
        // Make SDK accessible globally after import
        try {
            // ***** TAMIL *****
            // இங்க Google Generative AI SDK-ஐ import செய்கிறோம். இதுதான் Gemini API உடன் பேச உதவும்.
            const { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold } = await import("https://esm.run/@google/generative-ai");
            window.GoogleGenerativeAI = GoogleGenerativeAI;
            // பாதுகாப்பு அமைப்புகளையும் import செய்கிறோம்
            window.HarmCategory = HarmCategory;
            window.HarmBlockThreshold = HarmBlockThreshold;
            console.log("GoogleGenerativeAI SDK loaded successfully via module.");
            // SDK load ஆனதும் ஒரு event-ஐ trigger செய்கிறோம்.
            window.dispatchEvent(new Event('google-ai-sdk-loaded'));
        } catch (error) {
            console.error("Failed to load GoogleGenerativeAI SDK:", error);
            // பிழை ஏற்பட்டால் console-ல் காட்டுவதோடு, ஒரு global variable-ல் store செய்கிறோம்.
            window.googleAiSdkLoadError = error;
        }
    </script>

    <!-- Prism JS for Code Syntax Highlighting -->
    {/* ***** TAMIL *****
        PrismJS என்பது code block-களுக்கு syntax highlighting (வண்ணம் தீட்டுதல்) செய்ய உதவும் ஒரு library.
        முதலில் அதன் CSS file-ஐ link செய்கிறோம் (prism.min.css). இது அடிப்படை தோற்றத்தை கொடுக்கும்.
        பிறகு core JavaScript file-ஐ load செய்கிறோம் (prism-core.min.js).
        அடுத்து autoloader plugin-ஐ load செய்கிறோம். இது code block-ல் என்ன language (e.g., javascript, python) உள்ளதோ, அதற்கு தேவையான highlighting rules-ஐ தானாகவே load செய்யும்.
    */}
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    {/* ***** TAMIL *****
        Load Copy to Clipboard and Toolbar plugins for PrismJS
        இது code block-ல் ஒரு toolbar-ஐயும், அதில் 'Copy' button-ஐயும் காட்ட உதவும் plugins.
        முதலில் toolbar-க்கான CSS, பிறகு toolbar-க்கான JS, கடைசியாக copy button-க்கான JS load செய்யப்படுகிறது.
    */}
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>


    <style>
        /* --- Styles (v10.3 - Added YouTube Embed, Enhanced Code Block Styles) --- */
        /* ***** TAMIL *****
           இங்க CSS styles உள்ளன.
           YouTube video embed செய்வதற்கான style-ம், code block styling-ம் மேம்படுத்தப்பட்டுள்ளது.
           Code block சரியாகத் தெரிய, கீழ்வரும் CSS விதிகள் முக்கியம்:
           1. `.ai-message pre`: இதுதான் code block-ன் வெளிப்பெட்டி (container). இதற்கு background color, padding, border, மற்றும் `overflow-x: auto` கொடுக்கப்பட்டுள்ளது. `overflow-x: auto` என்பது நீளமான code வரிகள் இருந்தால், கிடைமட்டமாக scroll செய்ய scrollbar-ஐ காட்டும். `white-space: pre;` என்பது code-ல் உள்ள spaces, line breaks போன்றவற்றை அப்படியே காட்ட உதவும்.
           2. `.ai-message pre > code[class*="language-"]`: இது `pre` tag-க்கு உள்ளே இருக்கும் உண்மையான code-ஐ கொண்ட `code` tag. இதற்கு `display: block;` கொடுக்கப்பட்டுள்ளது. மற்ற padding, margin போன்றவற்றை reset செய்து, font family-ஐ monospace ஆக மாற்றுகிறோம். `white-space: inherit;` என்பது `pre` tag-ல் உள்ள `white-space: pre;` ஐ இதுவும் பயன்படுத்தும் என்பதை உறுதி செய்கிறது.
           3. `div.code-toolbar > .toolbar`: இது PrismJS மூலம் சேர்க்கப்படும் copy button உள்ள toolbar. `position: absolute` மூலம் இதை code block-ன் மேல் வலது மூலையில் காட்டுகிறோம். Hover செய்யும்போது மட்டுமே இது தெரியும் (`opacity: 0` to `opacity: 1`).
        */
        :root { /* ... Theme Variables ... */
             --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; --sidebar-width: 260px; --message-font-size-base: 1rem;
            /* LIGHT */ --sidebar-bg: #f7f7f7; --main-bg: #ffffff; --input-bg: #ffffff; --border-color: #e0e0e0; --text-primary: #2c2c2c; --text-secondary: #5f5f5f; --text-placeholder: #999999; --accent-color: #d97a7a; --user-message-bg: #cce0ff; --user-message-text: #1c1c1c; --ai-message-bg: #f0f0f0; --ai-message-text: #2c2c2c; --button-bg: #f0f0f0; --button-hover-bg: #e0e0e0; --active-item-bg: #e0e0e0; --code-bg: #e8e8e8; --scrollbar-thumb: #ccc; --scrollbar-thumb-hover: #bbb; --app-outer-bg: #e8e8e8; --send-button-bg: var(--accent-color); --send-button-hover-bg: #c76b6b; --send-button-text: #ffffff; --error-bg: #ffebee; --error-text: #c62828; --error-border: #ef9a9a; --message-font-size: var(--message-font-size-base); --delete-button-color: #aaa; --delete-button-hover-color: #dc3545; --input-border-color: var(--border-color); --input-focus-border-color: var(--accent-color); --preview-bg: var(--button-bg); --preview-border: var(--border-color); --remove-btn-color: var(--text-secondary); --remove-btn-hover-color: var(--error-text);
            /* Audio Specific */
            --record-button-bg: #ff6b6b; --record-button-text: #ffffff; --stop-button-bg: #4a4a4a; --stop-button-text: #ffffff;
            /* Model Selector Specific */
             --selector-bg: var(--input-bg); --selector-border: var(--border-color); --selector-text: var(--text-secondary);
        }
        body.dark-theme { /* DARK */ --sidebar-bg: #2a2a2e; --main-bg: #1e1e1e; --input-bg: #2a2a2e; --border-color: #404040; --text-primary: #e0e0e0; --text-secondary: #a0a0a0; --text-placeholder: #777777; --accent-color: #e58b8b; --user-message-bg: #3a4a6b; --user-message-text: #e8e8e8; --ai-message-bg: #333333; --ai-message-text: #e0e0e0; --button-bg: #404040; --button-hover-bg: #505050; --active-item-bg: #454545; --code-bg: #2c2c2e; --scrollbar-thumb: #555; --scrollbar-thumb-hover: #666; --app-outer-bg: #121212; --send-button-bg: var(--accent-color); --send-button-hover-bg: #f09f9f; --send-button-text: #1e1e1e; --error-bg: #5c2b2b; --error-text: #ffcdd2; --error-border: #8c4343; --delete-button-color: #666; --delete-button-hover-color: #f09f9f; --input-border-color: var(--border-color); --input-focus-border-color: var(--accent-color); --preview-bg: var(--button-bg); --preview-border: var(--border-color); --remove-btn-color: var(--text-secondary); --remove-btn-hover-color: var(--error-text);
            /* Audio Specific */
             --record-button-bg: #ff8787; --record-button-text: #1e1e1e; --stop-button-bg: #777777; --stop-button-text: #e0e0e0;
            /* Model Selector Specific */
             --selector-bg: var(--input-bg); --selector-border: var(--border-color); --selector-text: var(--text-secondary);
        }
        body { font-family: var(--font-family); margin: 0; padding: 0; background-color: var(--app-outer-bg); color: var(--text-primary); font-size: 15px; transition: background-color 0.3s ease, color 0.3s ease; }

        /* Layout & Structure */
        .app-container { display: flex; height: 100vh; width: 100vw; overflow: hidden; } .app-container.hidden { display: none; }
        .sidebar { width: var(--sidebar-width); background-color: var(--sidebar-bg); border-right: 1px solid var(--border-color); display: flex; flex-direction: column; padding: 15px 0; box-sizing: border-box; flex-shrink: 0; transition: background-color 0.3s ease, border-color 0.3s ease, width 0.3s ease; }
        .main-container { flex-grow: 1; display: flex; flex-direction: column; height: 100vh; overflow: hidden; position: relative; }
        .main-content, .review-view { display: none; flex-direction: column; background-color: var(--main-bg); height: 100%; width: 100%; overflow: hidden; transition: background-color 0.3s ease; }
        .main-content.active, .review-view.active { display: flex; }
        .chat-area { flex-grow: 1; overflow-y: auto; padding: 30px 10% 20px; display: flex; flex-direction: column; max-width: 800px; margin: 0 auto; width: 80%; }
        .input-container { padding: 15px 10% 20px; border-top: 1px solid var(--border-color); background-color: var(--input-bg); max-width: 800px; margin: 0 auto; width: 80%; transition: background-color 0.3s ease, border-color 0.3s ease; display: none; }

        /* Sidebar Elements */
         .sidebar-header { padding: 10px 20px; font-size: 1.1em; font-weight: 600; color: var(--text-primary); }
         .sidebar-section { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; margin-top: 10px; }
         .sidebar-section-title { padding: 5px 20px; font-size: 0.85em; font-weight: 600; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px; flex-shrink: 0; }
         #all-tests-section { border-bottom: 1px solid var(--border-color); margin-bottom: 10px; padding-bottom: 10px; flex-shrink: 0; display: flex; flex-direction: column; max-height: 40%; display: none; }
         #all-tests-section.visible { display: flex; }
         #test-search-input { width: calc(100% - 40px); padding: 8px 10px; margin: 5px 15px 10px 15px; border: 1px solid var(--input-border-color); background-color: var(--input-bg); color: var(--text-primary); border-radius: 6px; font-size: 0.9em; box-sizing: border-box; }
         #test-search-input:focus { outline: none; border-color: var(--input-focus-border-color); }
         #all-tests-list { overflow-y: auto; padding: 0 15px; flex-grow: 1; }
         #all-tests-list::-webkit-scrollbar { width: 6px; } #all-tests-list::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 3px;} #all-tests-list::-webkit-scrollbar-thumb:hover { background: var(--scrollbar-thumb-hover); }
         .test-list-item { padding: 8px 10px; margin-bottom: 5px; border-radius: 6px; background-color: var(--button-bg); cursor: default; transition: background-color 0.2s ease; display: flex; flex-direction: column; gap: 5px; border: 1px solid var(--border-color); }
         .test-list-item.hidden-by-search { display: none; }
         .test-list-item .no-search-results { padding:10px;color:var(--text-secondary);font-size:0.9em; }
         .test-item-info { font-size: 0.9em; color: var(--text-primary); position: relative; padding-right: 50px; }
         .test-item-title { font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: block; }
         .test-item-details { font-size: 0.8em; color: var(--text-secondary); }
         .test-item-actions { display: flex; justify-content: flex-start; gap: 8px; margin-top: 5px; }
         .test-item-actions button, .test-item-actions select { background-color: var(--main-bg); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 4px; padding: 4px 8px; font-size: 0.8em; cursor: pointer; transition: background-color 0.2s ease, color 0.2s ease; }
         .test-item-actions button:hover, .test-item-actions select:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
         .test-item-actions select:disabled { opacity: 0.6; cursor: not-allowed; }
        .test-item-controls { position: absolute; right: 5px; top: 0; display: flex; gap: 5px; }
        .test-item-controls button { background: none; border: none; color: var(--delete-button-color); cursor: pointer; font-size: 1.1em; padding: 0 3px; line-height: 1; opacity: 0.7; transition: color 0.2s ease, opacity 0.2s ease; }
        .test-item-controls button:hover { opacity: 1; color: var(--delete-button-hover-color); }
        .test-item-edit-mode { display: flex; align-items: center; }
        .test-item-edit-mode input[type="text"] { flex-grow: 1; padding: 2px 4px; margin-right: 5px; border: 1px solid var(--input-focus-border-color); background-color: var(--input-bg); color: var(--text-primary); border-radius: 3px; font-size: 0.95em; }
        .test-item-edit-mode button { font-size: 0.9em; padding: 2px 5px; background-color: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 3px; cursor: pointer; margin-left: 3px; }
        .test-item-edit-mode button:hover { background-color: var(--button-hover-bg); }
         .start-chat-button { display: flex; align-items: center; gap: 8px; background-color: var(--main-bg); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 8px; padding: 10px 15px; margin: 0 15px 10px 15px; font-size: 0.95em; font-weight: 500; cursor: pointer; text-align: left; transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease; flex-shrink: 0; }
         .start-chat-button:hover { background-color: var(--button-hover-bg); } .start-chat-button svg { fill: currentColor; width: 16px; height: 16px; }
         .start-chat-button:disabled { opacity: 0.6; cursor: not-allowed; }
         .chat-list { overflow-y: auto; padding: 0 15px; margin-bottom: 10px; flex-grow: 1; }
         .chat-list::-webkit-scrollbar { width: 6px; } .chat-list::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 3px;} .chat-list::-webkit-scrollbar-thumb:hover { background: var(--scrollbar-thumb-hover); }
         .chat-list-item { padding: 8px 30px 8px 10px; margin-bottom: 4px; border-radius: 6px; font-size: 0.9em; cursor: pointer; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-secondary); transition: background-color 0.2s ease, color 0.2s ease; position: relative; }
         .chat-list-item:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
         .chat-list-item.active { background-color: var(--active-item-bg); color: var(--text-primary); font-weight: 500; }
         .delete-chat-button { position: absolute; right: 6px; top: 50%; transform: translateY(-50%); width: 18px; height: 18px; background: none; border: none; color: var(--delete-button-color); cursor: pointer; font-size: 1.3em; line-height: 1; padding: 0; display: none; opacity: 0.7; transition: color 0.2s ease, opacity 0.2s ease; }
         .chat-list-item:hover .delete-chat-button { display: block; }
         .delete-chat-button:hover { color: var(--delete-button-hover-color); opacity: 1; }
         .sidebar-footer { border-top: 1px solid var(--border-color); padding: 10px 15px; transition: border-color 0.3s ease; flex-shrink: 0; }
         .sidebar-controls { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; flex-wrap: wrap; gap: 10px;} /* Added wrap and gap */
         .text-size-controls, .theme-toggle { display: flex; align-items: center; gap: 5px; }
         .text-size-controls span, .theme-toggle span { font-size: 0.85em; color: var(--text-secondary); }
         .text-size-buttons button, .theme-toggle button { background: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 4px; padding: 2px 8px; cursor: pointer; font-size: 1.1em; line-height: 1; transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease; }
         .text-size-buttons button:hover, .theme-toggle button:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
         .text-size-buttons button:disabled, .theme-toggle button:disabled { opacity: 0.6; cursor: not-allowed; }

         /* Model Selector Styling */
         .model-selector-container { margin-top: 10px; width: 100%; }
         .model-selector-container label { font-size: 0.85em; color: var(--text-secondary); display: block; margin-bottom: 4px; }
         #model-selector { width: 100%; padding: 6px 8px; border: 1px solid var(--selector-border); background-color: var(--selector-bg); color: var(--selector-text); border-radius: 6px; font-size: 0.85em; -webkit-appearance: none; appearance: none; background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23${'var(--text-secondary)'.substring(4, 10)}%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.4-12.8z%22%2F%3E%3C%2Fsvg%3E'); background-repeat: no-repeat; background-position: right 8px top 50%; background-size: .65em auto; }
         #model-selector:disabled { opacity: 0.6; cursor: not-allowed; background-color: var(--button-bg); }
         #model-selector:focus { outline: none; border-color: var(--input-focus-border-color); }

         .account-info { display: flex; align-items: center; gap: 10px; font-size: 0.9em; margin-top: 10px; }
         .account-avatar { width: 30px; height: 30px; border-radius: 50%; background-color: #6c757d; color: white; display: flex; align-items: center; justify-content: center; font-weight: 600; }
         .account-details { overflow: hidden; }
         .account-email { font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-primary); }
         .account-plan { font-size: 0.85em; color: var(--text-secondary); }
         #auth-controls { margin-top: 15px; text-align: center; }
         #auth-controls button { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 8px 15px; cursor: pointer; font-size: 0.9em; transition: background-color 0.2s ease; }
         #auth-controls button:hover { background-color: var(--button-hover-bg); }
         #logout-btn { display: none; }

        /* Chat Area Elements */
        .greeting { font-size: 1.8em; font-weight: 600; margin-bottom: 40px; color: var(--text-primary); } .greeting .asterisk { color: var(--accent-color); font-size: 1.2em; margin-right: 5px; display: inline-block; vertical-align: middle; }
        .message { padding: 12px 18px; border-radius: 18px; max-width: 80%; word-wrap: break-word; line-height: 1.6; margin-bottom: 15px; font-size: var(--message-font-size); transition: background-color 0.3s ease, color 0.3s ease; }
        .user-message { background-color: var(--user-message-bg); color: var(--user-message-text); align-self: flex-end; border-bottom-right-radius: 5px; }
        .ai-message { background-color: var(--ai-message-bg); color: var(--ai-message-text); align-self: flex-start; border-bottom-left-radius: 5px; }
        .ai-message strong { font-weight: 600; } .ai-message em { font-style: italic; }

        /* --- Code Block Styling (Enhanced v10.3) --- */
        /* ***** TAMIL *****
           `pre` tag-க்கான style. இது code block-ன் background, padding, border, மற்றும் scrollbar-ஐ கையாளுகிறது.
           `overflow-x: auto;` என்பது நீளமான code line-களுக்கு horizontal scrollbar காட்ட உதவும்.
           `white-space: pre;` என்பது code formatting-ஐ (spaces, line breaks) அப்படியே காட்ட உதவும்.
           `word-wrap: normal;` என்பது code தானாக அடுத்த வரிக்கு போவதை தடுக்கும் (scrollbar தான் பயன்படுத்தப்படும்).
        */
        .ai-message pre {
            background-color: var(--code-bg);
            color: var(--text-primary);
            padding: 12px 15px; /* Slightly more padding */
            border-radius: 6px; /* Slightly rounder */
            overflow-x: auto; /* <<< Ensure horizontal scroll for long lines */
            font-size: 0.9em;
            transition: background-color 0.3s ease, color 0.3s ease;
            border: 1px solid var(--border-color);
            margin: 10px 0; /* More margin */
            position: relative; /* <<< Needed for toolbar positioning */
            white-space: pre; /* <<< Preserve whitespace and line breaks as in the code */
            word-wrap: normal; /* <<< Prevent wrapping inside pre */
            box-sizing: border-box; /* Include padding/border in width calculation */
        }
        /* ***** TAMIL *****
           `pre` tag உள்ளே உள்ள `code` tag-க்கான style.
           இது font family (monospace), background, padding போன்றவற்றை reset செய்கிறது, ஏன்னா PrismJS இதை handle செய்யும்.
           `display: block;` முக்கியம்.
           `white-space: inherit;` என்பது `pre` tag-ன் `white-space: pre;` ஐ இதுவும் பயன்படுத்தும் என்பதை உறுதி செய்கிறது.
        */
        .ai-message pre > code[class*="language-"] {
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; /* Monospace font */
            display: block; /* <<< Ensure block display */
            padding: 0; /* Reset padding, pre tag handles it */
            margin: 0; /* Reset margin */
            overflow: visible; /* Code itself shouldn't scroll, pre tag handles it */
            background: none; /* No background for code tag itself */
            color: inherit; /* Inherit color from pre tag */
            font-size: 1em; /* Inherit font size from pre */
            text-shadow: none;
            white-space: inherit; /* <<< Inherit white-space from pre */
            word-wrap: inherit; /* Inherit word-wrap from pre */
            box-sizing: border-box;
        }
        /* Inline code styling (`) */
        .ai-message:not(pre) > code {
            background-color: var(--code-bg);
            color: var(--text-primary);
            padding: 2px 5px;
            border-radius: 4px;
            font-size: 0.9em;
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        /* ***** TAMIL *****
            PrismJS Toolbar/Copy Button Styling
            இது code block-ன் மேல் வலதுபுறம் தோன்றும் toolbar (copy button கொண்டது).
            `position: absolute` மூலம் இது `pre` tag-க்குள் (relative positioning உள்ள) நிலைநிறுத்தப்படுகிறது.
            Mouse hover செய்யும்போது மட்டுமே இது தெரியும் (`opacity: 0` to `1`).
        */
        div.code-toolbar { position: relative; } /* Ensure the pre's wrapper is relative if this is used */
        div.code-toolbar > .toolbar {
            position: absolute;
            top: 0.5em; /* Adjust position slightly */
            right: 0.5em; /* Adjust position slightly */
            transition: opacity 0.3s ease-in-out;
            opacity: 0;
            z-index: 1; /* Ensure it's above the code */
        }
        div.code-toolbar:hover > .toolbar { opacity: 1; }
        /* Style for the button inside the toolbar */
        div.code-toolbar > .toolbar .toolbar-item > button {
             background: var(--button-bg);
             color: var(--text-secondary);
             border: 1px solid var(--border-color);
             border-radius: 4px;
             padding: 3px 8px;
             font-size: 0.8em;
             cursor: pointer;
             transition: background-color 0.2s ease, color 0.2s ease;
             box-shadow: none;
             font-family: var(--font-family); /* Ensure consistent font */
         }
         div.code-toolbar > .toolbar .toolbar-item > button:hover {
             background-color: var(--button-hover-bg);
             color: var(--text-primary);
         }
        /* Dark theme adjustments for toolbar button */
        body.dark-theme div.code-toolbar > .toolbar .toolbar-item > button { background: var(--button-bg); color: var(--text-secondary); }
        body.dark-theme div.code-toolbar > .toolbar .toolbar-item > button:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
        /* --- End Code Block Styling --- */

        .ai-message.thinking { background-color: transparent; color: var(--text-secondary); font-style: italic; }
        .error-message { background-color: var(--error-bg); color: var(--error-text); border: 1px solid var(--error-border); align-self: flex-start; transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;}
        .info-message { text-align: center; color: var(--text-secondary); padding: 50px 20px; font-style: italic; }
        .message .multi-media-indicator { font-size: 0.9em; color: var(--text-secondary); margin-top: 8px; display: block; font-style: italic;}
        .message mjx-container { color: inherit !important; font-size: inherit !important; }
        .message img.chat-image, .message img.uploaded-image { max-width: 100%; height: auto; border-radius: 8px; margin-top: 8px; cursor: pointer; display: block; }
        .message img.uploaded-image { border: 1px solid var(--border-color); margin-bottom: 5px; }
        /* YouTube Embed Styling */
        .message .youtube-embed-container { margin-top: 10px; position: relative; padding-bottom: 56.25%; /* 16:9 Aspect Ratio */ height: 0; overflow: hidden; max-width: 100%; background: #000; border-radius: 8px; }
        .message iframe.chat-video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; }
        .message .chat-audio-player { margin-top: 10px; width: 100%; max-width: 350px; }
        .message .chat-audio-player audio { width: 100%; height: 40px; border-radius: 20px; }

        /* Input Area Elements */
        .suggestions { display: none; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; }
        .suggestion-chip { background-color: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 16px; padding: 8px 15px; font-size: 0.9em; cursor: pointer; transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease; }
        .suggestion-chip:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
        .input-box { display: flex; align-items: flex-end; background-color: var(--main-bg); border: 1px solid var(--input-border-color); border-radius: 12px; padding: 5px 5px 5px 15px; position: relative; transition: background-color 0.3s ease, border-color 0.3s ease; }
        .input-box:focus-within { border-color: var(--input-focus-border-color); }
        .input-buttons { display: flex; align-self: center; margin-right: 5px; gap: 3px; }
        #image-upload-button, #pdf-upload-button, #audio-upload-button, #record-audio-button { background: none; border: none; color: var(--text-secondary); cursor: pointer; font-size: 1.4em; padding: 0 4px; line-height: 1; transition: color 0.2s ease, opacity 0.2s ease; }
        #image-upload-button:hover, #pdf-upload-button:hover:not(:disabled), #audio-upload-button:hover, #record-audio-button:hover:not(.recording) { color: var(--text-primary); } /* Only hover if not disabled */
        #image-upload-button:disabled, #pdf-upload-button:disabled, #audio-upload-button:disabled, #record-audio-button:disabled:not(.recording) { opacity: 0.5; cursor: not-allowed; color: var(--text-secondary); }
        #record-audio-button.recording { color: var(--record-button-bg); animation: pulse 1.5s infinite; }
        #record-audio-button.recording:disabled { color: var(--stop-button-bg); opacity: 0.7; animation: none; cursor: default; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }

        #user-input { flex-grow: 1; border: none; outline: none; padding: 10px 5px; font-size: 1rem; background-color: transparent; resize: none; min-height: 48px; max-height: 250px; line-height: 1.5; color: var(--text-primary); font-family: var(--font-family); }
        #user-input::placeholder { color: var(--text-placeholder); }
        #user-input:disabled { background-color: var(--button-bg); cursor: not-allowed; opacity: 0.7; } /* Style for disabled input */
        .mcq-mode-control { display: flex; align-items: center; margin-left: 10px; padding-bottom: 8px; flex-shrink: 0; }
        .mcq-mode-control input[type="checkbox"] { margin-right: 5px; accent-color: var(--accent-color); cursor: pointer;}
        .mcq-mode-control label { font-size: 0.85em; color: var(--text-secondary); cursor: pointer; user-select: none;}
        #send-button { background-color: var(--send-button-bg); color: var(--send-button-text); border: none; border-radius: 8px; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; cursor: pointer; margin-left: 10px; transition: background-color 0.2s ease; padding: 0; flex-shrink: 0; }
        #send-button:hover:not(:disabled) { background-color: var(--send-button-hover-bg); }
        #send-button:disabled { background-color: #cccccc; cursor: not-allowed; opacity: 0.6; }
        #send-button svg { width: 20px; height: 20px; fill: currentColor; }

        /* Media Previews */
        #media-preview-container { margin-bottom: 10px; padding: 8px; background-color: var(--preview-bg); border: 1px solid var(--preview-border); border-radius: 8px; display: none; flex-direction: column; gap: 8px; }
        #image-previews-list { display: flex; gap: 8px; flex-wrap: wrap; max-height: 120px; overflow-y: auto; }
        .pdf-preview-item { background-color: var(--main-bg); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; padding: 4px 8px; font-size: 0.85em; display: flex; align-items: center; gap: 6px; max-width: 100%; box-sizing: border-box; } /* Added max-width, box-sizing */
        .pdf-preview-item span { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex-grow: 1; }
        .pdf-preview-item button { background: none; border: none; color: var(--remove-btn-color); cursor: pointer; font-size: 1.1em; line-height: 1; padding: 0 2px; margin-left: 4px; flex-shrink: 0; }
        .pdf-preview-item button:hover { color: var(--remove-btn-hover-color); }
        .image-preview-item { position: relative; }
        .image-preview-item img { max-height: 50px; max-width: 80px; height: auto; width: auto; border-radius: 4px; object-fit: cover; display: block; border: 1px solid var(--border-color); }
        .remove-image-item-button { position: absolute; top: -5px; right: -5px; background-color: rgba(0, 0, 0, 0.6); color: white; border: none; border-radius: 50%; width: 16px; height: 16px; font-size: 10px; line-height: 16px; text-align: center; cursor: pointer; opacity: 0.8; transition: opacity 0.2s ease; }
        .remove-image-item-button:hover { opacity: 1; }
        #preview-audio-container { display: flex; align-items: center; gap: 8px; display: none; }
        #preview-audio-container audio { height: 30px; max-width: 250px; }
        .media-preview-footer { display: flex; align-items: center; width: 100%; }
        #media-preview-info { font-size: 0.85em; color: var(--text-secondary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex-grow: 1; }
        #remove-media-button { background: none; border: none; color: var(--remove-btn-color); cursor: pointer; font-size: 1.4em; line-height: 1; padding: 0 5px; transition: color 0.2s ease; margin-left: auto; flex-shrink: 0; }
        #remove-media-button:hover { color: var(--remove-btn-hover-color); }

         #recording-status { font-size: 0.85em; color: var(--text-secondary); margin-bottom: 5px; display: none; text-align: center; padding: 3px 0; }
         #recording-status.visible { display: block; }

        .thinking::after { content: ' .'; animation: dots 1s steps(3, end) infinite; display: inline-block; }
        @keyframes dots { 0%, 20% { content: ' .'; } 40% { content: ' ..'; } 60%, 100% { content: ' ...'; } }
         .start-test-button { background-color: var(--accent-color); color: var(--send-button-text); border: none; border-radius: 6px; padding: 8px 15px; margin-top: 10px; cursor: pointer; font-weight: 500; display: inline-block; transition: background-color 0.2s ease; }
         .start-test-button:hover { background-color: var(--send-button-hover-bg); }

        /* Mock Test & Review View Styles */
        .mock-test-view { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--main-bg); z-index: 100; flex-direction: column; padding: 20px; box-sizing: border-box; transition: background-color 0.3s ease; }
        .mock-test-view.active { display: flex; }
        .test-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); flex-shrink: 0; }
        .test-header h2 { margin: 0; font-size: 1.3em; color: var(--text-primary); }
        .test-info { display: flex; align-items: center; }
        .test-info span { margin-left: 15px; font-size: 0.95em; color: var(--text-secondary); }
        #test-language-toggle, #review-language-toggle { margin-left: 15px; padding: 3px 8px; font-size: 0.8em; cursor: pointer; background-color: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 4px; transition: background-color 0.2s ease, color 0.2s ease; }
        #test-language-toggle:hover, #review-language-toggle:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
        .test-content { flex-grow: 1; overflow-y: auto; padding: 10px 20px; }
        .test-question-container { margin-bottom: 25px; }
        .test-question-number { font-weight: bold; margin-bottom: 8px; color: var(--text-secondary); }
        .test-question { font-size: 1.1em; line-height: 1.5; margin-bottom: 15px; color: var(--text-primary); }
        .test-options label { display: block; margin-bottom: 12px; background-color: var(--button-bg); padding: 12px 15px; border-radius: 6px; border: 1px solid var(--border-color); cursor: pointer; transition: background-color 0.2s ease, border-color 0.2s ease; color: var(--text-primary); }
        .test-options label:hover { background-color: var(--button-hover-bg); }
        .test-options input[type="radio"] { margin-right: 10px; accent-color: var(--accent-color); cursor: pointer;}
        .test-navigation { display: flex; justify-content: space-between; padding-top: 15px; border-top: 1px solid var(--border-color); margin-top: auto; flex-shrink: 0; }
        .test-navigation button { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 10px 20px; cursor: pointer; font-size: 0.95em; transition: background-color 0.2s ease; }
        .test-navigation button:hover:not(:disabled) { background-color: var(--button-hover-bg); }
        .test-navigation button#submit-test-btn { background-color: var(--accent-color); color: var(--send-button-text); border-color: var(--accent-color); }
        .test-navigation button#submit-test-btn:hover:not(:disabled) { background-color: var(--send-button-hover-bg); }
        .test-navigation button:disabled { opacity: 0.5; cursor: not-allowed; }
        .review-view { padding: 20px; box-sizing: border-box; background-color: var(--main-bg); }
        .review-header { margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid var(--border-color); }
        .review-header h2 { margin: 0 0 10px 0; font-size: 1.3em; color: var(--text-primary); }
        .review-summary { display: inline; }
        .review-summary span { margin-right: 20px; font-size: 1em; color: var(--text-primary); }
        .review-summary .score-correct { color: #28a745; font-weight: bold;} .review-summary .score-incorrect { color: #dc3545; font-weight: bold;} .review-summary .score-skipped { color: #fd7e14; font-weight: bold;}
        .review-filters { margin-top: 10px; margin-bottom: 15px; }
        .review-filters button { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 5px 12px; margin-right: 8px; cursor: pointer; font-size: 0.9em; transition: background-color 0.2s ease, border-color 0.2s ease; }
        .review-filters button:hover { background-color: var(--button-hover-bg); }
        .review-filters button.active-filter { background-color: var(--accent-color); color: var(--send-button-text); border-color: var(--accent-color);}
        .review-content { flex-grow: 1; overflow-y: auto; padding-right: 10px; }
        .review-item { margin-bottom: 15px; padding: 15px; border: 1px solid var(--border-color); border-radius: 6px; background-color: var(--button-bg); transition: background-color 0.3s ease, border-color 0.3s ease; }
        .review-item.hidden-by-filter { display: none; }
        .review-item-qnum { font-weight: bold; margin-bottom: 8px; color: var(--text-secondary); }
        .review-item-question { margin-bottom: 10px; line-height: 1.5; color: var(--text-primary); }
        .review-item-details span { display: block; margin-bottom: 5px; font-size: 0.95em; color: var(--text-primary); }
        .review-item-details .correct-answer { color: #28a745; font-weight: bold; }
        .review-item-details .user-answer-correct { color: #28a745; } .review-item-details .user-answer-incorrect { color: #dc3545; text-decoration: line-through; } .review-item-details .user-answer-skipped { color: #fd7e14; font-style: italic; }
        .review-item-explanation { margin-top: 8px; font-size: 0.9em; color: var(--text-secondary); border-left: 3px solid var(--border-color); padding-left: 8px; line-height: 1.4; }
        .review-footer { text-align: center; padding-top: 20px; border-top: 1px solid var(--border-color); margin-top: auto; flex-shrink: 0; display: flex; justify-content: center; gap: 15px; }
        #exit-review-btn, #save-review-btn { background-color: var(--accent-color); color: var(--send-button-text); border: none; border-radius: 6px; padding: 10px 25px; cursor: pointer; font-size: 1em; transition: background-color 0.2s ease; display: none; }
        #exit-review-btn:hover, #save-review-btn:hover:not(:disabled) { background-color: var(--send-button-hover-bg); }
        #save-review-btn { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); }
        #save-review-btn:hover:not(:disabled) { background-color: var(--button-hover-bg); }
        #save-review-btn:disabled { opacity: 0.6; cursor: not-allowed; background-color: #cccccc; border-color: #aaaaaa; }

        /* Responsive Design */
        @media (max-width: 768px) {
            :root { --sidebar-width: 200px; }
            .sidebar { padding: 10px 0; }
            .chat-area, .input-container { width: 95%; padding-left: 2.5%; padding-right: 2.5%; max-width: none; }
            .chat-area { padding-top: 15px; padding-bottom: 10px; }
            .input-container { padding-top: 10px; padding-bottom: 10px; }
            .message { max-width: 90%; font-size: calc(var(--message-font-size) * 0.95); }
            #image-upload-button, #pdf-upload-button, #audio-upload-button, #record-audio-button { font-size: 1.3em; padding: 0 3px; }
            #media-preview-container { padding: 6px; gap: 6px; }
            #image-previews-list { gap: 5px; max-height: 100px; }
            .pdf-preview-item { padding: 3px 6px; font-size: 0.8em; }
            .image-preview-item img { max-height: 40px; }
            .remove-image-item-button, .pdf-preview-item button { width: 14px; height: 14px; font-size: 9px; line-height: 14px; }
            #preview-audio-container audio { max-width: 180px; height: 28px; }
            #media-preview-info { font-size: 0.8em; }
            #remove-media-button { font-size: 1.3em; }
            .input-box { padding: 5px 5px 5px 10px; }
             #user-input { min-height: 40px; font-size: 0.95rem; }
             #send-button { width: 32px; height: 32px; }
             .mcq-mode-control label { font-size: 0.8em; }
            /* Responsive Sidebar Footer */
            .sidebar-footer { padding: 10px; }
            .sidebar-controls { flex-direction: column; align-items: flex-start; gap: 12px; }
            .model-selector-container { margin-top: 5px; }
            .account-info { margin-top: 15px; }
            #auth-controls { margin-top: 12px; }

            .mock-test-view, .review-view { padding: 10px; }
            .test-header, .review-header { margin-bottom: 15px; padding-bottom: 8px; flex-direction: column; align-items: flex-start; }
            .test-header h2, .review-header h2 { font-size: 1.1em; margin-bottom: 5px;}
            .test-info, .review-summary { margin-bottom: 5px; }
            .test-info span, .review-summary span { margin-left: 0; margin-right: 10px; font-size: 0.9em; display: inline-block; margin-bottom: 3px;}
            #test-language-toggle, #review-language-toggle { margin-left: 0; margin-top: 5px; font-size: 0.75em;}
            .test-content, .review-content { padding: 5px; }
            .test-question, .review-item-question { font-size: 1em; }
            .test-options label, .review-item { padding: 10px; font-size: 0.95em;}
            .review-filters { margin-top: 5px; }
            .review-filters button { padding: 4px 8px; font-size: 0.85em; margin-right: 5px;}
            .test-navigation, .review-footer { padding-top: 10px; }
            .test-navigation button, #exit-review-btn, #save-review-btn { padding: 8px 15px; font-size: 0.9em; }
        }
    </style>
</head>
<body>

    <div class="app-container" id="app-container">
        <!-- Sidebar -->
        <div class="sidebar">
             <!-- Sidebar content -->
             <div class="sidebar-header">Gemini Chat</div>
             <div id="all-tests-section">
                 <div class="sidebar-section-title">All Tests</div>
                 <input type="search" id="test-search-input" placeholder="Search tests..." disabled>
                 <div class="all-tests-list" id="all-tests-list">
                      <div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">Login to see saved tests.</div>
                 </div>
             </div>
             <div class="sidebar-section">
                 <button class="start-chat-button" id="start-chat" disabled> <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"></path></svg>
                      Start new chat
                 </button>
                 <div class="sidebar-section-title">Chats</div>
                 <div class="chat-list" id="chat-list">
                      <div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">Please log in to see chats.</div>
                 </div>
             </div>
             <div class="sidebar-footer">
                  <div class="sidebar-controls">
                      <div class="text-size-controls">
                          <span>Text Size</span>
                          <div class="text-size-buttons"> <button id="decrease-text-size" title="Decrease text size" disabled>-</button> <button id="increase-text-size" title="Increase text size" disabled>+</button> </div>
                      </div>
                      <div class="theme-toggle"> <button id="theme-toggle-button" title="Toggle Theme" disabled>☀️</button> </div>
                  </div>
                   <!-- ***** TAMIL ***** -->
                   <!-- இங்கதான் model-ஐ தேர்வு செய்வதற்கான dropdown-ஐ சேர்த்துள்ளோம் -->
                   <div class="model-selector-container">
                       <label for="model-selector">AI Model</label>
                       <select id="model-selector" disabled>
                            <!-- Options will be populated by JavaScript -->
                       </select>
                   </div>
                   <div id="auth-controls"> <button id="login-google-btn">Login with Google</button> <button id="logout-btn" style="display: none;">Logout</button> </div>
                   <div class="account-info">
                       <div class="account-avatar" id="account-avatar">?</div>
                       <div class="account-details"> <div class="account-email" id="account-email">Not logged in</div> <div class="account-plan" id="account-plan"></div> </div>
                   </div>
             </div>
        </div>

        <!-- Main container -->
        <div class="main-container">
            <div class="main-content active" id="main-content-chat">
                 <div class="chat-area" id="chat-area">
                     <!-- Greeting or Login Prompt -->
                 </div>
                 <div class="input-container" id="input-container">
                     <div class="suggestions" id="suggestions">
                          <button class="suggestion-chip" data-prompt="Summarize this document">Summarize this document</button>
                          <button class="suggestion-chip" data-prompt="Extract key points from this PDF">Extract key points from this PDF</button>
                          <button class="suggestion-chip" data-prompt="Describe this image">Describe this image</button>
                          <button class="suggestion-chip" data-prompt="Summarize this video">Summarize this video</button> <!-- Added YT Suggestion -->
                     </div>
                    <div id="media-preview-container">
                        <div id="image-previews-list">
                            <!-- Image/PDF Previews -->
                        </div>
                        <div id="preview-audio-container">
                           <audio id="preview-audio" controls></audio>
                        </div>
                        <div class="media-preview-footer">
                            <span id="media-preview-info"></span>
                            <button id="remove-media-button" title="Remove all media">&times;</button>
                        </div>
                    </div>
                    <div id="recording-status">Recording... <span>0s</span></div>
                    <div class="input-box">
                         <input type="file" id="image-upload-input" accept="image/png, image/jpeg, image/webp, image/heic, image/heif" style="display: none;" multiple> <!-- Updated Image MIME Types -->
                         <input type="file" id="pdf-upload-input" accept="application/pdf" style="display: none;" multiple>
                         <input type="file" id="audio-upload-input" accept="audio/wav, audio/mp3, audio/mpeg, audio/aac, audio/ogg, audio/flac, audio/aiff" style="display: none;">
                         {/* ***** TAMIL *****
                              தேவைப்பட்டால் Video Upload சேர்க்கலாம், ஆனால் browser-ல் பெரிய video files handle செய்வது சிக்கலானது. File API பயன்படுத்துவது சிறந்தது.
                              <input type="file" id="video-upload-input" accept="video/mp4, video/mpeg, video/mov, video/avi, video/x-flv, video/mpg, video/webm, video/wmv, video/3gpp" style="display: none;">
                         */}
                         <div class="input-buttons">
                             <button id="image-upload-button" title="Upload image(s)" disabled>📎</button>
                             <button id="pdf-upload-button" title="Upload PDF file(s)" disabled>📄</button> <!-- Title is updated dynamically -->
                             <button id="audio-upload-button" title="Upload audio file" disabled>🎵</button>
                             <button id="record-audio-button" title="Record audio" disabled>🎙️</button>
                              {/* <button id="video-upload-button" title="Upload video file (File API)" disabled>🎬</button> */}
                         </div>
                         <textarea id="user-input" placeholder="Enter prompt, attach media, or paste URL" rows="1" disabled></textarea>
                         <div class="mcq-mode-control"> <input type="checkbox" id="mcq-mode-checkbox" title="Generate MCQs based on prompt/media" disabled> <label for="mcq-mode-checkbox">MCQs?</label> </div>
                         <button id="send-button" title="Send message" disabled> <svg viewBox="0 0 24 24"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"></path></svg>
                        </button>
                    </div>
                 </div>
            </div>
            <!-- Review View -->
            <div class="review-view" id="review-view">
                 <div class="review-header">
                     <h2 id="review-title">Test Review</h2>
                     <div>
                         <div class="review-summary" id="review-summary"></div>
                      </div>
                     <div class="review-filters" id="review-filters" style="display: none;"> <button data-filter="all" class="active-filter">All</button> <button data-filter="incorrect">Incorrect</button> <button data-filter="skipped">Skipped</button> </div>
                 </div>
                 <div class="review-content" id="review-content"></div>
                 <div class="review-footer"> <button id="save-review-btn">Save Review</button> <button id="exit-review-btn">Back</button> </div>
              </div>
        </div>
    </div>
    <!-- Mock Test View -->
    <div class="mock-test-view" id="mock-test-view">
         <div class="test-header">
            <h2 id="test-title">Mock Test</h2>
            <div class="test-info">
                <span id="question-counter">Q: 1 / N</span>
                <span id="test-timer">Time: 00:00</span>
             </div>
         </div>
         <div class="test-content">
            <div class="test-question-container"> <div class="test-question-number" id="test-question-number"></div> <div class="test-question" id="test-question"></div> <div class="test-options" id="test-options"></div> </div>
         </div>
         <div class="test-navigation"> <button id="prev-question-btn" disabled>Previous</button> <button id="next-question-btn">Next</button> <button id="submit-test-btn">Submit Test</button> </div>
    </div>


    <script>
        // --- Firebase Config ---
        // ***** TAMIL *****
        // இது உங்கள் Firebase project-ன் configuration. இதை மாற்ற வேண்டாம்.
        const firebaseConfig = {
          apiKey: "AIzaSyDgw604fe5jnNu4kTOv1cQ-3n7PL8gcN58", // <- REPLACE IF NEEDED
          authDomain: "krish-c5db8.firebaseapp.com", // <- REPLACE IF NEEDED
          projectId: "krish-c5db8", // <- REPLACE IF NEEDED
          storageBucket: "krish-c5db8.appspot.com", // <- REPLACE IF NEEDED
          messagingSenderId: "217175257890", // <- REPLACE IF NEEDED
          appId: "1:217175257890:web:209f0f290eabab6b1fab7b", // <- REPLACE IF NEEDED
          measurementId: "G-97SHYGL2J4" // <- REPLACE IF NEEDED
        };

        // --- Initialize Firebase ---
        firebase.initializeApp(firebaseConfig);
        const fbAuth = firebase.auth();
        const db = firebase.firestore();

        // --- DOM Elements ---
        // ***** TAMIL *****
        // இங்க HTML-ல் உள்ள elements-ஐ JavaScript-ல் பயன்படுத்துவதற்காக variables-ல் store செய்கிறோம்.
        const appContainer = document.getElementById('app-container');
        const chatArea = document.getElementById('chat-area');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const suggestionsContainer = document.getElementById('suggestions');
        const startChatButton = document.getElementById('start-chat');
        const chatListContainer = document.getElementById('chat-list');
        const allTestsSection = document.getElementById('all-tests-section');
        const testSearchInput = document.getElementById('test-search-input');
        const allTestsListContainer = document.getElementById('all-tests-list');
        const accountEmail = document.getElementById('account-email');
        const accountAvatar = document.getElementById('account-avatar');
        const accountPlan = document.getElementById('account-plan');
        const decreaseTextBtn = document.getElementById('decrease-text-size');
        const increaseTextBtn = document.getElementById('increase-text-size');
        const themeToggleButton = document.getElementById('theme-toggle-button');
        const modelSelector = document.getElementById('model-selector'); // Model selector element
        const mainContainer = document.querySelector('.main-container');
        const chatView = document.getElementById('main-content-chat');
        const testView = document.getElementById('mock-test-view');
        const reviewView = document.getElementById('review-view');
        const inputContainer = document.getElementById('input-container');
        const mcqModeCheckbox = document.getElementById('mcq-mode-checkbox');
        const loginBtn = document.getElementById('login-google-btn');
        const logoutBtn = document.getElementById('logout-btn');
        // Test & Review Elements
        const testTitle = document.getElementById('test-title');
        const questionCounter = document.getElementById('question-counter');
        const testTimer = document.getElementById('test-timer');
        const testQuestionNumber = document.getElementById('test-question-number');
        const testQuestion = document.getElementById('test-question');
        const testOptionsContainer = document.getElementById('test-options');
        const prevQuestionBtn = document.getElementById('prev-question-btn');
        const nextQuestionBtn = document.getElementById('next-question-btn');
        const submitTestBtn = document.getElementById('submit-test-btn');
        const reviewTitle = document.getElementById('review-title');
        const reviewSummary = document.getElementById('review-summary');
        const reviewContent = document.getElementById('review-content');
        const exitReviewBtn = document.getElementById('exit-review-btn');
        const reviewFilters = document.getElementById('review-filters');
        const saveReviewBtn = document.getElementById('save-review-btn');
        // Media Elements
        const imageUploadButton = document.getElementById('image-upload-button');
        const imageUploadInput = document.getElementById('image-upload-input');
        const pdfUploadButton = document.getElementById('pdf-upload-button');
        const pdfUploadInput = document.getElementById('pdf-upload-input');
        const audioUploadButton = document.getElementById('audio-upload-button');
        const audioUploadInput = document.getElementById('audio-upload-input');
        const recordAudioButton = document.getElementById('record-audio-button');
        // Media Preview Elements
        const mediaPreviewContainer = document.getElementById('media-preview-container');
        const imagePreviewsList = document.getElementById('image-previews-list');
        const previewAudioContainer = document.getElementById('preview-audio-container');
        const previewAudio = document.getElementById('preview-audio');
        const mediaPreviewInfo = document.getElementById('media-preview-info');
        const removeMediaButton = document.getElementById('remove-media-button');
        // Recording Status
        const recordingStatus = document.getElementById('recording-status');
        const recordingTimerSpan = recordingStatus.querySelector('span');

        // --- Config & Constants ---
        // ***** TAMIL *****
        // இங்க application-க்கான சில முக்கியமான மாறிலிகளை (constants) அமைக்கிறோம்.
        // புது model-களையும், caching வேலை செய்யும் versioned model-களையும் சேர்த்துள்ளோம்.
        // Token Limits: 2.5 Pro-க்கு 65536 tokens, மற்றவற்றுக்கு 8192 tokens.
        // Context Caching: caching வேலை செய்ய 'Cache OK' என்று குறிக்கப்பட்ட versioned model-ஐ தேர்வு செய்ய வேண்டும்.
        // Experimental மற்றும் 'latest' model-கள் caching-ஐ support செய்யாது.
        const AVAILABLE_MODELS = [
            { id: "gemini-1.5-flash-latest", name: "Gemini 1.5 Flash Latest", supportsCaching: false, maxTokens: 8192 },
            { id: "gemini-1.5-pro-latest", name: "Gemini 1.5 Pro Latest", supportsCaching: false, maxTokens: 8192 },
            { id: "gemini-2.0-flash", name: "Gemini 2.0 Flash (New)", supportsCaching: false, maxTokens: 8192 },
            { id: "gemini-2.5-pro-exp-03-25", name: "Gemini 2.5 Pro Exp (New)", supportsCaching: false, maxTokens: 65536 }, // Specific large token limit
            { id: "gemini-1.5-flash-001", name: "Gemini 1.5 Flash 001 (Cache OK)", supportsCaching: true, maxTokens: 8192 }, // Specific version for caching
            { id: "gemini-1.5-pro-001", name: "Gemini 1.5 Pro 001 (Cache OK)", supportsCaching: true, maxTokens: 8192 }, // Specific version for caching
            // { id: "gemini-1.0-pro", name: "Gemini 1.0 Pro (Vision)", supportsCaching: false, maxTokens: 8192 }, // Removed older model for clarity
        ];
        const DEFAULT_MODEL_ID = AVAILABLE_MODELS[0].id; // Default to Flash Latest
        const DEFAULT_MAX_TOKENS = 8192; // Default max tokens for unknown models
        const STORAGE_KEY_API_KEY = 'geminiApiKey_insecureDemo';
        const STORAGE_KEY_MODEL_ID = 'geminiSelectedModelId'; // Key for model selection
        const NEW_CHAT_TITLE = "(New Chat)";
        const TEXT_SIZE_STEP = 0.1;
        const MIN_TEXT_SIZE_MULTIPLIER = 0.7;
        const MAX_TEXT_SIZE_MULTIPLIER = 1.5;
        const LIGHT_THEME_ICON = '☀️';
        const DARK_THEME_ICON = '🌙';
        const DELETE_ICON = '×';
        const EDIT_TEST_ICON = '✏️';
        const DELETE_TEST_ICON = '🗑️';
        // ***** TAMIL *****
        // YouTube URL-ஐ கண்டுபிடிக்க உதவும் Regex.
        const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:watch\?v=|embed\/|v\/)|youtu\.be\/)([a-zA-Z0-9_-]{11})(?:\S+)?/i;
        const imageUrlRegex = /(?<!src=["'])(?<!href=["'])(https?:\/\/[^\s()<>]+?\.(?:jpg|jpeg|png|gif|webp|bmp|heic|heif))/gi; // Added more image types
        const MAX_IMAGE_SIZE_MB = 4;
        const MAX_TOTAL_IMAGE_SIZE_MB = 16;
        const MAX_IMAGE_COUNT = 10; // Increased limit slightly
        const MAX_PDF_SIZE_MB = 50; // Limit for UI, File API can handle more
        const MAX_PDF_COUNT = 5;
        const MAX_AUDIO_SIZE_MB = 15; // Increased limit slightly
        const SUPPORTED_AUDIO_MIMES = ['audio/wav', 'audio/mp3', 'audio/mpeg', 'audio/aiff', 'audio/aac', 'audio/ogg', 'audio/flac'];
        const SUPPORTED_IMAGE_MIMES = ['image/png', 'image/jpeg', 'image/webp', 'image/heic', 'image/heif']; // From Gemini docs
        const RECORDING_TIME_LIMIT_SECONDS = 300; // 5 minutes
        const FILE_API_POLLING_INTERVAL_MS = 5000; // 5 seconds
        const FILE_API_PROCESSING_TIMEOUT_MS = 180000; // 3 minutes per file
        const CACHE_TTL_SECONDS = 3600; // Cache Time To Live: 1 hour

        // --- State Variables ---
        // ***** TAMIL *****
        // இங்க application-ன் நிலையை (state) track செய்ய variables-ஐ பயன்படுத்துகிறோம்.
        let API_KEY = '';
        let genAI = null; // GoogleGenerativeAI SDK instance
        let HarmCategory = null; // To store HarmCategory enum
        let HarmBlockThreshold = null; // To store HarmBlockThreshold enum
        let currentUser = null;
        let activeChatId = null;
        let currentChatHistory = []; // Stores history in {role, parts} format for SDK (populated from Firestore)
        let selectedModelId = DEFAULT_MODEL_ID; // State for selected model
        let currentTextSizeMultiplier = 1.0;
        let currentTheme = 'light';
        let isTestMode = false;
        let isReviewMode = false;
        let currentTestMCQs = [];
        let currentQuestionIndex = 0;
        let userAnswers = [];
        let testStartTime = null;
        let testTimerInterval = null;
        let reviewResultsCache = null;
        let cameFromAllTestsList = false;
        let activeChatListener = null; // Firestore listener for active chat messages
        let chatListListener = null; // Firestore listener for sidebar chat list
        let testListListener = null; // Firestore listener for saved tests
        let isDeletingChat = false;
        let allSavedTestsData = [];
        let selectedMediaItems = []; // { type: 'image'/'audio'/'pdf', file, base64?, mimeType?, name, id }
        let nextMediaId = 0;
        // Audio Recording State
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;
        let recordingStartTime = null;
        let recordingTimerInterval = null;
        let recorderStream = null;
        // Flag for SDK loading state
        let isAISdkReady = false;
        // Context Caching State
        let currentMediaCacheName = null; // Stores the name of the active cache for the current chat's media
        let cachedMediaUris = []; // Stores the URIs that are currently cached

        // --- Initialization ---
        initializeApp();

        // --- Event Listeners ---
        // ***** TAMIL *****
        // இங்க user actions-க்கு (click, input etc.) ஏற்ப functions-ஐ trigger செய்ய listeners-ஐ அமைக்கிறோம்.
        sendButton.addEventListener('click', handleSendMessage);
        userInput.addEventListener('input', () => {
            autoGrowTextarea();
            updateButtonStates(); // Update button states when input changes (e.g., YT URL pasted)
        });
        userInput.addEventListener('paste', () => {
            // Update button state slightly after paste allows the value to update
            setTimeout(updateButtonStates, 50);
        });
        userInput.addEventListener('keydown', handleInputKeydown);
        suggestionsContainer.addEventListener('click', handleSuggestionClick);
        startChatButton.addEventListener('click', createNewChat);
        chatListContainer.addEventListener('click', handleChatListClick);
        allTestsListContainer.addEventListener('click', handleAllTestsListClick);
        testSearchInput.addEventListener('input', filterTestsInSidebar);
        decreaseTextBtn.addEventListener('click', () => adjustTextSize(-TEXT_SIZE_STEP));
        increaseTextBtn.addEventListener('click', () => adjustTextSize(TEXT_SIZE_STEP));
        themeToggleButton.addEventListener('click', toggleTheme);
        modelSelector.addEventListener('change', handleModelSelectionChange); // Listener for model change
        prevQuestionBtn.addEventListener('click', () => handleTestNavigation('prev'));
        nextQuestionBtn.addEventListener('click', () => handleTestNavigation('next'));
        submitTestBtn.addEventListener('click', submitTest);
        exitReviewBtn.addEventListener('click', exitReview);
        chatArea.addEventListener('click', handleChatAreaClick);
        reviewFilters.addEventListener('click', handleReviewFilterClick);
        saveReviewBtn.addEventListener('click', saveTestReviewToCloud);
        loginBtn.addEventListener('click', signInWithGoogle);
        logoutBtn.addEventListener('click', signOut);
        // Media Listeners
        imageUploadButton.addEventListener('click', () => {
            if (!imageUploadButton.disabled) imageUploadInput.click();
        });
        imageUploadInput.addEventListener('change', handleImageFileSelect);
        pdfUploadButton.addEventListener('click', () => {
            if (!pdfUploadButton.disabled) pdfUploadInput.click();
        });
        pdfUploadInput.addEventListener('change', handlePdfFileSelect);
        audioUploadButton.addEventListener('click', () => {
            if (!audioUploadButton.disabled) audioUploadInput.click();
        });
        audioUploadInput.addEventListener('change', handleAudioFileSelect);
        recordAudioButton.addEventListener('click', () => {
             if (!recordAudioButton.disabled || isRecording) {
                toggleRecording();
             }
        });
        removeMediaButton.addEventListener('click', removeAllSelectedMedia);

        // Listen for SDK loaded event (set by module script)
        window.addEventListener('google-ai-sdk-loaded', () => {
            console.log("Caught 'google-ai-sdk-loaded' event.");
            isAISdkReady = true;
            HarmCategory = window.HarmCategory; // Get enums from window
            HarmBlockThreshold = window.HarmBlockThreshold;
            // If API key is already loaded, try initializing genAI now
            if (API_KEY && !genAI) {
                 initializeGenAIInstance(); // This now includes the .files check
                 // Re-evaluate button states if user is logged in
                 if(currentUser) {
                    console.log("Re-evaluating button states after SDK load.");
                    updateButtonStates();
                 }
            }
        });


        // --- Initialization Functions ---
        // ***** TAMIL *****
        // இந்த function app-ஐ ஆரம்பிக்கும்போது முதலில் run ஆகும்.
        async function initializeApp() {
            console.log("App Initializing (v10.3)..."); // Updated version
            setLoadingState(true, "Initializing...");
            chatArea.innerHTML = '';
            populateModelSelector(); // Populate dropdown first
            loadUserSettingsFromLocalStorage(); // Load theme/text size/model early
            await loadGeminiApiKey();
            fbAuth.onAuthStateChanged(handleAuthStateChange); // Sets up user auth listener
            switchView('chat');
            userInput.focus();
            console.log("App Initialization Complete.");
        }

        // ***** TAMIL *****
        // இங்க model selector dropdown-ல் AVAILABLE_MODELS array-வில் உள்ள options-ஐ சேர்க்கிறோம்.
        function populateModelSelector() {
            modelSelector.innerHTML = ''; // Clear existing options
            AVAILABLE_MODELS.forEach(model => {
                const option = document.createElement('option');
                option.value = model.id;
                option.textContent = model.name;
                // Set selected attribute if it matches the current state
                if (model.id === selectedModelId) {
                     option.selected = true;
                }
                modelSelector.appendChild(option);
            });
            console.log("Model selector populated.");
        }

        // loadGeminiApiKey remains mostly the same, ensures SDK init is called
        async function loadGeminiApiKey() {
             console.log("Attempting to load Gemini API Key...");
             API_KEY = localStorage.getItem(STORAGE_KEY_API_KEY);
             if(!API_KEY){
                 console.warn("!!! SECURITY WARNING !!! Using insecure API key storage. Use Cloud Functions in production.");
                 // API_KEY = "YOUR_API_KEY"; // FOR LOCAL TESTING ONLY - REMOVE BEFORE DEPLOYING
                 if(API_KEY){
                     localStorage.setItem(STORAGE_KEY_API_KEY, API_KEY);
                     console.log("Using potentially hardcoded insecure API Key.");
                 } else {
                     console.error("Gemini API Key is required. Please configure it in the script or localStorage.");
                     displayMessage("Error: Gemini API Key is not configured. AI features are disabled.", 'ai', ['error-message']);
                     API_KEY = ''; genAI = null; isAISdkReady = false;
                     updateButtonStates(); return false;
                 }
             } else {
                 console.log("Loaded insecure API Key from localStorage.");
             }

             if (API_KEY && isAISdkReady && !genAI) {
                return initializeGenAIInstance();
             } else if (API_KEY && !isAISdkReady) {
                 console.log("API Key loaded, but AI SDK not ready yet. Waiting for 'google-ai-sdk-loaded' event.");
                 return true;
             } else {
                 return !!API_KEY;
             }
        }

        // initializeGenAIInstance: Checks for File API and Harm types
        function initializeGenAIInstance() {
            if (!API_KEY || !isAISdkReady) {
                console.warn("Skipping genAI initialization. Conditions not met:", { API_KEY: !!API_KEY, isAISdkReady });
                return false;
            }
            // Check if HarmCategory/HarmBlockThreshold are loaded
             if (!HarmCategory || !HarmBlockThreshold) {
                 console.error("HarmCategory or HarmBlockThreshold enums not loaded from SDK. Cannot initialize safety settings correctly.");
                 // Proceed without safety settings? Or fail? Let's fail for now.
                  displayError("Error: Failed to load required safety components from AI SDK.");
                  genAI = null; isAISdkReady = false; // Indicate SDK isn't fully ready
                  updateButtonStates(); return false;
             }

            if (genAI) { genAI = null; console.log("Re-initializing genAI instance."); }

            console.log("Initializing GoogleGenerativeAI SDK instance...");
            try {
                 if (window.GoogleGenerativeAI) {
                     genAI = new window.GoogleGenerativeAI(API_KEY);
                     console.log("genAI object created:", genAI != null);

                     // Check for .files API and .caching API support in the loaded SDK
                     const supportsFiles = !!genAI?.files?.upload;
                     const supportsCaching = !!genAI?.caching?.createCachedContent;
                     console.log(`SDK Capabilities Check: File API: ${supportsFiles}, Caching API: ${supportsCaching}`);

                     if (supportsFiles) {
                        console.log("SUCCESS: GoogleGenerativeAI SDK instance created successfully with File API support (`genAI.files` FOUND).");
                     } else {
                        console.warn("WARNING: GoogleGenerativeAI SDK instance created, but `genAI.files` is MISSING. File uploads might fail or use older methods.");
                     }
                     if (!supportsCaching) {
                         console.warn("WARNING: GoogleGenerativeAI SDK instance created, but `genAI.caching` is MISSING. Context Caching feature will be disabled.");
                     }

                    return true; // Return true even if some features are missing, basic chat might work

                 } else {
                     console.error("ERROR: GoogleGenerativeAI SDK constructor not found on window object.");
                     displayError("Error: AI SDK loaded but failed to initialize.");
                     genAI = null; isAISdkReady = false; return false;
                 }
            } catch (e) {
                 console.error("CRITICAL ERROR initializing GoogleGenerativeAI:", e);
                 displayError(`Critical Error initializing AI SDK: ${e.message}. Check API Key & Console.`);
                 API_KEY = ''; localStorage.removeItem(STORAGE_KEY_API_KEY);
                 genAI = null; isAISdkReady = false; return false;
            } finally {
                 console.log("Updating button states finally after genAI initialization attempt.");
                 updateButtonStates();
            }
        }


        // --- Authentication Functions ---
        // ***** TAMIL *****
        // இந்த functions Google login/logout-ஐ கையாளுகின்றன.
        async function signInWithGoogle() {
             const provider = new firebase.auth.GoogleAuthProvider();
             try { setLoadingState(true, "Logging in..."); await fbAuth.signInWithPopup(provider); }
             catch (error) { console.error("Google Sign-In Error:", error); displayError(`Login failed: ${error.message || 'Unknown error'}`); setLoadingState(false); }
         }
        async function signOut() {
             try { setLoadingState(true, "Logging out..."); await fbAuth.signOut(); }
             catch (error) { console.error("Sign Out Error:", error); displayError(`Logout failed: ${error.message || 'Unknown error'}`); setLoadingState(false); }
         }

        // handleAuthStateChange: Resets cache state on logout/login
        // ***** TAMIL *****
        // User login/logout செய்யும்போது இந்த function run ஆகும். User data, chat list, test list load செய்யும்.
        // Refresh செய்தால், இது run ஆகி user logged in ஆக இருந்தால், history load ஆகும். அதனால் model-க்கு பழைய messages தெரியும்.
        function handleAuthStateChange(user) {
            console.log("Auth state changed. User:", user ? user.uid : 'None');
            setLoadingState(true, user ? "Loading user data..." : "Logging out...");

            // Clear previous state and listeners
            if (activeChatListener) { activeChatListener(); activeChatListener = null; console.log("Cleared active chat listener."); }
            if (chatListListener) { chatListListener(); chatListListener = null; console.log("Cleared chat list listener.");}
            if (testListListener) { testListListener(); testListListener = null; console.log("Cleared test list listener."); }
            stopRecording(true);
            chatArea.innerHTML = '';
            chatListContainer.innerHTML = `<div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">${user ? 'Loading chats...' : 'Please log in...'}</div>`;
            allTestsListContainer.innerHTML = `<div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">${user ? 'Loading tests...' : 'Login to see tests.'}</div>`;
            allTestsSection.classList.remove('visible');
            testSearchInput.value = '';
            activeChatId = null; currentChatHistory = []; isDeletingChat = false; allSavedTestsData = [];
            currentMediaCacheName = null; cachedMediaUris = []; // Reset cache state on auth change
            removeAllSelectedMedia();

            if (user) {
                currentUser = user; console.log("User logged in:", currentUser.uid);
                loginBtn.style.display = 'none'; logoutBtn.style.display = 'inline-block';
                accountEmail.textContent = currentUser.email || currentUser.displayName || `User`;
                accountAvatar.textContent = (currentUser.displayName || currentUser.email || 'U')[0].toUpperCase();
                accountPlan.textContent = "Firebase User";

                inputContainer.style.display = 'block';
                suggestionsContainer.style.display = 'flex';
                allTestsSection.classList.add('visible');

                loadUserSettings(currentUser.uid); // Includes applying theme/text size/model
                loadAndListenForChats(currentUser.uid); // <<<--- TAMIL: இங்கதான் login ஆனதும் chats load ஆகும்
                loadAndListenForTests(currentUser.uid);
                renderGreetingOrLoginPrompt();

            } else {
                currentUser = null; console.log("User logged out");
                loginBtn.style.display = 'inline-block'; logoutBtn.style.display = 'none';
                accountEmail.textContent = "Not logged in"; accountAvatar.textContent = '?'; accountPlan.textContent = "";

                inputContainer.style.display = 'none';
                suggestionsContainer.style.display = 'none';
                allTestsSection.classList.remove('visible');

                renderGreetingOrLoginPrompt();
                // Reset settings visually, also reset selected model to default
                currentTheme = 'light'; applyTheme();
                currentTextSizeMultiplier = 1.0; applyTextSize();
                selectedModelId = DEFAULT_MODEL_ID; applyModelSelection(); // Reset model selector UI
            }

            console.log("Updating button states after auth change.");
            updateButtonStates();
            setLoadingState(false);
        }

        // renderGreetingOrLoginPrompt remains the same
        function renderGreetingOrLoginPrompt() {
             chatArea.innerHTML = ''; // Clear first
             const greetingElement = document.createElement('div');
             greetingElement.classList.add('greeting');
             if (currentUser) {
                 greetingElement.innerHTML = `<span class="asterisk">*</span>Good day, ${currentUser.displayName || 'User'}!`;
                 chatArea.appendChild(greetingElement);
                 if (!activeChatId) {
                     displayMessage("Select a chat from the list or start a new one.", 'ai');
                 } else if (!API_KEY || !genAI) {
                     displayMessage("API Key missing or AI SDK failed to initialize. AI features are disabled. Please check API Key or reload.", 'ai', ['error-message']);
                 } else if (genAI && !genAI.files) {
                     displayMessage("File API is unavailable with the current AI configuration. PDF/Large File uploads are disabled.", 'ai', ['error-message']);
                 }
             }
             else {
                 greetingElement.innerHTML = `<span class="asterisk">*</span>Welcome!`;
                 chatArea.appendChild(greetingElement);
                 displayMessage("Please log in with Google to use the chat and save your history.", 'ai');
             }
             scrollToBottom(true);
         }

        // --- Settings (Theme/Text Size/Model) ---
        // ***** TAMIL *****
        // இந்த functions theme, text size, மற்றும் model selection-ஐ load/save செய்கின்றன.
        function loadUserSettingsFromLocalStorage() {
             const savedTheme = localStorage.getItem('chatTheme');
             const savedTextSize = localStorage.getItem('chatTextSizeMultiplier');
             const savedModelId = localStorage.getItem(STORAGE_KEY_MODEL_ID); // Load saved model
             currentTheme = savedTheme || 'light';
             currentTextSizeMultiplier = savedTextSize ? parseFloat(savedTextSize) : 1.0;
             // Validate saved model ID against available models
             selectedModelId = AVAILABLE_MODELS.some(m => m.id === savedModelId) ? savedModelId : DEFAULT_MODEL_ID;

             applyTheme();
             applyTextSize();
             applyModelSelection(); // Apply model selection to UI
        }
        async function loadUserSettings(userId) {
            const userDocRef = db.collection('users').doc(userId);
            try {
                const docSnap = await userDocRef.get();
                if (docSnap.exists) {
                    const settings = docSnap.data();
                    currentTheme = settings.theme || currentTheme;
                    currentTextSizeMultiplier = settings.textSizeMultiplier || currentTextSizeMultiplier;
                    // Load and validate model from Firestore
                    const firestoreModelId = settings.selectedModelId;
                    selectedModelId = AVAILABLE_MODELS.some(m => m.id === firestoreModelId) ? firestoreModelId : selectedModelId; // Keep local if FS invalid or empty
                    console.log("Loaded user settings from Firestore:", settings);
                } else {
                    console.log("No user settings found in Firestore, using local/defaults.");
                }
            } catch (error) {
                console.error("Error loading user settings from Firestore:", error);
            } finally {
                applyTheme();
                applyTextSize();
                applyModelSelection(); // Apply loaded model selection to UI
            }
        }
        async function saveUserSettings() {
            // Save to Local Storage immediately
            localStorage.setItem('chatTheme', currentTheme);
            localStorage.setItem('chatTextSizeMultiplier', currentTextSizeMultiplier.toString());
            localStorage.setItem(STORAGE_KEY_MODEL_ID, selectedModelId); // Save selected model

            // Save to Firestore if logged in
            if (!currentUser) return;
            const userDocRef = db.collection('users').doc(currentUser.uid);
            const settings = {
                theme: currentTheme,
                textSizeMultiplier: currentTextSizeMultiplier,
                selectedModelId: selectedModelId // Save model to Firestore
            };
            try {
                await userDocRef.set(settings, { merge: true });
                console.log("User settings saved to Firestore:", settings);
            } catch (error) {
                console.error("Error saving user settings to Firestore:", error);
            }
        }
        function applyTheme() { if(currentTheme==='dark'){ document.body.classList.add('dark-theme'); themeToggleButton.textContent=LIGHT_THEME_ICON; themeToggleButton.title="Switch to Light Theme"; } else { document.body.classList.remove('dark-theme'); themeToggleButton.textContent=DARK_THEME_ICON; themeToggleButton.title="Switch to Dark Theme"; } }
        function toggleTheme() { currentTheme = (currentTheme === 'light') ? 'dark' : 'light'; applyTheme(); saveUserSettings(); }
        function applyTextSize() { const newSize = `calc(var(--message-font-size-base) * ${currentTextSizeMultiplier})`; document.documentElement.style.setProperty('--message-font-size', newSize); updateButtonStates(); }
        function adjustTextSize(change) { let newMultiplier = Math.max(MIN_TEXT_SIZE_MULTIPLIER, Math.min(MAX_TEXT_SIZE_MULTIPLIER, currentTextSizeMultiplier + change)); newMultiplier = Math.round(newMultiplier * 10) / 10; if (newMultiplier !== currentTextSizeMultiplier) { currentTextSizeMultiplier = newMultiplier; applyTextSize(); saveUserSettings(); } }

        // ***** TAMIL *****
        // இங்க model selector-ல் user தேர்வு செய்த model-ஐ UI-ல் காட்டுகிறோம்.
        function applyModelSelection() {
            if (modelSelector) {
                 modelSelector.value = selectedModelId;
                 console.log(`Applied model selection: ${selectedModelId}`);
             }
             // Reset cache state if the new model doesn't support it
             const modelInfo = AVAILABLE_MODELS.find(m => m.id === selectedModelId);
             if (currentMediaCacheName && (!modelInfo || !modelInfo.supportsCaching)) {
                 console.warn(`Model ${selectedModelId} does not support caching or is unknown. Clearing active cache state.`);
                 // Optionally delete the cache from the backend here if needed
                 // try { await genAI.caching.deleteCachedContent(currentMediaCacheName); } catch(e) {}
                 currentMediaCacheName = null;
                 cachedMediaUris = [];
             }
        }
        // ***** TAMIL *****
        // இங்க user model-ஐ மாற்றும்போது அதை state-ல் update செய்து save செய்கிறோம்.
        // Caching வேலை செய்யுமா என்றும் check செய்கிறோம்.
        function handleModelSelectionChange(event) {
            const newModelId = event.target.value;
            if (newModelId !== selectedModelId) {
                console.log(`Model selection changed to: ${newModelId}`);
                selectedModelId = newModelId;
                applyModelSelection(); // Update UI and potentially clear cache state
                saveUserSettings(); // Save the new selection
                 // Provide feedback if caching might be affected
                const modelInfo = AVAILABLE_MODELS.find(m => m.id === selectedModelId);
                if (modelInfo && !modelInfo.supportsCaching) {
                     console.warn(`Selected model ${selectedModelId} does not support or is not configured for context caching.`);
                     // Display info message to user? (Optional)
                     // displayMessage(`Info: The selected model (${modelInfo.name}) may not support context caching.`, 'ai', ['info-message']);
                } else if (modelInfo && modelInfo.supportsCaching) {
                     console.log(`Selected model ${selectedModelId} supports context caching.`);
                     // Display info message to user? (Optional)
                     // displayMessage(`Info: The selected model (${modelInfo.name}) supports context caching for faster responses with large files (select PDFs).`, 'ai', ['info-message']);
                }
            }
        }

        // --- Chat Storage & Loading (Firestore) ---
        // loadAndListenForChats remains the same
        // ***** TAMIL *****
        // இந்த function Firestore-லிருந்து sidebar-ல் chat list-ஐ load செய்து காட்டுகிறது.
        // User login செய்ததும் இது run ஆகும்.
        function loadAndListenForChats(userId) {
            if (chatListListener) { chatListListener(); chatListListener = null; }
            const chatsRef = db.collection('chats').where('userId', '==', userId).orderBy('lastUpdated', 'desc');
            console.log(`Listening for chats for user ${userId}`);
            chatListListener = chatsRef.onSnapshot(snapshot => {
                 if (isDeletingChat) { console.log("Skipping chat list update during delete."); return; }
                const chats = []; snapshot.forEach(doc => { chats.push({ id: doc.id, ...doc.data() }); });
                console.log("Received chat list snapshot:", chats.length, "chats");
                renderSidebarChatList(chats);
                let chatToLoad = activeChatId;
                if (!chatToLoad || !chats.some(c => c.id === chatToLoad)) {
                     chatToLoad = chats.length > 0 ? chats[0].id : null;
                     if (chatToLoad) console.log("Active chat gone or none selected, switching to newest:", chatToLoad);
                     else console.log("No active chat and no existing chats found.");
                }

                if (chatToLoad && chatToLoad !== activeChatId) {
                     switchChat(chatToLoad);
                } else if (chatToLoad && chatToLoad === activeChatId) {
                     highlightActiveChatInSidebar();
                     console.log("Chat list updated, keeping same active chat. Updating button states.");
                     updateButtonStates();
                     setLoadingState(false);
                } else {
                     activeChatId = null; currentChatHistory = [];
                     if (activeChatListener) { activeChatListener(); activeChatListener = null; }
                     renderGreetingOrLoginPrompt();
                     console.log("No chat selected. Updating button states.");
                     updateButtonStates(); setLoadingState(false);
                     currentMediaCacheName = null; cachedMediaUris = []; // Clear cache state if no chat selected
                }
            }, error => { console.error("Error listening for chats:", error); displayError("Could not load chat list."); chatListContainer.innerHTML = '<div style="padding:10px;color:var(--error-text);">Error loading chats.</div>'; setLoadingState(false); });
        }
        // renderSidebarChatList remains the same
        function renderSidebarChatList(chats) {
            chatListContainer.innerHTML = ''; if (!currentUser) { chatListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);">Please log in.</div>'; return; }
            if (chats.length === 0) { chatListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);">No chats yet. Start one!</div>'; }
            else { chats.forEach(chatData => { const itemElement = document.createElement('div'); itemElement.classList.add('chat-list-item'); let title = chatData.title; if (typeof title !== 'string' || !title.trim()) { title = '(Untitled Chat)'; } title = title.trim(); itemElement.textContent = title; itemElement.dataset.id = chatData.id; itemElement.title = title; const deleteBtn = document.createElement('button'); deleteBtn.classList.add('delete-chat-button'); deleteBtn.innerHTML = DELETE_ICON; deleteBtn.title = "Delete chat"; deleteBtn.dataset.id = chatData.id; itemElement.appendChild(deleteBtn); chatListContainer.appendChild(itemElement); }); }
            highlightActiveChatInSidebar();
        }
        // highlightActiveChatInSidebar remains the same
        function highlightActiveChatInSidebar() { const items = chatListContainer.querySelectorAll('.chat-list-item'); items.forEach(item => { item.classList.toggle('active', item.dataset.id === activeChatId); }); }


        // --- Media Handling Functions ---
        // ***** TAMIL *****
        // இந்த functions image, pdf, audio upload செய்வதை கையாளுகின்றன.
        // handleImageFileSelect, handlePdfFileSelect, handleAudioFileSelect remain the same
         function handleImageFileSelect(event) {
            console.log("handleImageFileSelect triggered");
            if (selectedMediaItems.length > 0 && selectedMediaItems.some(item => item.type === 'pdf' || item.type === 'audio')) {
                alert("Cannot select images when PDF(s) or audio are already selected. Please remove other media first.");
                imageUploadInput.value = ''; return;
            }
            // ***** TAMIL *****
            // YouTube URL paste செய்திருந்தால், image upload செய்ய முடியாது.
             if (youtubeRegex.test(userInput.value.trim())) {
                 alert("Cannot upload images when a YouTube URL is present in the input. Please remove the URL first.");
                 imageUploadInput.value = ''; return;
             }
            const files = event.target.files;
            if (!files || files.length === 0) { imageUploadInput.value = ''; return; }
            let currentImageCount = selectedMediaItems.filter(item => item.type === 'image').length;
            let addedCount = 0;
            let totalSizeMB = selectedMediaItems.reduce((sum, item) => sum + (item.file?.size || 0), 0) / 1024 / 1024;
            // ***** TAMIL *****
            // Gemini support செய்யும் image mime type-களை பயன்படுத்துகிறோம்.
            const allowedTypes = SUPPORTED_IMAGE_MIMES;
            for (const file of files) {
                if (currentImageCount >= MAX_IMAGE_COUNT) { alert(`Maximum ${MAX_IMAGE_COUNT} images allowed.`); break; }
                if (!allowedTypes.includes(file.type)) { console.warn(`Skipping invalid file type: ${file.name} (${file.type})`); continue; }
                const fileSizeMB = file.size / 1024 / 1024;
                if (fileSizeMB > MAX_IMAGE_SIZE_MB) { alert(`Image "${file.name}" (${fileSizeMB.toFixed(1)}MB) exceeds ${MAX_IMAGE_SIZE_MB}MB limit.`); continue; }
                if (totalSizeMB + fileSizeMB > MAX_TOTAL_IMAGE_SIZE_MB) { alert(`Adding "${file.name}" would exceed total image size limit of ${MAX_TOTAL_IMAGE_SIZE_MB}MB.`); continue; }
                const mediaId = nextMediaId++;
                selectedMediaItems.push({ id: mediaId, type: 'image', file: file, base64: null, mimeType: file.type, name: file.name });
                currentImageCount++; totalSizeMB += fileSizeMB; addedCount++;
            }
             if (addedCount > 0) { console.log(`Added ${addedCount} images. Total images: ${currentImageCount}`); displayMediaPreview(); }
             imageUploadInput.value = '';
        }
        function handlePdfFileSelect(event) {
            console.log("handlePdfFileSelect triggered");
            if (selectedMediaItems.length > 0 && selectedMediaItems.some(item => item.type === 'image' || item.type === 'audio')) {
                alert("Cannot select PDF(s) when image(s) or audio are already selected. Please remove other media first.");
                pdfUploadInput.value = ''; return;
            }
            // ***** TAMIL *****
            // YouTube URL paste செய்திருந்தால், PDF upload செய்ய முடியாது.
             if (youtubeRegex.test(userInput.value.trim())) {
                 alert("Cannot upload PDFs when a YouTube URL is present in the input. Please remove the URL first.");
                 pdfUploadInput.value = ''; return;
             }
             if (!genAI || !genAI.files) {
                 alert("PDF upload is currently disabled because the File API is unavailable.");
                 pdfUploadInput.value = ''; return;
            }
            const files = event.target.files;
            if (!files || files.length === 0) { pdfUploadInput.value = ''; return; }
            let currentPdfCount = selectedMediaItems.filter(item => item.type === 'pdf').length;
            let addedCount = 0;
            for (const file of files) {
                if (currentPdfCount >= MAX_PDF_COUNT) { alert(`Maximum ${MAX_PDF_COUNT} PDF files allowed.`); break; }
                if (file.type !== 'application/pdf') { console.warn(`Skipping non-PDF file: ${file.name} (${file.type})`); continue; }
                const fileSizeMB = file.size / 1024 / 1024;
                if (fileSizeMB > MAX_PDF_SIZE_MB) { alert(`PDF "${file.name}" (${fileSizeMB.toFixed(1)}MB) exceeds ${MAX_PDF_SIZE_MB}MB limit (for preview). It might still work with the API.`); console.warn(`Large PDF selected: ${fileSizeMB.toFixed(1)}MB`); }
                 const mediaId = nextMediaId++;
                 selectedMediaItems.push({ id: mediaId, type: 'pdf', file: file, name: file.name, mimeType: file.type });
                 currentPdfCount++; addedCount++;
            }
             if (addedCount > 0) { console.log(`Added ${addedCount} PDFs. Total PDFs: ${currentPdfCount}`); displayMediaPreview(); }
             pdfUploadInput.value = '';
        }
        function handleAudioFileSelect(event) {
            console.log("handleAudioFileSelect triggered");
            if (selectedMediaItems.length > 0 && selectedMediaItems.some(item => item.type === 'image' || item.type === 'pdf')) {
                alert("Cannot select audio when image(s) or PDF(s) are already selected. Please remove other media first.");
                audioUploadInput.value = ''; return;
            }
            // ***** TAMIL *****
            // YouTube URL paste செய்திருந்தால், audio upload செய்ய முடியாது.
             if (youtubeRegex.test(userInput.value.trim())) {
                 alert("Cannot upload audio when a YouTube URL is present in the input. Please remove the URL first.");
                 audioUploadInput.value = ''; return;
             }
            removeAllSelectedMedia();
            const file = event.target.files[0];
            if (!file) { audioUploadInput.value = ''; return; }
            if (!SUPPORTED_AUDIO_MIMES.includes(file.type)) { alert(`Unsupported audio file type: ${file.type}. Supported: ${SUPPORTED_AUDIO_MIMES.join(', ')}`); audioUploadInput.value = ''; return; }
            const fileSizeMB = file.size / 1024 / 1024;
            if (fileSizeMB > MAX_AUDIO_SIZE_MB) { alert(`Audio file too large (${fileSizeMB.toFixed(1)}MB). Max ${MAX_AUDIO_SIZE_MB}MB.`); audioUploadInput.value = ''; return; }
            const reader = new FileReader();
            reader.onload = (e) => {
                 const mediaId = nextMediaId++;
                selectedMediaItems = [{ id: mediaId, type: 'audio', file: file, base64: e.target.result, mimeType: file.type, name: file.name }];
                console.log("Audio selected and read:", file.name);
                displayMediaPreview();
            }
            reader.onerror = (error) => { console.error("Error reading audio file:", error); alert("Error reading audio file."); removeAllSelectedMedia(); };
            audioUploadInput.value = '';
            reader.readAsDataURL(file);
        }
        // displayMediaPreview, renderImagePreviewItem, renderPdfPreviewItem remain the same
        function displayMediaPreview() {
            console.log("displayMediaPreview. Items:", selectedMediaItems.length);
            imagePreviewsList.innerHTML = ''; // Clear both image and PDF previews here
            previewAudioContainer.style.display = 'none';
            previewAudio.removeAttribute('src');
            mediaPreviewInfo.textContent = '';
            imagePreviewsList.style.display = 'none'; // Hide initially
            imagePreviewsList.style.flexDirection = ''; // Reset style
            imagePreviewsList.style.alignItems = ''; // Reset style

            if (selectedMediaItems.length === 0) {
                mediaPreviewContainer.style.display = 'none';
                updateButtonStates(); // Update buttons when media is cleared
                return;
            }

            const audioItem = selectedMediaItems.find(item => item.type === 'audio');
            const imageItems = selectedMediaItems.filter(item => item.type === 'image');
            const pdfItems = selectedMediaItems.filter(item => item.type === 'pdf');
            let infoText = "";

            if (audioItem) {
                imagePreviewsList.style.display = 'none'; // Ensure hidden
                try {
                    previewAudio.src = audioItem.base64; previewAudio.load(); previewAudioContainer.style.display = 'flex';
                    infoText = `1 audio file: ${audioItem.name || 'Audio'}`;
                } catch (e) { console.error("Error setting audio src:", e); infoText = 'Error loading audio preview'; }
            } else if (imageItems.length > 0) {
                previewAudioContainer.style.display = 'none';
                imagePreviewsList.style.display = 'flex'; // Show image preview list
                imagePreviewsList.style.flexDirection = 'row'; // Set for images
                imagePreviewsList.style.alignItems = 'flex-start'; // Set for images
                imageItems.forEach(item => {
                     if (!item.base64) {
                         const reader = new FileReader();
                         reader.onload = (e) => { item.base64 = e.target.result; renderImagePreviewItem(item); };
                         reader.onerror = () => { item.base64 = '#error'; renderImagePreviewItem(item); };
                         reader.readAsDataURL(item.file);
                     } else { renderImagePreviewItem(item); }
                });
                infoText = `${imageItems.length} image(s) selected`;
            } else if (pdfItems.length > 0) {
                 previewAudioContainer.style.display = 'none';
                 imagePreviewsList.style.display = 'flex'; // Show PDF preview list
                 imagePreviewsList.style.flexDirection = 'column'; // Set for PDFs
                 imagePreviewsList.style.alignItems = 'stretch'; // Set for PDFs
                 pdfItems.forEach(item => renderPdfPreviewItem(item));
                 infoText = `${pdfItems.length} PDF file(s) selected`;
            }

            mediaPreviewInfo.textContent = infoText;
            mediaPreviewContainer.style.display = 'flex';
            updateButtonStates(); // Update buttons when media is displayed
        }
        function renderImagePreviewItem(item) {
             try {
                 const existingItem = imagePreviewsList.querySelector(`.image-preview-item[data-media-id="${item.id}"]`);
                 if (existingItem) return;
                 const itemContainer = document.createElement('div');
                 itemContainer.classList.add('image-preview-item'); itemContainer.dataset.mediaId = item.id;
                 const img = document.createElement('img');
                 img.src = item.base64 === '#error' ? '' : (item.base64 || '');
                 img.alt = item.base64 === '#error' ? 'Preview error' : (item.name || 'Image');
                 img.title = item.name || 'Image';
                 img.onerror = () => { img.alt = "Preview load error"; img.src = ""; };
                 const removeBtn = document.createElement('button');
                 removeBtn.classList.add('remove-image-item-button'); removeBtn.innerHTML = '&times;'; removeBtn.title = `Remove ${item.name || 'image'}`;
                 removeBtn.onclick = (e) => { e.stopPropagation(); removeSelectedMediaItem(item.id); };
                 itemContainer.appendChild(img); itemContainer.appendChild(removeBtn); imagePreviewsList.appendChild(itemContainer);
             } catch (e) { console.error("Error creating image preview element:", e); }
        }
        function renderPdfPreviewItem(item) {
             try {
                 const existingItem = imagePreviewsList.querySelector(`.pdf-preview-item[data-media-id="${item.id}"]`);
                 if (existingItem) return; // Avoid duplicates
                 const itemContainer = document.createElement('div');
                 itemContainer.classList.add('pdf-preview-item'); itemContainer.dataset.mediaId = item.id;
                 const icon = document.createElement('span'); icon.textContent = '📄'; icon.style.marginRight = '4px';
                 const nameSpan = document.createElement('span'); nameSpan.textContent = item.name || 'PDF File'; nameSpan.title = item.name || 'PDF File';
                 const removeBtn = document.createElement('button');
                 removeBtn.innerHTML = '&times;'; removeBtn.title = `Remove ${item.name || 'PDF'}`;
                 removeBtn.onclick = (e) => { e.stopPropagation(); removeSelectedMediaItem(item.id); };
                 itemContainer.appendChild(icon); itemContainer.appendChild(nameSpan); itemContainer.appendChild(removeBtn); imagePreviewsList.appendChild(itemContainer);
             } catch (e) { console.error("Error creating PDF preview element:", e); }
        }
        // removeSelectedMediaItem, removeAllSelectedMedia remain the same
        function removeSelectedMediaItem(mediaId) {
             console.log(`Removing media item ID: ${mediaId}`);
             selectedMediaItems = selectedMediaItems.filter(item => item.id !== mediaId);
             displayMediaPreview(); // This will also call updateButtonStates
             // If the removed media was the cached media, clear the cache state
             if (currentMediaCacheName && cachedMediaUris.length > 0 && !selectedMediaItems.some(item => item.type === 'pdf')) {
                  console.log("Removed last cached media type (PDF). Clearing cache state.");
                  // Optionally delete the cache from backend here
                  // try { await genAI.caching.deleteCachedContent(currentMediaCacheName); } catch(e){}
                  currentMediaCacheName = null;
                  cachedMediaUris = [];
             }
        }
        function removeAllSelectedMedia() {
            console.log("removeAllSelectedMedia called.");
            stopRecording(true); // Ensure recording stops if active
            selectedMediaItems = []; nextMediaId = 0;
            imagePreviewsList.innerHTML = ''; previewAudio.removeAttribute('src');
            previewAudioContainer.style.display = 'none'; mediaPreviewContainer.style.display = 'none';
            mediaPreviewInfo.textContent = ''; imagePreviewsList.style.flexDirection = ''; imagePreviewsList.style.alignItems = '';
            imageUploadInput.value = ''; pdfUploadInput.value = ''; audioUploadInput.value = '';
             // Clear cache state if media is removed
             if (currentMediaCacheName) {
                  console.log("All media removed. Clearing active media cache state.");
                   // Optionally delete the cache from backend here
                   // try { await genAI.caching.deleteCachedContent(currentMediaCacheName); } catch(e){}
                  currentMediaCacheName = null;
                  cachedMediaUris = [];
             }
            console.log("All selected media removed, inputs reset, cache state cleared.");
            updateButtonStates(); // Update buttons after clearing media
        }


        // --- Audio Recording Functions ---
        // ***** TAMIL *****
        // இந்த functions audio record செய்வதை கையாளுகின்றன.
        // toggleRecording, startRecording, stopRecording, resetRecordingUI remain the same
        async function toggleRecording() {
            if (isRecording) { stopRecording(); }
            else {
                if (selectedMediaItems.some(item => item.type === 'image' || item.type === 'pdf')) { alert("Cannot record audio when images or PDFs are selected. Remove them first."); return; }
                // ***** TAMIL *****
                // YouTube URL paste செய்திருந்தால், audio record செய்ய முடியாது.
                 if (youtubeRegex.test(userInput.value.trim())) {
                     alert("Cannot record audio when a YouTube URL is present in the input. Please remove the URL first.");
                     return;
                 }
                if (sendButton.disabled && !isRecording) {
                     const appReady = currentUser && API_KEY && genAI && activeChatId;
                     if (!appReady || userInput.placeholder.includes("Generating") || userInput.placeholder.includes("Sending") || userInput.placeholder.includes("Uploading") || userInput.placeholder.includes("Recording")) {
                          alert("Please wait for the current action to complete or ensure you are logged in with a valid API key and active chat."); return;
                     }
                }
                await startRecording();
            }
        }
        async function startRecording() {
            console.log("Attempting to start recording...");
            if (selectedMediaItems.length > 0) { alert("Cannot record audio when other media is selected. Please remove it first."); return; }
            if (youtubeRegex.test(userInput.value.trim())) { alert("Cannot record audio when a YouTube URL is present in the input. Please remove the URL first."); return; }
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) { alert("Audio recording is not supported by your browser."); console.error("getUserMedia not supported."); return; }
            try {
                console.log("Requesting microphone access...");
                if (recorderStream) { recorderStream.getTracks().forEach(track => track.stop()); recorderStream = null; console.warn("Stopped lingering recorder stream."); }
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                recorderStream = stream; console.log("Microphone access granted."); recordAudioButton.disabled = true;
                let options = {};
                const preferredMimeTypes = ['audio/ogg;codecs=opus', 'audio/webm;codecs=opus', 'audio/aac', 'audio/mp4'];
                for (const mimeType of preferredMimeTypes) { if (MediaRecorder.isTypeSupported(mimeType)) { options.mimeType = mimeType; break; } }
                if (!options.mimeType) console.warn("No preferred MIME type supported, using browser default.");
                mediaRecorder = new MediaRecorder(stream, options);
                const actualMimeType = mediaRecorder.mimeType; console.log("Initializing MediaRecorder. Options:", options, "Actual MIME type:", actualMimeType);
                audioChunks = [];
                mediaRecorder.ondataavailable = (event) => { if (event.data.size > 0) { audioChunks.push(event.data); } };
                mediaRecorder.onstop = () => {
                    console.log("MediaRecorder stopped. Chunks:", audioChunks.length);
                    if (recorderStream) { recorderStream.getTracks().forEach(track => track.stop()); console.log("Microphone stream tracks stopped."); recorderStream = null; }
                    isRecording = false; recordingStatus.classList.remove('visible');
                    recordAudioButton.classList.remove('recording'); recordAudioButton.textContent = '🎙️'; recordAudioButton.title = 'Record audio';
                    if (recordingTimerInterval) { clearInterval(recordingTimerInterval); recordingTimerInterval = null; }
                    if (audioChunks.length === 0) { console.warn("No audio data recorded."); setLoadingState(false); updateButtonStates(); return; } // Added setLoadingState(false) here
                    const audioBlob = new Blob(audioChunks, { type: actualMimeType });
                    audioChunks = []; const fileSizeMB = audioBlob.size / 1024 / 1024;
                    console.log(`Recording complete. Blob size: ${fileSizeMB.toFixed(3)} MB, Type: ${actualMimeType}`);
                    if (audioBlob.size === 0) { console.warn("Created Blob has size 0."); alert("Recording failed: No audio data captured."); setLoadingState(false); updateButtonStates(); return; } // Added setLoadingState(false) here
                    if (fileSizeMB > MAX_AUDIO_SIZE_MB) { alert(`Recorded audio too large (${fileSizeMB.toFixed(1)}MB). Max ${MAX_AUDIO_SIZE_MB}MB.`); setLoadingState(false); updateButtonStates(); return; } // Added setLoadingState(false) here
                    const reader = new FileReader();
                    setLoadingState(true, "Processing audio...");
                    reader.onloadend = () => {
                         if (reader.result && typeof reader.result === 'string' && reader.result.startsWith('data:')) {
                            let finalMimeType = actualMimeType.split(';')[0]; const mediaId = nextMediaId++;
                            selectedMediaItems = [{ id: mediaId, type: 'audio', file: new File([audioBlob], `recording.audio`, { type: finalMimeType }), base64: reader.result, mimeType: finalMimeType, name: `recording-${new Date().toISOString().substring(0, 19).replace(/[:T]/g, '-')}.${finalMimeType.split('/')[1] || 'audio'}` }];
                            displayMediaPreview(); // This will call updateButtonStates
                         } else { console.error("FileReader result invalid."); alert("Error processing recorded audio (Invalid data)."); }
                         setLoadingState(false); // Stop processing state
                         // updateButtonStates(); // displayMediaPreview handles this
                    };
                    reader.onerror = (error) => { console.error("Error converting recorded audio blob:", error); alert("Error processing recorded audio."); setLoadingState(false); updateButtonStates(); };
                    reader.readAsDataURL(audioBlob);
                };
                mediaRecorder.onerror = (event) => { console.error("MediaRecorder error:", event.error || event); alert(`Recording error: ${event.error?.name || 'Unknown'}`); stopRecording(true); }; // stopRecording will handle setLoadingState(false)
                mediaRecorder.start(); isRecording = true; recordingStartTime = Date.now();
                recordAudioButton.classList.add('recording'); recordAudioButton.textContent = '🛑'; recordAudioButton.title = 'Stop recording';
                recordingStatus.classList.add('visible'); recordingTimerSpan.textContent = '0s';
                setLoadingState(true, "Recording..."); // Set loading state for recording
                recordingTimerInterval = setInterval(() => {
                    const elapsedSeconds = Math.floor((Date.now() - recordingStartTime) / 1000);
                    recordingTimerSpan.textContent = `${elapsedSeconds}s`;
                    if (elapsedSeconds >= RECORDING_TIME_LIMIT_SECONDS) { console.log("Recording time limit."); stopRecording(); alert(`Stopped after ${RECORDING_TIME_LIMIT_SECONDS} seconds.`); }
                }, 1000);
                console.log("Recording started..."); recordAudioButton.disabled = false;
            } catch (error) {
                console.error("Error starting recording:", error);
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') { alert("Microphone access denied. Please allow access in browser settings."); }
                else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') { alert("No microphone found."); }
                else { alert(`Could not start recording: ${error.name}`); }
                stopRecording(true); // Ensure cleanup and setLoadingState(false) on error
            }
        }
        function stopRecording(force = false) {
            console.log("stopRecording called. isRecording:", isRecording, "force:", force);
            if (mediaRecorder && (isRecording || force)) {
                try {
                    if (mediaRecorder.state === "recording" || mediaRecorder.state === "paused") {
                         mediaRecorder.stop(); // onstop handler will manage UI reset and state
                         console.log("MediaRecorder.stop() called.");
                         // Let onstop handle setLoadingState(false) unless forcing
                         if (force && !isRecording) { // If forcing stop on an already stopped recorder
                              resetRecordingUI();
                              setLoadingState(false); // Explicitly turn off loading if forced stop on inactive
                         }
                    } else if (force) {
                         console.log("Recorder not active, forcing cleanup.");
                         resetRecordingUI();
                         setLoadingState(false);
                    }
                }
                catch (error) {
                    console.error("Error calling mediaRecorder.stop():", error);
                    resetRecordingUI();
                    setLoadingState(false); // Ensure loading state is off on error
                }
            } else if (force) {
                 console.log("No recorder or not recording, forced stop.");
                resetRecordingUI();
                setLoadingState(false);
            } else {
                console.log("Not recording or recorder not available.");
                 // If stop was called naturally but wasn't recording, ensure loading is off
                 if (!isRecording) {
                      setLoadingState(false);
                      updateButtonStates();
                 }
            }
        }
        function resetRecordingUI() {
            console.log("Resetting recording UI/state."); isRecording = false;
            if (recordAudioButton) { recordAudioButton.classList.remove('recording'); recordAudioButton.textContent = '🎙️'; recordAudioButton.title = 'Record audio'; }
            if (recordingStatus) recordingStatus.classList.remove('visible');
            if (recordingTimerInterval) { clearInterval(recordingTimerInterval); recordingTimerInterval = null; }
            if (recorderStream) { recorderStream.getTracks().forEach(track => track.stop()); console.log("Mic stream stopped (reset UI)."); recorderStream = null; }
            mediaRecorder = null; audioChunks = [];
            // Don't call setLoadingState(false) here directly
            // Call updateButtonStates to reflect non-recording state
            console.log("Updating button states after resetting recording UI.");
            updateButtonStates();
        }


        // --- Chat Creation, Deletion, Switching ---
        // ***** TAMIL *****
        // இந்த functions புதிய chat உருவாக்குவது, அழிப்பது, வேறு chat-க்கு மாறுவது ஆகியவற்றை கையாளுகின்றன.
        // createNewChat remains the same
        async function createNewChat() {
            if (!currentUser || startChatButton.disabled) { displayError("Please log in or wait for current action."); return; }
            setLoadingState(true, "Creating chat...");
            removeAllSelectedMedia(); // Clears media and cache state
            const newChatRef = db.collection('chats').doc();
            const timestamp = firebase.firestore.FieldValue.serverTimestamp();
            try {
                await newChatRef.set({ userId: currentUser.uid, title: NEW_CHAT_TITLE, createdAt: timestamp, lastUpdated: timestamp });
                console.log("New chat created:", newChatRef.id);
                // Listener will automatically pick it up and switch
            } catch (error) { console.error("Error creating new chat:", error); displayError("Failed to create chat."); setLoadingState(false); }
        }
        // handleChatListClick remains the same
        function handleChatListClick(event) {
             const target = event.target;
             const deleteButton = target.closest('.delete-chat-button');
             if (deleteButton) { event.stopPropagation(); const chatId = deleteButton.dataset.id; const chatListItem = deleteButton.closest('.chat-list-item'); const chatTitle = chatListItem?.textContent?.replace(deleteButton.textContent, '').trim() || 'this chat'; if (chatId) { confirmAndDeleteChat(chatId, chatTitle); } return; }
             const item = target.closest('.chat-list-item'); const clickedId = item?.dataset?.id; if (item && clickedId && clickedId !== activeChatId) { switchChat(clickedId); }
         }
        // confirmAndDeleteChat remains the same
        function confirmAndDeleteChat(chatId, chatTitle) { if (!currentUser || !chatId) return; if (confirm(`Delete chat "${chatTitle}" permanently?`)) { deleteChatFromFirestore(chatId); } else { console.log(`Deletion cancelled for chat: ${chatId}`); } }
        // deleteChatFromFirestore remains the same
        async function deleteChatFromFirestore(chatId) {
            if (!currentUser || !chatId) return; isDeletingChat = true; console.log(`[Delete Start] Chat: ${chatId}`); setLoadingState(true, "Deleting chat...");
            const chatDocRef = db.collection('chats').doc(chatId); const messagesRef = chatDocRef.collection('messages');
            try {
                const messagesSnapshot = await messagesRef.get(); if (!messagesSnapshot.empty) { const batch = db.batch(); messagesSnapshot.docs.forEach(doc => { batch.delete(doc.ref); }); await batch.commit(); console.log(`[Delete] Deleted ${messagesSnapshot.size} messages.`); }
                await chatDocRef.delete(); console.log(`[Delete Success] Chat doc: ${chatId}`);
                 // Also attempt to delete any associated context cache (best effort)
                 const cacheNameToDelete = `cache-${chatId}-media`; // Simple potential name
                 try {
                     // Need genAI instance and caching API to delete cache
                     if (genAI?.caching?.deleteCachedContent) {
                         await genAI.caching.deleteCachedContent({ name: cacheNameToDelete }); // Pass name as object property
                         console.log(`[Delete Cache Attempt] Tried to delete cache: ${cacheNameToDelete}`);
                     } else {
                          console.log("[Delete Cache Attempt] Skipped cache deletion, SDK/API unavailable.");
                     }
                 } catch(cacheError) {
                      if (cacheError.message?.includes("not found")) {
                         console.log(`[Delete Cache Attempt] Cache ${cacheNameToDelete} not found, likely already deleted or never created.`);
                      } else {
                         console.warn(`[Delete Cache Attempt] Error deleting cache ${cacheNameToDelete}:`, cacheError);
                      }
                 }

                if (activeChatId === chatId) {
                    activeChatId = null; currentChatHistory = []; if (activeChatListener) { activeChatListener(); activeChatListener = null; }
                    chatArea.innerHTML = ''; renderGreetingOrLoginPrompt();
                    removeAllSelectedMedia(); // Clears media and cache state
                }
            } catch (error) { console.error(`[Delete Error] Chat ${chatId}:`, error); displayError(`Failed to delete chat.`); }
            finally { isDeletingChat = false; setLoadingState(false); console.log(`[Delete End] Chat: ${chatId}`); }
        }
        // switchChat: Clears cache state when switching chats
        function switchChat(chatId) {
             if (!currentUser || !chatId || chatId === activeChatId) {
                 console.log(`Switch chat skipped: currentUser=${!!currentUser}, chatId=${chatId}, activeChatId=${activeChatId}`);
                 return;
             }
             console.log("Switching to chat:", chatId);
             setLoadingState(true, "Loading chat...");
             activeChatId = chatId;
             currentMediaCacheName = null; // Reset cache state for the new chat
             cachedMediaUris = [];
             removeAllSelectedMedia();
             highlightActiveChatInSidebar();
             userInput.value = ''; autoGrowTextarea(); mcqModeCheckbox.checked = false;
             loadAndListenForActiveChat(chatId); // <<<--- TAMIL: இங்கதான் chat மாறும்போது history load ஆகும்
        }

        // --- Message Loading (Firestore) ---
        // loadAndListenForActiveChat
        // ***** TAMIL *****
        // இந்த function Firestore-லிருந்து ஒரு குறிப்பிட்ட chat-ன் messages-ஐ load செய்து காட்டுகிறது.
        // இது chat மாறும்போது அல்லது refresh ஆகி login செய்த பிறகு run ஆகும்.
        // இங்கதான் `currentChatHistory` array fill செய்யப்படும். இதுதான் API call-ல் அனுப்பப்படும்.
        function loadAndListenForActiveChat(chatId) {
            if (!currentUser || !chatId) {
                chatArea.innerHTML = ''; if (activeChatListener) { activeChatListener(); activeChatListener = null; }
                renderGreetingOrLoginPrompt(); updateButtonStates(); setLoadingState(false);
                return;
            }
            if (activeChatListener) { activeChatListener(); activeChatListener = null; } // Remove previous listener

            const messagesRef = db.collection('chats').doc(chatId).collection('messages').orderBy('timestamp', 'asc');
            chatArea.innerHTML = ''; // Clear chat area
            const loadingMsg = displayMessage("Loading chat history...", 'ai', ['thinking']);
            scrollToBottom(true);
            console.log(`Listening for messages in chat ${chatId}`);

            activeChatListener = messagesRef.onSnapshot(snapshot => {
                console.log(`Received messages snapshot for chat ${chatId}:`, snapshot.size, "messages");
                removeMessageElement(loadingMsg); // Remove "Loading..." message
                chatArea.innerHTML = ''; // Clear again before rendering new snapshot
                currentChatHistory = []; // <<<--- TAMIL: இங்க chat history array-ஐ reset செய்கிறோம்

                if (snapshot.empty && activeChatId === chatId) {
                    // Chat exists but has no messages
                    const chatListItem = chatListContainer.querySelector(`.chat-list-item[data-id="${chatId}"]`);
                    const chatTitle = chatListItem?.textContent?.replace(DELETE_ICON, '').trim() || '';
                    if (chatTitle && chatTitle !== NEW_CHAT_TITLE) {
                        displayMessage("Chat is empty. Send a message to start!", 'ai');
                    } else {
                        // If it's still "(New Chat)", show the initial greeting
                        renderGreetingOrLoginPrompt();
                    }
                } else {
                    snapshot.forEach(doc => {
                        const msgData = doc.data();
                        const role = msgData.role === 'user' ? 'user' : 'model';
                        const parts = [];

                        // ***** TAMIL *****
                        // இங்க Firestore-ல் உள்ள text-ஐ மட்டும் history array-ல் சேர்க்கிறோம்.
                        // Media data history-ல் சேர்க்கப்படவில்லை (current design).
                        // Long context வேலை செய்ய இந்த history முழுமையாக API call-ல் அனுப்பப்படும்.
                        // YouTube URLம் text ஆக historyல் சேமிக்கப்படும் (APIல் fileData ஆக அனுப்பப்பட்டாலும்).
                        let historyText = msgData.text || "";
                        if (msgData.youtubeVideoId) {
                            // Append the YT URL to the text for history context if it wasn't already part of the main text
                            const ytUrlInText = `https://www.youtube.com/watch?v=${msgData.youtubeVideoId}`;
                            if (!historyText.includes(ytUrlInText)) {
                                historyText = (historyText ? historyText + "\n" : "") + ytUrlInText;
                            }
                        }

                        if (historyText) {
                            parts.push({ text: historyText });
                        }

                        // Add to in-memory history *only if* it has valid text parts
                        if (parts.length > 0) {
                             currentChatHistory.push({ role: role, parts: parts });
                        }

                        // Display message in UI using Firestore data (this handles rendering media links/previews/YT from DB data)
                        displayMessage(msgData.text || '', msgData.role, [], null, msgData);
                    });
                }
                scrollToBottom(true); // Scroll after rendering all messages
                console.log(`Finished loading/displaying ${currentChatHistory.length} history items for chat ${chatId}. Updating button states.`);
                updateButtonStates(); // Update buttons based on loaded state
                setLoadingState(false); // Turn off loading indicator
                if (!isTestMode && !isReviewMode && activeChatId) { setTimeout(() => userInput.focus(), 100); } // Focus input if in chat view

            }, error => {
                console.error(`Error listening messages chat ${chatId}:`, error);
                displayError("Could not load messages for this chat.");
                removeMessageElement(loadingMsg); chatArea.innerHTML = ''; currentChatHistory = [];
                 console.error("Error loading messages. Updating button states.");
                updateButtonStates(); setLoadingState(false);
            });
        }


        // --- File Upload Helper (Gemini File API) ---
        // ***** TAMIL *****
        // இந்த function பெரிய files (PDF போன்றவை)-ஐ Gemini File API-க்கு upload செய்கிறது.
        // uploadAndProcessFile remains the same
        async function uploadAndProcessFile(file, index, totalFiles) {
             // Double-check genAI and genAI.files existence
            if (!genAI?.files?.upload || !genAI?.files?.get || !genAI?.files?.delete) {
                 console.error("[File API] Error: genAI.files service or required methods (upload, get, delete) are not available.");
                 throw new Error("AI SDK File Service not initialized or missing methods.");
             }

            const progressMsg = `Uploading file ${index + 1}/${totalFiles}: ${file.name}...`;
            console.log(`[File API] ${progressMsg}`);
            setLoadingState(true, progressMsg);

            let uploadResult = null; // Define here to be accessible in finally/catch

            try {
                // Use the File API upload method
                uploadResult = await genAI.files.upload({
                    file: file, // The File object itself
                    mimeType: file.type,
                    displayName: file.name,
                });
                console.log(`[File API] Upload initiated for ${file.name}. API File Name: ${uploadResult?.file?.name}, State: ${uploadResult?.file?.state}`);

                 if (!uploadResult?.file?.name) {
                     throw new Error(`File upload for ${file.name} did not return a valid file name.`);
                 }
                 const apiFileName = uploadResult.file.name; // e.g., "files/xxxxxxxx"

                // Poll the File API to check processing status
                let fileResponse = await genAI.files.get({ name: apiFileName }); // Pass name in object
                const startTime = Date.now();

                while (fileResponse?.file?.state === 'PROCESSING') {
                    if (Date.now() - startTime > FILE_API_PROCESSING_TIMEOUT_MS) {
                        throw new Error(`File processing timed out for ${file.name} after ${FILE_API_PROCESSING_TIMEOUT_MS / 1000}s.`);
                    }
                    const processMsg = `Processing file ${index + 1}/${totalFiles}: ${file.name}... (State: ${fileResponse.file.state})`;
                    setLoadingState(true, processMsg);
                    console.log(`[File API] File ${file.name} state: ${fileResponse.file.state}. Waiting ${FILE_API_POLLING_INTERVAL_MS / 1000}s...`);
                    await new Promise(resolve => setTimeout(resolve, FILE_API_POLLING_INTERVAL_MS));

                    try {
                        fileResponse = await genAI.files.get({ name: apiFileName }); // Pass name in object
                        if (!fileResponse?.file) {
                             throw new Error(`Polling failed: Invalid response from getFile for ${apiFileName}.`);
                        }
                    } catch (pollError) {
                        console.error(`[File API] Error polling file ${apiFileName}:`, pollError);
                        throw new Error(`Error checking processing status for ${file.name}: ${pollError.message}`);
                    }
                }

                // Check the final state
                if (fileResponse.file.state !== 'ACTIVE') {
                    console.error(`[File API] File processing failed for ${file.name}. Final State: ${fileResponse.file.state}`, fileResponse.file);
                    // Attempt to delete the failed file from the API storage
                    try { await genAI.files.delete({ name: apiFileName }); console.log(`[File API] Deleted failed/inactive file: ${apiFileName}`); } catch (delErr) { console.warn(`[File API] Failed to delete failed/inactive file ${apiFileName}:`, delErr); }
                    throw new Error(`File processing for ${file.name} resulted in state: ${fileResponse.file.state}.`);
                }

                console.log(`[File API] File ${file.name} (API: ${apiFileName}) processed successfully. URI: ${fileResponse.file.uri}`);
                return fileResponse.file; // Return the processed file object (contains name, uri, mimeType etc.)

            } catch (uploadError) {
                 console.error(`[File API] Error during upload/processing for ${file.name}:`, uploadError);
                 // Attempt to clean up the file if upload started but failed during processing
                 if (uploadResult?.file?.name) {
                      try { await genAI.files.delete({ name: uploadResult.file.name }); console.log(`[File API] Cleaned up file ${uploadResult.file.name} after error.`); }
                      catch (delErr) { console.warn(`[File API] Failed to cleanup file ${uploadResult.file.name} after error:`, delErr); }
                 }
                 throw uploadError; // Re-throw the error to be caught by handleSendMessage
            }
        }


        // --- Message Sending (Gemini API & Firestore Save) ---
        // ***** TAMIL *****
        // இதுதான் user message-ஐயும், media-வையும் (image, audio, pdf, YouTube URL) வாங்கி, Gemini API-க்கு அனுப்பி, பதிலை வாங்கி காட்டுகின்ற முக்கிய function.
        // இங்கதான் model selection, long context history, context caching, YouTube URL, max token limits போன்ற logic பயன்படுத்தப்படுகிறது.
        async function handleSendMessage() {
            const userMessageTextRaw = userInput.value.trim();
            const mediaItemsToSend = [...selectedMediaItems]; // Copy selected items
            const isMCQRequest = mcqModeCheckbox.checked;

            // ***** TAMIL *****
            // Input text-ல் YouTube URL உள்ளதா என்று regex மூலம் check செய்கிறோம்.
            const youtubeMatch = userMessageTextRaw.match(youtubeRegex);
            const youtubeUrl = youtubeMatch ? youtubeMatch[0] : null; // முழு URL-ஐ எடுக்கிறோம்

            console.log("handleSendMessage: Text:", userMessageTextRaw ? userMessageTextRaw.substring(0, 50) + '...' : '(empty)', "Media items:", mediaItemsToSend.length, "YT URL:", youtubeUrl, "Model:", selectedModelId);

            // --- Initial Checks ---
            if (!currentUser) { displayError("Please log in to send messages."); return; }
            if (!activeChatId) { displayError("Please select or create a chat first."); return; }
            if (!API_KEY || !genAI || !isAISdkReady || !HarmCategory || !HarmBlockThreshold) { displayError("API Key or AI SDK not ready/fully initialized. Cannot send message."); return; }
             const currentModelInfo = AVAILABLE_MODELS.find(m => m.id === selectedModelId);
             if (!currentModelInfo) { displayError("Selected AI model is invalid. Please choose another model."); return; }

             // ***** TAMIL *****
             // YouTube URL-ம், வேறு media file-ம் ஒரே நேரத்தில் இருந்தால் பிழை காட்டுகிறோம்.
             if (youtubeUrl && mediaItemsToSend.length > 0) {
                 displayError("Cannot process a YouTube URL and uploaded media (images/PDFs/audio) in the same message. Please remove one or the other.");
                 setLoadingState(false); // Reset loading state if returning early
                 return;
             }
             const hasPdfs = mediaItemsToSend.some(item => item.type === 'pdf');
             if (hasPdfs && (!genAI.files || !genAI.files.upload)) {
                 displayError("File API is unavailable. Cannot send PDF files."); return;
             }
            if (!userMessageTextRaw && mediaItemsToSend.length === 0 && !youtubeUrl) { // Also check for YT URL here
                console.log("Empty message and no media/URL. Nothing to send."); return;
            }
            if (sendButton.disabled || isRecording) { console.log("Send disabled (loading/recording)."); return; }

            setLoadingState(true, "Preparing message...");

            // --- Clear Input & Preview ---
            userInput.value = ''; autoGrowTextarea();
            if (isMCQRequest) mcqModeCheckbox.checked = false;
            // Don't remove media yet, need it for API call processing below

            // --- Firestore References & Timestamps ---
            const timestamp = firebase.firestore.FieldValue.serverTimestamp();
            const messagesColRef = db.collection('chats').doc(activeChatId).collection('messages');
            const chatDocRef = db.collection('chats').doc(activeChatId);

            // --- Prepare User Message Data for Firestore (Display) ---
            const userMsgData = { role: "user", text: userMessageTextRaw, timestamp: timestamp };
            const singleAudioItem = mediaItemsToSend.find(item => item.type === 'audio');
            const imageItems = mediaItemsToSend.filter(item => item.type === 'image');
            const pdfItems = mediaItemsToSend.filter(item => item.type === 'pdf');
            let potentialTestTitle = null;

             // Add media info to Firestore message for display purposes
             if (singleAudioItem) { /* ... audio info ... */ userMsgData.mediaType = 'audio'; userMsgData.mediaData = singleAudioItem.base64; userMsgData.mediaMimeType = singleAudioItem.mimeType; userMsgData.mediaName = singleAudioItem.name; }
             else if (imageItems.length === 1) { /* ... image info ... */ userMsgData.mediaType = 'image'; userMsgData.mediaName = imageItems[0].name; userMsgData.mediaMimeType = imageItems[0].mimeType; if (!imageItems[0].base64) { try { imageItems[0].base64 = await readFileAsBase64(imageItems[0].file); } catch (e) { console.error("Error reading image for DB:", e); imageItems[0].base64 = '#error'; } } userMsgData.mediaData = imageItems[0].base64; }
             else if (imageItems.length > 1) { /* ... multi-image info ... */ userMsgData.mediaType = 'multi-image'; userMsgData.mediaCount = imageItems.length; userMsgData.mediaNames = imageItems.map(img => img.name || 'image'); }
             else if (pdfItems.length > 0) { /* ... multi-pdf info ... */ userMsgData.mediaType = 'multi-pdf'; userMsgData.mediaCount = pdfItems.length; userMsgData.mediaNames = pdfItems.map(pdf => pdf.name || 'pdf'); }
             // ***** TAMIL *****
             // YouTube video ID-ஐ Firestore-ல் save செய்கிறோம், இது chat-ல் video-வை காட்ட உதவும்.
             if (youtubeUrl && youtubeMatch && youtubeMatch[1]) userMsgData.youtubeVideoId = youtubeMatch[1]; // Store the video ID (group 1 from regex)

            // --- Save User Message to Firestore ---
             try {
                 const chatSnap = await chatDocRef.get(); let isFirstUserMessageInNewChat = false; if (chatSnap.exists && chatSnap.data().title === NEW_CHAT_TITLE) { const messagesSnap = await messagesColRef.limit(1).get(); if (messagesSnap.empty) { isFirstUserMessageInNewChat = true; } }
                 const userMessageDocRef = await messagesColRef.add(userMsgData); // Store ref
                 await chatDocRef.update({ lastUpdated: timestamp }); console.log("User message saved to Firestore:", userMessageDocRef.id);
                 // Update in-memory history immediately after successful save
                 const userPartsForHistory = [];
                 let historyText = userMsgData.text;
                 // Append YT URL to history text if present and not already included
                  if (youtubeUrl && historyText && !historyText.includes(youtubeUrl)) {
                       historyText += "\n" + youtubeUrl;
                  } else if (youtubeUrl && !historyText) {
                       historyText = youtubeUrl;
                  }
                 if (historyText) userPartsForHistory.push({ text: historyText });

                 // ***** TAMIL *****
                 // User message history-ல் YouTube URL-ஐ text ஆக சேர்க்கிறோம் (API call-க்கு தனியாக fileData அனுப்பினாலும்).
                 // இதனால் context history-ல் user என்ன கேட்டார் என்று தெரியும்.
                 if (userPartsForHistory.length > 0) { currentChatHistory.push({ role: 'user', parts: userPartsForHistory }); }
                 if (isFirstUserMessageInNewChat) { let titleSource = userMessageTextRaw || (mediaItemsToSend[0]?.name) || (youtubeUrl ? 'YouTube Video Chat' : NEW_CHAT_TITLE); const generatedTitle = generateChatTitle(titleSource); if (generatedTitle && generatedTitle !== NEW_CHAT_TITLE) { await updateActiveChatTitle(generatedTitle); } }
             } catch(error) { console.error("Error saving user message:", error); displayError("Failed to save your message."); setLoadingState(false); return; }

            // --- Show Thinking Indicator ---
            const thinking = displayMessage("Thinking...", 'ai', ['thinking']);
            scrollToBottom();

            // --- Prepare Parts for API Call ---
            const partsForApi = [];
            let fileDataPartsForApi = []; // Separate array for potential caching (PDFs)
            let useCache = false;
            let cacheToUse = null;
            let isYouTubeRequest = false; // Flag for YouTube request
            let generatedResponse = null;
            let aiResponseSaved = false;
            let uploadedFileUris = []; // Store URIs of successfully uploaded PDFs

            try {
                 // ***** TAMIL *****
                 // இங்கதான் API request-க்கான 'parts' array-வை தயார் செய்கிறோம்.
                 // YouTube URL, மற்ற media, அல்லது text - எது உள்ளதோ, அதற்கு ஏற்றவாறு parts சேர்க்கப்படும்.

                 let textPromptForApi = userMessageTextRaw; // Start with the raw text

                 // --- 1. Process YouTube URL (if present and no other media) ---
                 if (youtubeUrl && mediaItemsToSend.length === 0) {
                     isYouTubeRequest = true;
                     // ***** TAMIL *****
                     // YouTube URL-ஐ Gemini API documentation-ல் உள்ள format-ல் fileData ஆக சேர்க்கிறோம்.
                     const youtubePart = {
                         fileData: {
                             // mimeType is optional for YouTube URLs according to latest docs, but doesn't hurt
                             // mimeType: "video/mp4",
                             fileUri: youtubeUrl     // முழு YouTube URL
                         }
                     };
                     // IMPORTANT: fileData parts should generally come *before* the text prompt part.
                     partsForApi.push(youtubePart);
                     console.log("Added YouTube URL as fileData part for API:", youtubeUrl);

                     // Extract text prompt excluding the URL
                     textPromptForApi = userMessageTextRaw.replace(youtubeUrl, '').trim();

                     // If MCQ requested, formulate the text prompt accordingly
                     if (isMCQRequest) {
                          potentialTestTitle = generateChatTitle(textPromptForApi || "YouTube Video Test") + ` (${new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })})`;
                          const mcqInstructions = `\n\nPlease generate multiple choice questions based on the provided video. Provide the response *only* as a valid JSON array string, enclosed within \`\`\`json ... \`\`\`. Each object in the array must have "question" (object with "en" and "ta" strings), "options" (array of 4 objects with "en" and "ta" strings), "answer" (string 'A', 'B', 'C', or 'D'), and "explanation" (object with "en" and "ta" strings). Provide accurate English content only. Do not include any text outside the JSON structure.`;
                          // Combine any existing text with instructions, or use a default + instructions
                          textPromptForApi = textPromptForApi ? textPromptForApi + mcqInstructions : `Generate multiple choice questions based on the provided video.` + mcqInstructions;
                          console.log("MCQ mode for YouTube: Using prompt:", textPromptForApi);
                     }
                     // If no text prompt was provided besides the URL (and not MCQ), add a default one.
                     else if (!textPromptForApi) {
                          textPromptForApi = "Summarize this video.";
                          console.log("YouTube URL only: Using default 'Summarize' prompt.");
                     }

                     // Add the final text prompt part if it exists
                     if (textPromptForApi) {
                         partsForApi.push({ text: textPromptForApi });
                         console.log("Added text prompt part for YouTube request:", textPromptForApi);
                     }

                 }
                 // --- 2. Process Uploaded Media (if present and no YouTube URL) ---
                 else if (mediaItemsToSend.length > 0) {
                     // --- 2a. Audio ---
                     if (singleAudioItem) {
                         if (!singleAudioItem.base64 || !singleAudioItem.mimeType) { throw new Error("Audio data is missing or invalid."); }
                         const base64Data = singleAudioItem.base64.substring(singleAudioItem.base64.indexOf(',') + 1);
                         partsForApi.push({ inlineData: { mimeType: singleAudioItem.mimeType, data: base64Data } });
                         console.log(`Added audio inlineData part.`);
                     }
                     // --- 2b. Images ---
                     else if (imageItems.length > 0) {
                         const imageBase64Promises = imageItems.map(item => item.base64 || readFileAsBase64(item.file));
                         const imageBase64Results = await Promise.all(imageBase64Promises);
                         let addedImageCount = 0;
                         imageBase64Results.forEach((b64, index) => {
                             if (!b64 || b64 === '#error') { console.error(`Skipping image ${imageItems[index]?.name || index}: Invalid base64 data.`); return; }
                             const mime = imageItems[index].mimeType; const data = b64.substring(b64.indexOf(',') + 1);
                             if(data && mime) { partsForApi.push({ inlineData: { mimeType: mime, data: data } }); addedImageCount++; }
                             else { console.error(`Skipping image ${imageItems[index]?.name || index}: Missing data or mimeType.`); }
                         });
                         console.log(`Added ${addedImageCount}/${imageItems.length} images as inlineData parts.`);
                         if (addedImageCount === 0 && imageItems.length > 0) { throw new Error("Failed to process any selected images."); }
                     }
                     // --- 2c. PDFs (File API) ---
                     else if (pdfItems.length > 0) {
                         console.log(`Uploading ${pdfItems.length} PDF(s) via File API...`);
                         const uploadPromises = pdfItems.map((item, index) => uploadAndProcessFile(item.file, index, pdfItems.length));
                         const uploadedFileResults = await Promise.all(uploadPromises);
                         uploadedFileUris = uploadedFileResults.map(f => f.uri).filter(uri => uri);

                         if (uploadedFileUris.length === 0 && pdfItems.length > 0) { throw new Error("Failed to upload or process any selected PDF files."); }

                         fileDataPartsForApi = uploadedFileUris.map(uri => {
                             const originalFile = uploadedFileResults.find(f => f.uri === uri);
                             return { fileData: { mimeType: originalFile.mimeType, fileUri: uri } };
                         });
                         console.log(`Prepared ${fileDataPartsForApi.length} fileData parts for API (PDFs).`);

                         // Context Caching Logic for PDFs (remains the same)
                         const canAttemptCaching = currentModelInfo.supportsCaching && fileDataPartsForApi.length > 0 && !!genAI?.caching?.createCachedContent;
                         if (canAttemptCaching) {
                              const sortedUris = [...uploadedFileUris].sort();
                              if (currentMediaCacheName && cachedMediaUris.length === sortedUris.length && cachedMediaUris.every((uri, i) => uri === sortedUris[i])) {
                                   console.log(`Attempting to use existing cache: ${currentMediaCacheName}`); useCache = true; cacheToUse = currentMediaCacheName;
                              } else {
                                   console.log("No matching PDF cache found or URIs differ. Will attempt to create a new cache after this call."); currentMediaCacheName = null; cachedMediaUris = [];
                              }
                         } else if (fileDataPartsForApi.length > 0) { console.log(`Caching skipped for PDFs: Model ${selectedModelId} doesn't support it, or SDK caching API missing.`); }
                     } // End PDF processing

                     // Add text prompt if available AFTER processing media parts
                      textPromptForApi = userMessageTextRaw; // Use the original text
                      if (isMCQRequest) { // Append MCQ instructions if needed
                          potentialTestTitle = generateChatTitle(textPromptForApi || (mediaItemsToSend[0]?.name) || "Generated Test") + ` (${new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })})`;
                          const mcqInstructions = `\n\nPlease generate multiple choice questions based on the provided text and/or media (image(s)/PDF(s)/audio). Provide the response *only* as a valid JSON array string, enclosed within \`\`\`json ... \`\`\`. Each object in the array must have "question" (object with "en" and "ta" strings), "options" (array of 4 objects with "en" and "ta" strings), "answer" (string 'A', 'B', 'C', or 'D'), and "explanation" (object with "en" and "ta" strings). Provide accurate English content only. Do not include any text outside the JSON structure.`;
                          textPromptForApi = textPromptForApi ? textPromptForApi + mcqInstructions : mcqInstructions; // Append or use instructions only
                          console.log("MCQ mode for uploaded media: Using prompt:", textPromptForApi);
                      }
                      if (textPromptForApi) {
                          partsForApi.push({ text: textPromptForApi });
                          console.log("Added text prompt part for uploaded media request:", textPromptForApi);
                      }

                 }
                 // --- 3. Only Text ---
                 else {
                      textPromptForApi = userMessageTextRaw;
                      if (isMCQRequest) { // Handle MCQ request for text-only input
                           potentialTestTitle = generateChatTitle(textPromptForApi || "Text-Based Test") + ` (${new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })})`;
                           const mcqInstructions = `\n\nPlease generate multiple choice questions based on the provided text. Provide the response *only* as a valid JSON array string, enclosed within \`\`\`json ... \`\`\`. Each object in the array must have "question" (object with "en" and "ta" strings), "options" (array of 4 objects with "en" and "ta" strings), "answer" (string 'A', 'B', 'C', or 'D'), and "explanation" (object with "en" and "ta" strings). Provide accurate English content only. Do not include any text outside the JSON structure.`;
                           textPromptForApi = textPromptForApi ? textPromptForApi + mcqInstructions : mcqInstructions;
                           console.log("MCQ mode for text only: Using prompt:", textPromptForApi);
                      }
                     if (textPromptForApi) {
                         partsForApi.push({ text: textPromptForApi });
                         console.log("Added text-only prompt part:", textPromptForApi);
                     }
                 }


                // --- Combine Parts for Final API Request ---
                // Order: Media first (inline or fileData), then text prompt
                let finalPartsForApi = [];
                if (isYouTubeRequest) {
                    // Already handled: youtubePart then text part
                    finalPartsForApi = partsForApi;
                } else if (fileDataPartsForApi.length > 0) { // PDFs
                    if (useCache) {
                        // Text/inline parts first, cache name handles files separately
                        finalPartsForApi = partsForApi.filter(p => p.text || p.inlineData); // Filter out any fileData parts inadvertently added earlier
                    } else {
                        // FileData parts first, then text/inline parts
                        finalPartsForApi = [...fileDataPartsForApi, ...partsForApi.filter(p => p.text || p.inlineData)];
                    }
                } else { // Text-only or inline media (audio/images)
                    // Media part first (if any), then text part
                    finalPartsForApi = partsForApi; // partsForApi should already be in [media, text] order if both present
                }

                 if (finalPartsForApi.length === 0 && !useCache) {
                    throw new Error("No valid content (text, media, or YouTube URL) to send after processing.");
                 }

                // --- Call Gemini API using SDK ---
                console.log("Calling Gemini API via SDK...");
                setLoadingState(true, "Generating response...");

                // ***** TAMIL *****
                // NEW (v10.3): இங்க model-க்கான `maxOutputTokens`ஐ config செய்கிறோம்.
                // 2.5 Pro-க்கு 65536, மற்றவற்றுக்கு 8192.
                const selectedModelConfig = AVAILABLE_MODELS.find(m => m.id === selectedModelId);
                const maxTokens = selectedModelConfig?.maxTokens || DEFAULT_MAX_TOKENS;
                console.log(`Using model: ${selectedModelId}, Setting maxOutputTokens: ${maxTokens}`);

                const model = genAI.getGenerativeModel({
                    model: selectedModelId,
                    safetySettings: [
                         { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
                         { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
                         { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
                         { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
                    ],
                    // ***** TAMIL *****
                    // NEW (v10.3): API call-க்கு `generationConfig`-ஐ சேர்க்கிறோம்.
                    generationConfig: {
                        maxOutputTokens: maxTokens,
                        // temperature: 0.9, // Optional: Uncomment and adjust creativity
                        // topP: 1, // Optional: Uncomment and adjust nucleus sampling
                        // topK: 1, // Optional: Uncomment and adjust top-k sampling
                    }
                });

                // ***** TAMIL *****
                // இங்க chat history-ஐ API request-ல் சேர்க்கிறோம் (`contents` array). இதுதான் long context.
                const historyForSDK = currentChatHistory
                    .map(msg => ({
                        role: msg.role,
                        // Ensure parts in history are only text for simplicity in SDK call history
                        parts: msg.parts.filter(part => typeof part.text === 'string').map(part => ({ text: part.text }))
                    }))
                    .filter(msg => msg.parts.length > 0);

                // Construct the request payload
                 const contentsRequest = [ ...historyForSDK, { role: "user", parts: finalPartsForApi } ];
                 const generateContentRequest = {
                     contents: contentsRequest,
                     ...(useCache && cacheToUse && { cache: { name: cacheToUse } }) // Conditionally add cache parameter if using PDF cache
                 };

                console.log("SDK Request Payload:", JSON.stringify(generateContentRequest, (k, v) => {
                     if (k === 'data' && typeof v === 'string' && v.length > 100) return v.substring(0, 50) + '...[truncated]';
                     if (k === 'fileUri' && typeof v === 'string') {
                         if (v.includes('youtube.com') || v.includes('youtu.be')) return v; // Show full YT URL
                         else return '...' + v.split('/').pop() + ' [uri]'; // Shorten other URIs
                     }
                     return v;
                 }, 2));

                // ***** TAMIL *****
                // API call செய்கிறோம்.
                const result = await model.generateContent(generateContentRequest);
                generatedResponse = result.response;

                // --- Process API Response ---
                removeMessageElement(thinking); // Remove "Thinking..." indicator
                let aiMsgData = { role: "model", text: "Error: No valid response from API.", timestamp: firebase.firestore.FieldValue.serverTimestamp(), mcqData: null, mcqTitle: null };
                let displayAsError = true; let rawAiText = ""; let blocked = false;

                // ***** TAMIL *****
                // API response-ஐ process செய்கிறோம். பிழை உள்ளதா, block செய்யப்பட்டுள்ளதா என்று பார்க்கிறோம்.
                if (generatedResponse.promptFeedback?.blockReason) {
                    aiMsgData.text = `Blocked (Prompt): ${generatedResponse.promptFeedback.blockReason}`; blocked = true; displayAsError = true; console.warn("Prompt blocked:", generatedResponse.promptFeedback);
                } else if (generatedResponse.candidates && generatedResponse.candidates.length > 0) {
                    const candidate = generatedResponse.candidates[0];
                    if (candidate.finishReason === 'SAFETY') { aiMsgData.text = `Blocked (Response Safety): ${candidate.safetyRatings?.map(r => `${r.category.replace('HARM_CATEGORY_','')} (${r.probability})`).join(', ') || 'Reason unspecified'}`; blocked = true; displayAsError = true; console.warn("Response blocked (Safety):", candidate.safetyRatings); }
                    else if (candidate.finishReason === 'RECITATION') { aiMsgData.text = `Blocked (Response Recitation)`; blocked = true; displayAsError = true; console.warn("Response blocked (Recitation)"); }
                    else if (candidate.content?.parts?.length > 0) {
                        try {
                             rawAiText = generatedResponse.text(); // Helper method to extract text
                             aiMsgData.text = rawAiText; displayAsError = false;
                             if (isMCQRequest && !blocked) { // Parse MCQs if requested and not blocked
                                try {
                                     const jsonMatch = rawAiText.match(/```json\s*([\s\S]*?)\s*```/); const jsonString = jsonMatch ? jsonMatch[1].trim() : rawAiText.trim();
                                     if (jsonString.startsWith('[') && jsonString.endsWith(']')) {
                                         const mcqs = JSON.parse(jsonString);
                                         const isValid = Array.isArray(mcqs) && mcqs.length > 0 && mcqs.every(q => q.question?.en && q.options?.length === 4 && q.options.every(opt=>opt.en) && q.answer && q.explanation?.en);
                                         if (isValid) {
                                              mcqs.forEach(q => { q.question.ta = q.question.ta || q.question.en; q.explanation.ta = q.explanation.ta || q.explanation.en; q.options.forEach(opt => { opt.ta = opt.ta || opt.en; }); });
                                              aiMsgData.text = `Generated ${mcqs.length} MCQs.`; aiMsgData.mcqData = mcqs; aiMsgData.mcqTitle = potentialTestTitle; console.log("MCQs parsed successfully."); displayAsError = false;
                                         } else { throw new Error("Invalid MCQ structure."); }
                                     } else { throw new Error("Not a JSON array."); }
                                 } catch (parseError) { console.warn("Failed to parse MCQ JSON:", parseError.message); aiMsgData.text = "MCQ format error.\n\n" + rawAiText; displayAsError = true; aiMsgData.mcqData = null; aiMsgData.mcqTitle = null; }
                             }
                        } catch (textError) { console.error("Error extracting text from SDK response:", textError); aiMsgData.text = "Error extracting text from response."; displayAsError = true; }
                    } else if (candidate.finishReason === 'MAX_TOKENS') { console.warn("Response stopped: MAX_TOKENS."); aiMsgData.text = (generatedResponse.text ? generatedResponse.text() : "") + "\n\n(Response may be truncated due to token limit)"; displayAsError = false; }
                    else if (candidate.finishReason === 'STOP' && (!candidate.content || candidate.content?.parts?.length === 0)){ aiMsgData.text = "(Model returned no content)"; displayAsError = false;}
                    else { console.warn("API response finish reason:", candidate.finishReason); aiMsgData.text = `Response finished: ${candidate.finishReason || 'Unknown'}. ` + (generatedResponse.text ? generatedResponse.text() : ""); displayAsError = false; }
                } else { console.error("API Error: No candidates in response."); aiMsgData.text = "Error: No response data from API."; displayAsError = true; }

                // --- Save AI Response to Firestore ---
                 try {
                      await messagesColRef.add(aiMsgData);
                      await chatDocRef.update({ lastUpdated: firebase.firestore.FieldValue.serverTimestamp() });
                      aiResponseSaved = true;
                      console.log("AI response/error saved to Firestore.");
                      if (!displayAsError && !blocked && aiMsgData.text) {
                           currentChatHistory.push({ role: 'model', parts: [{ text: aiMsgData.text }] });
                      }
                } catch (saveError) { console.error("Error saving AI response:", saveError); displayError(`Failed to save AI response.`); }

                 // --- Attempt to Create Cache (PDFs only, if applicable and not used) ---
                 if (!isYouTubeRequest && !useCache && currentModelInfo.supportsCaching && fileDataPartsForApi.length > 0 && !!genAI?.caching?.createCachedContent) {
                      const newCacheName = `cache-${activeChatId}-media-${Date.now()}`;
                      console.log(`Attempting to create PDF cache: ${newCacheName} for ${fileDataPartsForApi.length} file(s). TTL: ${CACHE_TTL_SECONDS}s`);
                       try {
                            const cacheRequest = {
                                model: `models/${selectedModelId}`, contents: [{ role: 'user', parts: fileDataPartsForApi }], ttlSeconds: CACHE_TTL_SECONDS, name: newCacheName
                            };
                            console.log("PDF Cache Creation Request:", JSON.stringify(cacheRequest, (k, v) => (k === 'fileUri' ? '...' + v.split('/').pop() + ' [uri]' : v), 2));
                            // Create cache asynchronously
                            genAI.caching.createCachedContent(cacheRequest).then(createdCache => {
                                if (createdCache?.name) {
                                    currentMediaCacheName = createdCache.name; cachedMediaUris = [...uploadedFileUris].sort();
                                    console.log(`PDF Cache ${currentMediaCacheName} creation initiated successfully for URIs:`, cachedMediaUris);
                                 } else { console.warn("PDF Cache creation call may have succeeded but did not return a valid cache object."); }
                            }).catch(cacheError => { console.error(`Error initiating PDF cache creation for ${newCacheName}:`, cacheError); });
                       } catch (e) { console.error("Unexpected error setting up PDF cache creation:", e); }
                 } else if (useCache) { console.log(`Used existing PDF cache: ${cacheToUse}`); }
                  else if (!isYouTubeRequest && fileDataPartsForApi.length > 0) { console.log("PDF Cache creation skipped: Model/SDK doesn't support it, or no PDF files to cache."); }

            } catch (error) { // Catch errors from media processing, API call, or response processing
                 console.error("Error during send process:", error);
                 removeMessageElement(thinking); // Ensure thinking message is removed on error
                 const errorText = `Error: ${error.message || "An unexpected error occurred during sending."}`;
                 displayError(errorText); // Display error in chat
                 if (!aiResponseSaved) { // Avoid saving duplicate errors
                     try { await messagesColRef.add({ role: "model", text: errorText, timestamp: firebase.firestore.FieldValue.serverTimestamp() }); await chatDocRef.update({ lastUpdated: firebase.firestore.FieldValue.serverTimestamp() }); console.log("Error message saved to Firestore."); }
                     catch (saveError) { console.error("Failed to save error message:", saveError); }
                 }
            } finally {
                 console.log("handleSendMessage finally block reached.");
                 // Clear media selection UI (for uploaded files) after everything is processed
                 removeAllSelectedMedia(); // This calls updateButtonStates internally
                 setLoadingState(false); // Turn off loading state
                 if (!isTestMode && !isReviewMode && activeChatId) { setTimeout(() => userInput.focus(), 100); } // Refocus input
            }
        } // End of handleSendMessage



        // --- Chat Title Generation/Update ---
        // generateChatTitle, updateActiveChatTitle remain the same
        function generateChatTitle(sourceText) { if (!sourceText || typeof sourceText !== 'string') return NEW_CHAT_TITLE; const text = sourceText.trim(); if (!text) return NEW_CHAT_TITLE; const title = text.split(/\s+/).slice(0, 5).join(' ').replace(/[.,!?;:]+$/, ''); return title.length > 35 ? title.substring(0, 32) + '...' : title; }
        async function updateActiveChatTitle(newTitle) { if (!currentUser || !activeChatId || !newTitle || typeof newTitle !== 'string' || !newTitle.trim() || newTitle.trim() === NEW_CHAT_TITLE) return; const finalTitle = newTitle.trim(); const chatDocRef = db.collection('chats').doc(activeChatId); try { await chatDocRef.update({ title: finalTitle }); console.log(`Chat ${activeChatId} title updated: "${finalTitle}"`); } catch (error) { console.error("Error updating chat title:", error); } }

        // --- File Reader Helper ---
        // readFileAsBase64 remains the same
        function readFileAsBase64(file) { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = () => resolve(reader.result); reader.onerror = (error) => reject(error); reader.readAsDataURL(file); }); }

        // --- UI & Message Display Helpers ---
        // autoGrowTextarea, handleInputKeydown, handleSuggestionClick remain the same
        function autoGrowTextarea() { userInput.style.height='auto'; userInput.style.height=(userInput.scrollHeight)+'px'; }
        function handleInputKeydown(event) { if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();if(!sendButton.disabled) handleSendMessage();} }
        function handleSuggestionClick(event) { if(event.target.classList.contains('suggestion-chip')){ const prompt = event.target.dataset.prompt || ''; userInput.value = prompt; if (prompt.toLowerCase().includes("video") || prompt.toLowerCase().includes("youtube")) { userInput.value += " "; userInput.placeholder = "Paste YouTube URL after the prompt..."; } autoGrowTextarea();userInput.focus(); updateButtonStates();} } // Update buttons after suggestion click
        // displayError remains the same
        function displayError(text) { console.error("Displaying Error:", text); displayMessage(`${text}`, 'ai', ['error-message']); scrollToBottom(); }
        // scrollToBottom remains the same
        function scrollToBottom(immediate = false) { chatArea.scrollTo({top:chatArea.scrollHeight,behavior:immediate?'auto':'smooth'}); }
        // removeMessageElement remains the same
        function removeMessageElement(element) { if(element && element.parentNode === chatArea) { try { chatArea.removeChild(element); } catch(e) { /* ignore */ } } }

        // updateButtonStates: Checks model selector state, SDK capabilities, and YouTube URL in input
        // ***** TAMIL *****
        // இந்த function UIல் உள்ள buttons (send, upload, etc.) enable/disable செய்ய உதவுகிறது.
        // User login செய்திருக்கிறாரா, SDK ரெடியாக உள்ளதா, caching வேலை செய்யுமா, input-ல் YouTube URL உள்ளதா போன்றவற்றை check செய்கிறது.
         function updateButtonStates(isLoading = false) {
            const isLoggedIn = !!currentUser;
            const isSdkFullyReady = isLoggedIn && !!API_KEY && !!genAI && isAISdkReady && !!HarmCategory && !!HarmBlockThreshold; // More robust check
            const canUseFileAPI = isSdkFullyReady && !!genAI.files?.upload; // Check specific method needed for PDF uploads
            const currentModelInfo = AVAILABLE_MODELS.find(m => m.id === selectedModelId);
            const canUseCachingAPI = isSdkFullyReady && !!genAI.caching?.createCachedContent; // Check if SDK has caching methods
            const canAttemptCaching = canUseCachingAPI && currentModelInfo?.supportsCaching; // Check if SDK AND selected model support caching
            // ***** TAMIL *****
            // Input field-ல் YouTube URL இருக்கிறதா என்று check செய்கிறோம்.
            const hasYouTubeUrlInInput = youtubeRegex.test(userInput.value.trim());
            const hasSelectedMedia = selectedMediaItems.length > 0;

            const isChatSelected = !!activeChatId;
            const isAppReady = isSdkFullyReady; // Basic app readiness depends on SDK init
            // ***** TAMIL *****
            // Send செய்யலாமா என்று check செய்யும்போது, YouTube URL-ம், வேறு media-வும் ஒரே நேரத்தில் இருக்கக்கூடாது என்பதையும் check செய்கிறோம்.
            const canSendCombination = !(hasYouTubeUrlInInput && hasSelectedMedia);
            const canSendMessage = isAppReady && isChatSelected && !isLoading && !isRecording && canSendCombination && (userInput.value.trim() !== '' || hasSelectedMedia || hasYouTubeUrlInInput);


            // Input Area Buttons
            userInput.disabled = !isAppReady || !isChatSelected || isLoading || isRecording;
            sendButton.disabled = !canSendMessage;
            mcqModeCheckbox.disabled = !canSendMessage;

            // Media buttons (disable if YouTube URL is present *OR* other incompatible media is selected)
            const disableFileUpload = isLoading || isRecording || !isAppReady || !isChatSelected || hasYouTubeUrlInInput;
            const disableAudioRecord = isLoading || !isAppReady || !isChatSelected || hasYouTubeUrlInInput; // Recording button logic handles its own isRecording state

            imageUploadButton.disabled = disableFileUpload || (hasSelectedMedia && !selectedMediaItems.every(i => i.type === 'image'));
            pdfUploadButton.disabled = disableFileUpload || !canUseFileAPI || (hasSelectedMedia && !selectedMediaItems.every(i => i.type === 'pdf'));
            audioUploadButton.disabled = disableFileUpload || (hasSelectedMedia && !selectedMediaItems.every(i => i.type === 'audio'));
            recordAudioButton.disabled = disableAudioRecord || hasSelectedMedia; // Also disable if any media selected

            // Update titles based on disabled state
            imageUploadButton.title = imageUploadButton.disabled ? "Image upload disabled (Check login, SDK, active chat, or conflicting input/media)" : "Upload image(s)";
            pdfUploadButton.title = pdfUploadButton.disabled ? (canUseFileAPI ? "PDF upload disabled (Check login, SDK, active chat, or conflicting input/media)" : "PDF upload disabled (File API unavailable)") : "Upload PDF file(s)";
            audioUploadButton.title = audioUploadButton.disabled ? "Audio upload disabled (Check login, SDK, active chat, or conflicting input/media)" : "Upload audio file";
            recordAudioButton.title = recordAudioButton.disabled ? "Audio recording disabled (Check login, SDK, active chat, or conflicting input/media)" : (isRecording ? "Stop recording" : "Record audio");


            // Re-enable record button specifically if recording is active (to allow stopping)
            if (isRecording) {
                recordAudioButton.disabled = false; // Allow stopping
                recordAudioButton.title = "Stop recording";
            }


            // Sidebar Buttons
            startChatButton.disabled = !isLoggedIn || isLoading || isRecording;
            testSearchInput.disabled = !isLoggedIn || isLoading || isRecording;

            // Settings Buttons
            decreaseTextBtn.disabled = isLoading || isRecording || currentTextSizeMultiplier <= MIN_TEXT_SIZE_MULTIPLIER;
            increaseTextBtn.disabled = isLoading || isRecording || currentTextSizeMultiplier >= MAX_TEXT_SIZE_MULTIPLIER;
            themeToggleButton.disabled = isLoading || isRecording;
            modelSelector.disabled = isLoading || isRecording || !isLoggedIn; // Disable if loading/recording or logged out

            // Auth Buttons
            loginBtn.disabled = isLoading;
            logoutBtn.disabled = isLoading;
         }

        // setLoadingState remains mostly the same
        function setLoadingState(isLoading, message = "Generating...") {
            updateButtonStates(isLoading); // Update buttons based on loading state

            let placeholderText = "";
            const isLoggedIn = !!currentUser;
             const isSdkFullyReady = isLoggedIn && !!API_KEY && !!genAI && isAISdkReady && !!HarmCategory && !!HarmBlockThreshold;

            if (isRecording) { placeholderText = "Recording audio..."; }
            else if (isLoading) { placeholderText = message; }
            else if (!isLoggedIn) { placeholderText = "Please log in"; }
            else if (!isSdkFullyReady) { placeholderText = "API Key/SDK Error. Check settings/reload."; }
            else if (!activeChatId) { placeholderText = "Select or create a chat"; }
            else { placeholderText = "Enter prompt, attach media, or paste URL"; }

            if (userInput.placeholder !== placeholderText) { userInput.placeholder = placeholderText; }
        }

        // switchView remains the same
        function switchView(viewName, cameFromTests = false) { console.log("Switching view to:", viewName); chatView.classList.remove('active'); reviewView.classList.remove('active'); testView.classList.remove('active'); appContainer.classList.remove('hidden'); isTestMode = false; isReviewMode = false; cameFromAllTestsList = cameFromTests; saveReviewBtn.style.display = 'none'; exitReviewBtn.style.display = 'none'; if(viewName === 'test'){ appContainer.classList.add('hidden'); testView.classList.add('active'); isTestMode = true; } else if(viewName === 'review'){ reviewView.classList.add('active'); isReviewMode = true; exitReviewBtn.style.display = 'inline-block'; exitReviewBtn.textContent = cameFromAllTestsList ? "Back to All Tests" : "Back to Chat"; } else { chatView.classList.add('active'); if (currentUser && activeChatId && API_KEY && genAI && !isRecording) { setTimeout(() => userInput.focus(), 100); } } if (viewName !== 'test' && testTimerInterval) { clearInterval(testTimerInterval); testTimerInterval = null; } }

        // displayMessage: Includes enhanced code block handling with PrismJS and YouTube Embed
        // ***** TAMIL *****
        // இந்த function message-களை chat area-வில் காட்டுகிறது. Code block-களையும், YouTube video-வையும் format செய்கிறது.
        // PrismJS மூலம் code highlighting சரியாக வேலை செய்யுமாறு மாற்றப்பட்டுள்ளது.
        function displayMessage(text, sender, cssClasses = [], appendHtml = null, messageData = null) {
            const messageElement = document.createElement('div');
            messageElement.classList.add('message', `${sender}-message`);
            if (cssClasses?.length > 0) messageElement.classList.add(...cssClasses);
            let hasContent = false;
            let containsCode = false; // <<< TAMIL: Code block உள்ளதா என track செய்ய ஒரு flag

            // --- Media Rendering (Uploaded Files) ---
            // (Media rendering logic remains unchanged)
            if (messageData?.mediaType === 'image' && messageData.mediaData && messageData.mediaData !== '#error') { try { const img = document.createElement('img'); img.src = messageData.mediaData; img.alt = messageData.mediaName || "Uploaded Image"; img.classList.add('uploaded-image'); img.loading = "lazy"; img.onerror = () => { img.alt = "Image load error"; img.src = ""; }; messageElement.appendChild(img); hasContent = true; } catch (e) { console.error("Error creating image element:", e); } }
            else if (messageData?.mediaType === 'multi-image' && messageData.mediaCount > 0) { try { const indicator = document.createElement('div'); indicator.classList.add('multi-media-indicator'); indicator.textContent = `(${messageData.mediaCount} image${messageData.mediaCount > 1 ? 's' : ''} sent: ${messageData.mediaNames?.join(', ') || ''})`; messageElement.appendChild(indicator); hasContent = true; } catch (e) { console.error("Error creating multi-image indicator:", e); } }
            else if (messageData?.mediaType === 'multi-pdf' && messageData.mediaCount > 0) { try { const indicator = document.createElement('div'); indicator.classList.add('multi-media-indicator'); indicator.textContent = `(${messageData.mediaCount} PDF${messageData.mediaCount > 1 ? 's' : ''} sent: ${messageData.mediaNames?.join(', ') || ''})`; messageElement.appendChild(indicator); hasContent = true; } catch (e) { console.error("Error creating multi-PDF indicator:", e); } }
            else if (messageData?.mediaType === 'audio' && messageData.mediaData) { try { const audioContainer = document.createElement('div'); audioContainer.classList.add('chat-audio-player'); const audioPlayer = document.createElement('audio'); audioPlayer.src = messageData.mediaData; audioPlayer.controls = true; audioPlayer.preload = "metadata"; if(messageData.mediaName) audioPlayer.title = messageData.mediaName; audioPlayer.onerror = () => { console.warn("Error loading audio player"); audioContainer.innerHTML = `<span style='font-size:0.8em; color:var(--error-text);'>(Audio load error)</span>`; }; audioContainer.appendChild(audioPlayer); messageElement.appendChild(audioContainer); hasContent = true; } catch (e) { console.error("Error creating audio element:", e); } }

            // --- Text Content Rendering (with Code Block Handling) ---
            if (text) {
                const messageContentContainer = document.createElement('div');
                try {
                    // Basic text sanitization - let browser handle initial escaping
                    const tempDiv = document.createElement('div');
                    tempDiv.innerText = text;
                    let formattedText = tempDiv.innerHTML;

                    // Handle Images in Text (if not already handled as primary media)
                    if (messageData?.mediaType !== 'image') {
                        formattedText = formattedText.replace(imageUrlRegex, (match, imgUrl) => `<img src="${imgUrl}" class="chat-image" alt="Chat Image" loading="lazy" onerror="this.alt='Image URL load error'; this.src='';">`);
                    }

                    // ***** TAMIL *****
                    // Handle Code Blocks (``` ... ```) - Enhanced for PrismJS
                    // இங்கதான் ```xyz ... ``` போன்ற அமைப்பை HTML code block ஆக மாற்றுகிறோம்.
                    formattedText = formattedText.replace(/```(\w*)\n?([\s\S]*?)```/g, (match, lang, code) => {
                        containsCode = true; // <<< TAMIL: Code block கண்டுபிடிக்கப்பட்டது என flag செட் செய்கிறோம்.
                        // language பெயர் सुरक्षितமாக உள்ளதா என சரிபார்த்து, class பெயரை உருவாக்குகிறோம் (e.g., language-javascript). இல்லையெனில் 'language-plain' பயன்படுத்துகிறோம்.
                        const safeLang = lang?.trim()?.match(/^[a-zA-Z0-9_-]+$/) ? lang.trim().toLowerCase() : 'plain';
                        const languageClass = `language-${safeLang}`;
                        // Code உள்ளே இருக்கும் HTML குறிச்சொற்களை (<, >) escape செய்கிறோம், இல்லையெனில் browser அதை HTML ஆக காட்டிவிடும்.
                        const escapedCode = code.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                        // ***** TAMIL *****
                        // PrismJS சரியாக வேலை செய்ய, `<pre>` tag-க்கும், உள்ளே உள்ள `<code>` tag-க்கும் language class-ஐ சேர்க்க வேண்டும்.
                        // `<div class="code-toolbar">` என்பது PrismJS-ன் toolbar plugin (copy button காட்ட) தானாகவே சேர்க்கும். நாம் இங்கு `<pre>` மற்றும் `<code>` ஐ மட்டும் உருவாக்கினால் போதும்.
                        return `<pre class="${languageClass}"><code class="${languageClass}">${escapedCode}</code></pre>`;
                    });

                    // Handle Inline Code (`)
                    formattedText = formattedText.replace(/`([^`]+)`/g, (match, code) => `<code>${code.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</code>`);
                    // Handle Bold/Italics/Newlines
                    formattedText = formattedText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/(?<!\*)\*(?!\*)(.*?)(?<!\*)\*(?!\*)/g, '<em>$1</em>').replace(/\n/g, '<br>');

                    messageContentContainer.innerHTML = formattedText;
                    messageElement.appendChild(messageContentContainer);
                    hasContent = true;

                    // MathJax typesetting (run after content is added)
                    if (text.includes('$') || text.includes('\\') || text.includes('^') || text.includes('_')) {
                        if (typeof MathJax !== "undefined" && MathJax.typesetPromise) {
                            // Run typesetting after a minimal delay to ensure DOM is ready
                            setTimeout(() => {
                                MathJax.typesetPromise([messageContentContainer]).catch(err => console.error('MathJax typesetting error:', err));
                            }, 50);
                        }
                    }
                } catch (e) {
                    console.error("Error formatting text content:", e);
                    // Fallback to plain text if formatting fails
                    messageContentContainer.innerText = text;
                    if (!messageElement.contains(messageContentContainer)) {
                        messageElement.appendChild(messageContentContainer);
                    }
                    hasContent = true;
                }
            }


            // --- YouTube Embed (Render based on Firestore data) ---
            // ***** TAMIL *****
            // இங்க messageData-ல் youtubeVideoId இருந்தால், YouTube video embed செய்து காட்டுகிறோம்.
            if (messageData?.youtubeVideoId) {
                try {
                    const youtubeEmbedDiv = document.createElement('div');
                    youtubeEmbedDiv.classList.add('youtube-embed-container');
                    const iframe = document.createElement('iframe');
                    iframe.classList.add('chat-video');
                    iframe.src = `https://www.youtube.com/embed/${messageData.youtubeVideoId}`;
                    iframe.title = "YouTube video player";
                    iframe.allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share";
                    iframe.allowFullscreen = true;
                    iframe.loading = "lazy";
                    iframe.onerror = () => {
                        youtubeEmbedDiv.innerHTML = `<span style='font-size:0.8em; color:var(--error-text);'>(YouTube embed error: ID ${messageData.youtubeVideoId})</span>`;
                    };
                    youtubeEmbedDiv.appendChild(iframe);
                    messageElement.appendChild(youtubeEmbedDiv);
                    hasContent = true;
                    console.log(`Displaying YouTube embed for ID: ${messageData.youtubeVideoId}`);
                } catch (e) {
                    console.error("Error creating YouTube embed:", e);
                }
            }

             // --- MCQ Offer ---
            if (messageData?.role === 'model' && messageData?.mcqData?.length > 0) { try { displayMCQOffer(messageData.mcqData, messageData.mcqTitle, messageElement); hasContent = true; } catch (e) { console.error("Error displaying MCQ offer:", e); } }
            // --- Append Raw HTML ---
            else if (appendHtml) { try { const appendDiv = document.createElement('div'); appendDiv.innerHTML = appendHtml; while (appendDiv.firstChild) { messageElement.appendChild(appendDiv.firstChild); } hasContent = true; } catch (e) { console.error("Error appending raw HTML:", e); } }

            // --- Append Message to Chat Area ---
            if (hasContent || cssClasses.includes('thinking') || cssClasses.includes('error-message')) {
                if (!chatArea.contains(messageElement)) {
                    chatArea.appendChild(messageElement);
                    // ***** TAMIL *****
                    // Apply PrismJS highlighting if code blocks were found
                    // Code block இருந்தால் (`containsCode` flag true ஆக இருந்தால்), PrismJS-ஐ பயன்படுத்தி syntax highlighting செய்கிறோம்.
                    // இது message DOM-ல் சேர்க்கப்பட்ட பிறகு, ஒரு ചെറിയ தாமதத்திற்குப் பிறகு (setTimeout) செய்யப்படுகிறது. இது DOM புதுப்பிக்கப்படுவதை உறுதி செய்கிறது.
                    // `Prism.highlightAllUnder(messageElement)` என்பது messageElement-க்குள் உள்ள அனைத்து code block-களையும் highlight செய்யும்.
                    if (containsCode && typeof Prism !== 'undefined') {
                         setTimeout(() => { // Use timeout to ensure DOM update
                             try {
                                 Prism.highlightAllUnder(messageElement);
                                 console.log("Prism highlighting applied under element.");
                             } catch (highlightError) {
                                 console.error("Prism highlighting error:", highlightError);
                             }
                         }, 0); // Minimal delay is usually sufficient
                     }
                }
            } else { console.warn(`Skipping display of empty message. Sender: ${sender}, Classes: ${cssClasses.join(', ')}`); }
            return messageElement;
        }


        // --- MCQ/Test/Review/All Tests Functions ---
        // ***** TAMIL *****
        // இந்த functions எல்லாம் mock test, review, saved tests தொடர்பானவை. இவற்றில் மாற்றம் இல்லை.
        // handleChatAreaClick, displayMCQOffer, startMockTest, displayTestQuestion,
        // handleOptionSelect, handleTestNavigation, startTestTimer, submitTest,
        // calculateResults, displayReview, handleReviewFilterClick, filterReviewItems,
        // exitReview, saveTestReviewToCloud, loadAndListenForTests, renderAllTestsList,
        // filterTestsInSidebar, handleAllTestsListClick, enterTestTitleEditMode,
        // exitTestTitleEditMode, saveTestTitle, deleteSavedTest, startReattempt
        // (These functions remain unchanged from v10.3)
         function handleChatAreaClick(event) { const startButton = event.target.closest('.start-test-button'); if (startButton) { const mcqDataString = startButton.dataset.mcq; const titleFromButton = startButton.dataset.mcqTitle; let mcqs = null; if (mcqDataString) { try { mcqs = JSON.parse(mcqDataString); } catch (e) { console.error("Failed parse MCQ data from button:", e); displayError("Could not start test. Invalid data."); return; } } if (mcqs?.length > 0) { startMockTest(mcqs, titleFromButton || null); } else { displayError("MCQ data missing or invalid."); } return; } const clickedImage = event.target.closest('img.chat-image, img.uploaded-image'); if (clickedImage?.src && !clickedImage.src.startsWith('#') && clickedImage.src.trim() !== '') { try { if (!clickedImage.src.startsWith('data:image') || clickedImage.src.length < 2 * 1024 * 1024) { window.open(clickedImage.src, '_blank'); } else { console.log("Clicked large base64 image in chat."); } } catch (e) { console.error("Error opening image source:", e); } } }
         function displayMCQOffer(mcqData, mcqTitle, aiMessageElement) { if (aiMessageElement.querySelector('.start-test-button')) return; const questionCount = mcqData.length; const button = document.createElement('button'); button.classList.add('start-test-button'); button.textContent = `Start Mock Test (${questionCount} Qs)`; button.title = mcqTitle || `Start generated test`; try { button.dataset.mcq = JSON.stringify(mcqData); if (mcqTitle) { button.dataset.mcqTitle = mcqTitle; } } catch (e) { console.error("Failed stringify MCQ data for button:", e); return; } const buttonContainer = document.createElement('div'); buttonContainer.style.marginTop = '10px'; buttonContainer.appendChild(button); aiMessageElement.appendChild(buttonContainer); }
         function startMockTest(mcqs, title = null) { if (!currentUser) { displayError("Log in to start test."); return; } if (!mcqs?.length) { displayError("No questions for test."); if (cameFromAllTestsList) { switchView('chat'); } return; } console.log("Starting mock test:", mcqs.length, "Qs. Title:", title); currentTestMCQs = mcqs; currentQuestionIndex = 0; userAnswers = new Array(mcqs.length).fill(null); reviewResultsCache = null; switchView('test'); displayTestQuestion(0); startTestTimer(); const finalTitle = (title && title.trim()) ? title.trim() : `Mock Test (${mcqs.length} Qs)`; testTitle.textContent = finalTitle; }
         function displayTestQuestion(index) { if (index < 0 || index >= currentTestMCQs.length) return; currentQuestionIndex = index; const questionData = currentTestMCQs[index]; const questionText = questionData.question?.en || "(Question missing)"; testQuestionNumber.textContent = `Question ${index + 1}`; testQuestion.innerHTML = questionText; testOptionsContainer.innerHTML = ''; const options = questionData.options || []; const optionLetters = ['A', 'B', 'C', 'D']; options.forEach((optionObj, optionIndex) => { if (optionIndex >= optionLetters.length) return; const optionText = optionObj?.en || '(Option missing)'; const label = document.createElement('label'); const input = document.createElement('input'); input.type = 'radio'; input.name = `q_${index}`; input.value = optionIndex; input.checked = (userAnswers[index] === optionIndex); input.onchange = () => handleOptionSelect(optionIndex); label.appendChild(input); label.appendChild(document.createTextNode(` ${optionLetters[optionIndex]}. ${optionText}`)); testOptionsContainer.appendChild(label); }); try { if (typeof MathJax !== "undefined" && MathJax.typesetPromise) { MathJax.typesetPromise([testQuestion, testOptionsContainer]).catch(err=>console.error('MathJax Test Q Error:', err)); } } catch(e){ console.error("MathJax call failed in test:", e); } prevQuestionBtn.disabled = (index === 0); nextQuestionBtn.disabled = (index === currentTestMCQs.length - 1); questionCounter.textContent = `Q: ${index + 1} / ${currentTestMCQs.length}`; }
         function handleOptionSelect(optionIndex) { if (currentQuestionIndex >= 0 && currentQuestionIndex < userAnswers.length) { userAnswers[currentQuestionIndex] = optionIndex; console.log(`Answered Q${currentQuestionIndex + 1}: Option ${optionIndex}`); } }
         function handleTestNavigation(direction) { let newIndex = currentQuestionIndex; if (direction === 'prev' && currentQuestionIndex > 0) { newIndex--; } else if (direction === 'next' && currentQuestionIndex < currentTestMCQs.length - 1) { newIndex++; } if (newIndex !== currentQuestionIndex) { displayTestQuestion(newIndex); } }
         function startTestTimer() { if (testTimerInterval) clearInterval(testTimerInterval); testStartTime = Date.now(); testTimer.textContent = `Time: 00:00`; testTimerInterval = setInterval(() => { const elapsedSeconds = Math.floor((Date.now() - testStartTime) / 1000); const minutes = Math.floor(elapsedSeconds / 60).toString().padStart(2, '0'); const seconds = (elapsedSeconds % 60).toString().padStart(2, '0'); testTimer.textContent = `Time: ${minutes}:${seconds}`; }, 1000); }
         function submitTest() { if (!confirm("Submit test?")) return; if (testTimerInterval) clearInterval(testTimerInterval); const endTime = Date.now(); const timeTakenMs = testStartTime ? endTime - testStartTime : 0; const results = calculateResults(currentTestMCQs, userAnswers, timeTakenMs); reviewResultsCache = results; switchView('review', false); displayReview(results); }
         function calculateResults(mcqs, answers, timeMs) { let correctCount = 0, incorrectCount = 0, skippedCount = 0; const reviewQuestions = []; mcqs.forEach((q, idx) => { const uAIdx = answers[idx]; const opts = q.options || []; const cALtr = q.answer?.trim().toUpperCase(); const cAIdx = cALtr ? cALtr.charCodeAt(0) - 'A'.charCodeAt(0) : -1; const cATxtE = (cAIdx >= 0 && cAIdx < opts.length) ? (opts[cAIdx]?.en || '?') : "N/A"; let uATxtE = "Skipped"; let st = "skipped"; if (uAIdx !== null && uAIdx >= 0 && uAIdx < opts.length) { uATxtE = opts[uAIdx]?.en || '?'; if (uAIdx === cAIdx) { st = "correct"; correctCount++; } else { st = "incorrect"; incorrectCount++; } } else if (uAIdx !== null) { uATxtE = "Invalid"; st = "incorrect"; incorrectCount++; } else { skippedCount++; } reviewQuestions.push({ question: q.question?.en || '?', correctAnswer: cATxtE, userAnswer: uATxtE, status: st, explanation: q.explanation?.en || "N/A" }); }); const total = mcqs.length; const score = `${correctCount}/${total}`; const timeS = Math.round(timeMs / 1000); const mins = Math.floor(timeS / 60); const secs = timeS % 60; const timeStr = `${mins}m ${secs}s`; return { questions: reviewQuestions, summary: { score, correct: correctCount, incorrect: incorrectCount, skipped: skippedCount, timeString: timeStr }, testDate: new Date().toISOString(), timeTakenMs: timeMs, sourceChatId: activeChatId, testTitle: testTitle.textContent, originalMCQs: mcqs }; }
         function displayReview(reviewData) { reviewContent.innerHTML = ''; reviewSummary.innerHTML = ''; reviewFilters.style.display = 'none'; if (!reviewData?.questions?.length || !reviewData.summary || !reviewData.originalMCQs) { reviewSummary.innerHTML = "<span>No review data available.</span>"; saveReviewBtn.style.display = 'none'; return; } const { score, correct, incorrect, skipped, timeString } = reviewData.summary; reviewSummary.innerHTML = `<span>Score: ${score}</span> <span class="score-correct">Correct: ${correct}</span> <span class="score-incorrect">Incorrect: ${incorrect}</span> <span class="score-skipped">Skipped: ${skipped}</span> <span>Time: ${timeString}</span>`; reviewTitle.textContent = reviewData.testTitle || "Test Review"; reviewData.questions.forEach((qSum, idx) => { const origQ = reviewData.originalMCQs[idx]; if (!origQ) return; const qTxt = origQ.question?.en || '?'; const opts = origQ.options || []; const cALtr = origQ.answer?.trim().toUpperCase(); const cAIdx = cALtr ? cALtr.charCodeAt(0) - 'A'.charCodeAt(0) : -1; const cATxt = (cAIdx >= 0 && cAIdx < opts.length) ? (opts[cAIdx]?.en) : "N/A"; let uATxt = qSum.userAnswer; const st = qSum.status; if (st === 'skipped') uATxt = "Skipped"; else if (st === 'invalid') uATxt = "Invalid"; const explTxt = origQ.explanation?.en || "N/A."; let iStCls = `status-${st}`; let aDtCls = `user-answer-${st}`; const rItem = document.createElement('div'); rItem.classList.add('review-item', iStCls); rItem.dataset.status = st; let dHtml = `<span class="${aDtCls}">Your Answer: ${uATxt}</span>`; if (st !== 'correct') { dHtml += `<br><span class="correct-answer">Correct Answer: ${cATxt}</span>`; } dHtml += `<div class="review-item-explanation">Explanation: ${explTxt}</div>`; rItem.innerHTML = `<div class="review-item-qnum">Q ${idx + 1}</div> <div class="review-item-question">${qTxt}</div> <div class="review-item-details">${dHtml}</div>`; reviewContent.appendChild(rItem); }); if (incorrect > 0 || skipped > 0) reviewFilters.style.display = 'block'; else reviewFilters.style.display = 'none'; if (reviewData.savedAt) { saveReviewBtn.textContent = "Saved"; saveReviewBtn.disabled = true; saveReviewBtn.style.display = 'inline-block'; } else if (reviewResultsCache && !cameFromAllTestsList) { saveReviewBtn.textContent = "Save Review"; saveReviewBtn.disabled = !currentUser; saveReviewBtn.style.display = 'inline-block'; } else { saveReviewBtn.style.display = 'none'; } filterReviewItems('all'); reviewFilters.querySelectorAll('button').forEach(btn => { btn.classList.toggle('active-filter', btn.dataset.filter === 'all'); }); try { if (typeof MathJax !== "undefined" && MathJax.typesetPromise) { MathJax.typesetPromise([reviewContent]).catch(err=>console.error('MathJax Review Error:', err)); } } catch (e) { console.error("MathJax call failed in review:", e); } }
         function handleReviewFilterClick(event) { const button = event.target.closest('button[data-filter]'); if (button) { filterReviewItems(button.dataset.filter); } }
         function filterReviewItems(filter) { reviewFilters.querySelectorAll('button').forEach(btn => { btn.classList.toggle('active-filter', btn.dataset.filter === filter); }); reviewContent.querySelectorAll('.review-item').forEach(item => { const show = (filter === 'all') || item.dataset.status === filter; item.classList.toggle('hidden-by-filter', !show); }); }
         function exitReview() { reviewResultsCache = null; switchView('chat'); reviewSummary.innerHTML = ''; reviewContent.innerHTML = ''; reviewTitle.textContent = 'Review'; }
         async function saveTestReviewToCloud() { if (!currentUser) { alert("Please log in to save the review."); return; } if (!reviewResultsCache || reviewResultsCache.savedAt) { alert("No new review data to save or already saved."); return; } if (!reviewResultsCache.originalMCQs?.length || !reviewResultsCache.summary) { if (!confirm("Warning: Review data seems incomplete. Save anyway?")) { return; } } const dataToSave = { ...reviewResultsCache, userId: currentUser.uid, savedAt: firebase.firestore.FieldValue.serverTimestamp(), }; saveReviewBtn.disabled = true; saveReviewBtn.textContent = "Saving..."; try { const newRef = await db.collection('testReviews').add(dataToSave); console.log("Review saved:", newRef.id); alert("Review saved!"); saveReviewBtn.textContent = "Saved"; if (reviewResultsCache) reviewResultsCache.savedAt = new Date(); } catch (error) { console.error("Error saving review:", error); alert("Failed to save review."); saveReviewBtn.disabled = false; saveReviewBtn.textContent = "Save Review"; } }
         function loadAndListenForTests(userId) { if (testListListener) { testListListener(); testListListener = null; } const testsRef = db.collection('testReviews').where('userId', '==', userId).orderBy('savedAt', 'desc'); console.log(`Listening for saved tests for user ${userId}`); testListListener = testsRef.onSnapshot(snapshot => { allSavedTestsData = []; snapshot.forEach(doc => { allSavedTestsData.push({ id: doc.id, ...doc.data() }); }); console.log("Received saved tests snapshot:", allSavedTestsData.length, "tests"); renderAllTestsList(allSavedTestsData); filterTestsInSidebar(); }, error => { console.error("Error listening for saved tests:", error); allTestsListContainer.innerHTML = `<div style="padding:10px; color:var(--error-text);">Error loading saved tests.</div>`; allSavedTestsData = []; }); }
         function renderAllTestsList(tests) { allTestsListContainer.innerHTML = ''; if (!currentUser) { allTestsListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);">Login to see tests.</div>'; return; } if (tests.length === 0) { allTestsListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);">No saved tests found.</div>'; } else { tests.forEach(testData => { const item = document.createElement('div'); item.classList.add('test-list-item'); item.dataset.reviewId = testData.id; const title = testData.testTitle || '(Untitled Test)'; const date = testData.savedAt?.toDate ? testData.savedAt.toDate().toLocaleString() : 'Unknown date'; const score = testData.summary?.score || 'N/A'; const hasReattemptData = testData.originalMCQs?.length > 0 && testData.originalMCQs.every(q => q?.question && q.options && q.answer && q.explanation); const infoDiv = document.createElement('div'); infoDiv.classList.add('test-item-info'); const titleSpan = document.createElement('span'); titleSpan.classList.add('test-item-title'); titleSpan.textContent = title; titleSpan.title = title; const detailSpan = document.createElement('span'); detailSpan.classList.add('test-item-details'); detailSpan.textContent = `Saved: ${date} | Score: ${score}`; const controlsDiv = document.createElement('div'); controlsDiv.classList.add('test-item-controls'); const editButton = document.createElement('button'); editButton.innerHTML = EDIT_TEST_ICON; editButton.title = "Edit title"; editButton.dataset.action = "edit-title"; controlsDiv.appendChild(editButton); const deleteButton = document.createElement('button'); deleteButton.innerHTML = DELETE_TEST_ICON; deleteButton.title = "Delete test"; deleteButton.dataset.action = "delete-test"; controlsDiv.appendChild(deleteButton); infoDiv.appendChild(titleSpan); infoDiv.appendChild(detailSpan); infoDiv.appendChild(controlsDiv); const actionsDiv = document.createElement('div'); actionsDiv.classList.add('test-item-actions'); const viewButton = document.createElement('button'); viewButton.textContent = "Details"; viewButton.dataset.action = "view"; actionsDiv.appendChild(viewButton); const reattemptSelect = document.createElement('select'); reattemptSelect.dataset.action = "reattempt"; reattemptSelect.disabled = !hasReattemptData; reattemptSelect.title = hasReattemptData ? "Reattempt test" : "Reattempt data not available"; reattemptSelect.innerHTML = `<option value="" selected>${hasReattemptData ? 'Reattempt...' : 'N/A'}</option> <option value="mistaked" ${!hasReattemptData?'disabled':''}>Mistaked Only</option> <option value="skipped" ${!hasReattemptData?'disabled':''}>Skipped Only</option> <option value="both" ${!hasReattemptData?'disabled':''}>Mistaked/Skipped</option> <option value="full" ${!hasReattemptData?'disabled':''}>Full Test</option>`; reattemptSelect.addEventListener('change', (e) => { const selectedMode = e.target.value; if (selectedMode) { const reviewId = e.target.closest('.test-list-item')?.dataset.reviewId; if (reviewId) { startReattempt(reviewId, selectedMode); } e.target.value = ""; } }); actionsDiv.appendChild(reattemptSelect); item.appendChild(infoDiv); item.appendChild(actionsDiv); allTestsListContainer.appendChild(item); }); } }
         function filterTestsInSidebar() { const searchTerm = testSearchInput.value.toLowerCase().trim(); const items = allTestsListContainer.querySelectorAll('.test-list-item'); let visibleCount = 0; const noResultsMsg = allTestsListContainer.querySelector('.no-search-results'); if (noResultsMsg) { noResultsMsg.remove(); } items.forEach(item => { const title = item.querySelector('.test-item-title')?.textContent.toLowerCase() || ''; const details = item.querySelector('.test-item-details')?.textContent.toLowerCase() || ''; const isMatch = title.includes(searchTerm) || details.includes(searchTerm); item.classList.toggle('hidden-by-search', !isMatch); if (isMatch) visibleCount++; }); if (visibleCount === 0 && searchTerm !== '' && items.length > 0) { const msgDiv = document.createElement('div'); msgDiv.textContent = "No saved tests match your search."; msgDiv.classList.add('no-search-results'); allTestsListContainer.appendChild(msgDiv); } }
         async function handleAllTestsListClick(event) { const button = event.target.closest('button[data-action], select[data-action]'); if (!button || button.tagName === 'SELECT') return; const action = button.dataset.action; const listItem = button.closest('.test-list-item'); const reviewId = listItem?.dataset.reviewId; if (!reviewId) { console.error("Could not find review ID for action:", action); return; } switch (action) { case "view": const reviewData = allSavedTestsData.find(t => t.id === reviewId); if (reviewData) { reviewResultsCache = reviewData; switchView('review', true); displayReview(reviewData); } else { alert("Error: Could not find review data to display."); } break; case "edit-title": enterTestTitleEditMode(listItem, reviewId); break; case "delete-test": const testTitle = listItem.querySelector('.test-item-title')?.textContent || 'this test'; if (confirm(`Are you sure you want to delete the test "${testTitle}"?`)) { deleteSavedTest(reviewId, listItem); } break; } }
         function enterTestTitleEditMode(listItem, reviewId) { const infoDiv = listItem.querySelector('.test-item-info'); const titleSpan = infoDiv.querySelector('.test-item-title'); const detailSpan = infoDiv.querySelector('.test-item-details'); const controlsDiv = infoDiv.querySelector('.test-item-controls'); const currentTitle = titleSpan.textContent; titleSpan.style.display = 'none'; detailSpan.style.display = 'none'; if(controlsDiv) controlsDiv.style.display = 'none'; if (infoDiv.querySelector('.test-item-edit-mode')) return; const editContainer = document.createElement('div'); editContainer.classList.add('test-item-edit-mode'); const input = document.createElement('input'); input.type = 'text'; input.value = currentTitle; input.maxLength = 100; input.addEventListener('keydown', (e) => { if (e.key === 'Enter') { saveTestTitle(listItem, reviewId, input.value); } else if (e.key === 'Escape') { exitTestTitleEditMode(listItem, currentTitle); } }); const saveButton = document.createElement('button'); saveButton.textContent = 'Save'; saveButton.onclick = () => saveTestTitle(listItem, reviewId, input.value); const cancelButton = document.createElement('button'); cancelButton.textContent = 'Cancel'; cancelButton.onclick = () => exitTestTitleEditMode(listItem, currentTitle); editContainer.appendChild(input); editContainer.appendChild(saveButton); editContainer.appendChild(cancelButton); infoDiv.appendChild(editContainer); input.focus(); input.select(); }
        function exitTestTitleEditMode(listItem, originalTitle = null) { const infoDiv = listItem.querySelector('.test-item-info'); const titleSpan = infoDiv.querySelector('.test-item-title'); const detailSpan = infoDiv.querySelector('.test-item-details'); const controlsDiv = infoDiv.querySelector('.test-item-controls'); const editContainer = infoDiv.querySelector('.test-item-edit-mode'); if (editContainer) editContainer.remove(); if (originalTitle !== null && titleSpan) { titleSpan.textContent = originalTitle; titleSpan.title = originalTitle; } if(titleSpan) titleSpan.style.display = ''; if(detailSpan) detailSpan.style.display = ''; if(controlsDiv) controlsDiv.style.display = ''; }
        async function saveTestTitle(listItem, reviewId, newTitle) { const trimmedTitle = newTitle.trim(); if (!trimmedTitle) { alert("Test title cannot be empty."); return; } if (trimmedTitle.length > 100) { alert("Test title is too long (max 100 characters)."); return; } const docRef = db.collection('testReviews').doc(reviewId); try { await docRef.update({ testTitle: trimmedTitle }); console.log("Test title updated successfully:", reviewId); const titleSpan = listItem.querySelector('.test-item-title'); if (titleSpan) { titleSpan.textContent = trimmedTitle; titleSpan.title = trimmedTitle; } const testIndex = allSavedTestsData.findIndex(t => t.id === reviewId); if (testIndex > -1) allSavedTestsData[testIndex].testTitle = trimmedTitle; exitTestTitleEditMode(listItem); } catch (error) { console.error("Error updating test title:", error); alert("Failed to update test title."); } }
        async function deleteSavedTest(reviewId, listItem) { if (!currentUser || !reviewId) return; listItem.style.opacity = '0.5'; listItem.style.pointerEvents = 'none'; const docRef = db.collection('testReviews').doc(reviewId); try { await docRef.delete(); console.log("Saved test deleted successfully:", reviewId); allSavedTestsData = allSavedTestsData.filter(t => t.id !== reviewId); alert("Saved test deleted."); } catch (error) { console.error("Error deleting saved test:", error); alert("Failed to delete saved test."); listItem.style.opacity = '1'; listItem.style.pointerEvents = 'auto'; } }
        async function startReattempt(reviewId, mode) { console.log(`Attempting reattempt for review ID: ${reviewId}, Mode: ${mode}`); const reviewData = allSavedTestsData.find(t => t.id === reviewId); if (!reviewData) { alert("Error: Could not find the saved review data for reattempt."); return; } const originalMCQs = reviewData.originalMCQs; const hasValidData = originalMCQs?.length > 0 && originalMCQs.every(q => q?.question && q.options && q.answer && q.explanation); if (!hasValidData) { alert("Error: Cannot reattempt. Original test data is missing or invalid."); return; } const summaryQuestions = reviewData.questions || []; let questionsForReattempt = []; switch (mode) { case 'mistaked': questionsForReattempt = originalMCQs.filter((mcq, index) => summaryQuestions[index]?.status === 'incorrect'); break; case 'skipped': questionsForReattempt = originalMCQs.filter((mcq, index) => summaryQuestions[index]?.status === 'skipped'); break; case 'both': questionsForReattempt = originalMCQs.filter((mcq, index) => summaryQuestions[index]?.status === 'incorrect' || summaryQuestions[index]?.status === 'skipped'); break; case 'full': default: questionsForReattempt = [...originalMCQs]; break; } if (questionsForReattempt.length === 0) { alert(`No questions found for the selected reattempt mode ('${mode}').`); return; } const originalTitle = reviewData.testTitle || 'Test'; const reattemptTitle = `${originalTitle} (Reattempt: ${mode})`; startMockTest(questionsForReattempt, reattemptTitle); }

        // ***** TAMIL *****
        // Web Browsing / Search பற்றி குறிப்பு:
        // இந்த JavaScript SDK (@google/generative-ai) நேரடியாக web search செய்ய வைக்கும் `tool_code` போன்ற அமைப்பை client-side-ல் ஆதரிக்காது.
        // Google Search போன்ற external tools-ஐ பயன்படுத்த, நீங்கள் ஒரு backend server (e.g., Cloud Functions, Node.js) பயன்படுத்த வேண்டும் அல்லது Vertex AI Agent போன்ற சேவைகளைப் பயன்படுத்த வேண்டும்.
        // ஆனால், Gemini models பயிற்சி செய்யப்பட்ட பரந்த இணையத் தரவுகளிலிருந்து தகவல்களைப் பயன்படுத்த முடியும்.
        // நீங்கள் ஒரு கேள்வியைக் கேட்டால், model அதனிடம் உள்ள தகவல்களின் அடிப்படையில் பதிலளிக்க முயற்சிக்கும்.
        // ஒருவேளை model தானாகவே web search செய்து பதிலளித்தால், அது நமக்குத் தெரியாது (அது model-ன் உள் செயல்பாடு).
        // நீங்கள் இங்கு கேட்கும் கேள்விகளுக்கு, model அதன் பயிற்சி தரவை வைத்து பதிலளிக்கும்.

    </script>

</body>
</html>
