<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Version Updated -->
    <title>Gemini Chat + Mock Test (v10.5 - Audio Playback, Upload Status)</title> <!-- Version Updated -->
    <script>
        // MathJax Configuration
        window.MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']], displayMath: [['$$', '$$'], ['\\[', '\\]']] },
            svg: { fontCache: 'global' },
            options: { skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
    <!-- <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-storage-compat.js"></script> -->

    <!-- Google Generative AI SDK (Loaded as Module) -->
    <script type="module">
        // Make SDK accessible globally after import
        try {
            // ***** TAMIL *****
            // ‡Æá‡Æô‡Øç‡Æï Google Generative AI SDK-‡Æê import ‡Æö‡ØÜ‡ÆØ‡Øç‡Æï‡Æø‡Æ±‡Øã‡ÆÆ‡Øç. ‡Æá‡Æ§‡ØÅ‡Æ§‡Ææ‡Æ©‡Øç Gemini API ‡Æâ‡Æü‡Æ©‡Øç ‡Æ™‡Øá‡Æö ‡Æâ‡Æ§‡Æµ‡ØÅ‡ÆÆ‡Øç.
            const { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold } = await import("https://esm.run/@google/generative-ai");
            window.GoogleGenerativeAI = GoogleGenerativeAI;
            // ‡Æ™‡Ææ‡Æ§‡ØÅ‡Æï‡Ææ‡Æ™‡Øç‡Æ™‡ØÅ ‡ÆÖ‡ÆÆ‡Øà‡Æ™‡Øç‡Æ™‡ØÅ‡Æï‡Æ≥‡Øà‡ÆØ‡ØÅ‡ÆÆ‡Øç import ‡Æö‡ØÜ‡ÆØ‡Øç‡Æï‡Æø‡Æ±‡Øã‡ÆÆ‡Øç
            window.HarmCategory = HarmCategory;
            window.HarmBlockThreshold = HarmBlockThreshold;
            console.log("GoogleGenerativeAI SDK loaded successfully via module.");
            // SDK load ‡ÆÜ‡Æ©‡Æ§‡ØÅ‡ÆÆ‡Øç ‡Æí‡Æ∞‡ØÅ event-‡Æê trigger ‡Æö‡ØÜ‡ÆØ‡Øç‡Æï‡Æø‡Æ±‡Øã‡ÆÆ‡Øç.
            window.dispatchEvent(new Event('google-ai-sdk-loaded'));
        } catch (error) {
            console.error("Failed to load GoogleGenerativeAI SDK:", error);
            // ‡Æ™‡Æø‡Æ¥‡Øà ‡Æè‡Æ±‡Øç‡Æ™‡Æü‡Øç‡Æü‡Ææ‡Æ≤‡Øç console-‡Æ≤‡Øç ‡Æï‡Ææ‡Æü‡Øç‡Æü‡ØÅ‡Æµ‡Æ§‡Øã‡Æü‡ØÅ, ‡Æí‡Æ∞‡ØÅ global variable-‡Æ≤‡Øç store ‡Æö‡ØÜ‡ÆØ‡Øç‡Æï‡Æø‡Æ±‡Øã‡ÆÆ‡Øç.
            window.googleAiSdkLoadError = error;
        }
    </script>

    <!-- Prism JS for Code Syntax Highlighting -->
    <!-- ***** TAMIL *****
        PrismJS CSS theme ‡ÆÆ‡Æ±‡Øç‡Æ±‡ØÅ‡ÆÆ‡Øç JavaScript files-‡Æê load ‡Æö‡ØÜ‡ÆØ‡Øç‡Æï‡Æø‡Æ±‡Øã‡ÆÆ‡Øç.
        Order ‡ÆÆ‡ØÅ‡Æï‡Øç‡Æï‡Æø‡ÆØ‡ÆÆ‡Øç: core -> autoloader -> plugins (toolbar, copy-to-clipboard).
    -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>


    <style>
        /* --- Styles (v10.5 - Added Audio Player styling) --- */
        /* ***** TAMIL *****
           ‡Æá‡Æô‡Øç‡Æï CSS styles ‡Æâ‡Æ≥‡Øç‡Æ≥‡Æ©.
           ‡Æ™‡ØÅ‡Æ§‡ØÅ‡Æö‡Ææ image modal-‡Æï‡Øç‡Æï‡ØÅ‡ÆÆ‡Øç, message copy/delete icon-‡Æï‡Æ≥‡ØÅ‡Æï‡Øç‡Æï‡ØÅ‡ÆÆ‡Øç, chat-‡Æ≤ audio player-‡Æï‡Øç‡Æï‡ØÅ‡ÆÆ‡Øç style ‡Æö‡Øá‡Æ∞‡Øç‡Æ§‡Øç‡Æ§‡Æø‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡Øá‡Æ©‡Øç.
        */
        :root { /* ... Theme Variables ... */
             --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; --sidebar-width: 260px; --message-font-size-base: 1rem;
            /* LIGHT */ --sidebar-bg: #f7f7f7; --main-bg: #ffffff; --input-bg: #ffffff; --border-color: #e0e0e0; --text-primary: #2c2c2c; --text-secondary: #5f5f5f; --text-placeholder: #999999; --accent-color: #d97a7a; --user-message-bg: #cce0ff; --user-message-text: #1c1c1c; --ai-message-bg: #f0f0f0; --ai-message-text: #2c2c2c; --button-bg: #f0f0f0; --button-hover-bg: #e0e0e0; --active-item-bg: #e0e0e0; --code-bg: #e8e8e8; --scrollbar-thumb: #ccc; --scrollbar-thumb-hover: #bbb; --app-outer-bg: #e8e8e8; --send-button-bg: var(--accent-color); --send-button-hover-bg: #c76b6b; --send-button-text: #ffffff; --error-bg: #ffebee; --error-text: #c62828; --error-border: #ef9a9a; --message-font-size: var(--message-font-size-base); --delete-button-color: #aaa; --delete-button-hover-color: #dc3545; --input-border-color: var(--border-color); --input-focus-border-color: var(--accent-color); --preview-bg: var(--button-bg); --preview-border: var(--border-color); --remove-btn-color: var(--text-secondary); --remove-btn-hover-color: var(--error-text); --message-action-color: #888; --message-action-hover-color: #333; --modal-bg: rgba(0, 0, 0, 0.7); --modal-content-bg: #ffffff; --modal-close-color: #aaa; --modal-close-hover-color: #fff;
            /* Audio Specific */
            --record-button-bg: #ff6b6b; --record-button-text: #ffffff; --stop-button-bg: #4a4a4a; --stop-button-text: #ffffff; --audio-player-bg: var(--ai-message-bg); --audio-player-controls: var(--text-secondary); --audio-player-progress: var(--accent-color); --audio-player-thumb: var(--text-primary);
            /* Model Selector Specific */
             --selector-bg: var(--input-bg); --selector-border: var(--border-color); --selector-text: var(--text-secondary);
        }
        body.dark-theme { /* DARK */ --sidebar-bg: #2a2a2e; --main-bg: #1e1e1e; --input-bg: #2a2a2e; --border-color: #404040; --text-primary: #e0e0e0; --text-secondary: #a0a0a0; --text-placeholder: #777777; --accent-color: #e58b8b; --user-message-bg: #3a4a6b; --user-message-text: #e8e8e8; --ai-message-bg: #333333; --ai-message-text: #e0e0e0; --button-bg: #404040; --button-hover-bg: #505050; --active-item-bg: #454545; --code-bg: #2c2c2e; --scrollbar-thumb: #555; --scrollbar-thumb-hover: #666; --app-outer-bg: #121212; --send-button-bg: var(--accent-color); --send-button-hover-bg: #f09f9f; --send-button-text: #1e1e1e; --error-bg: #5c2b2b; --error-text: #ffcdd2; --error-border: #8c4343; --delete-button-color: #666; --delete-button-hover-color: #f09f9f; --input-border-color: var(--border-color); --input-focus-border-color: var(--accent-color); --preview-bg: var(--button-bg); --preview-border: var(--border-color); --remove-btn-color: var(--text-secondary); --remove-btn-hover-color: var(--error-text); --message-action-color: #999; --message-action-hover-color: #eee; --modal-bg: rgba(0, 0, 0, 0.8); --modal-content-bg: #2a2a2e; --modal-close-color: #aaa; --modal-close-hover-color: #fff;
            /* Audio Specific */
             --record-button-bg: #ff8787; --record-button-text: #1e1e1e; --stop-button-bg: #777777; --stop-button-text: #e0e0e0; --audio-player-bg: var(--ai-message-bg); --audio-player-controls: var(--text-secondary); --audio-player-progress: var(--accent-color); --audio-player-thumb: var(--text-primary);
            /* Model Selector Specific */
             --selector-bg: var(--input-bg); --selector-border: var(--border-color); --selector-text: var(--text-secondary);
        }
        body { font-family: var(--font-family); margin: 0; padding: 0; background-color: var(--app-outer-bg); color: var(--text-primary); font-size: 15px; transition: background-color 0.3s ease, color 0.3s ease; }

        /* Layout & Structure */
        .app-container { display: flex; height: 100vh; width: 100vw; overflow: hidden; } .app-container.hidden { display: none; }
        .sidebar { width: var(--sidebar-width); background-color: var(--sidebar-bg); border-right: 1px solid var(--border-color); display: flex; flex-direction: column; padding: 15px 0; box-sizing: border-box; flex-shrink: 0; transition: background-color 0.3s ease, border-color 0.3s ease, width 0.3s ease; }
        .main-container { flex-grow: 1; display: flex; flex-direction: column; height: 100vh; overflow: hidden; position: relative; }
        .main-content, .review-view { display: none; flex-direction: column; background-color: var(--main-bg); height: 100%; width: 100%; overflow: hidden; transition: background-color 0.3s ease; }
        .main-content.active, .review-view.active { display: flex; }
        .chat-area { flex-grow: 1; overflow-y: auto; padding: 30px 10% 20px; display: flex; flex-direction: column; max-width: 800px; margin: 0 auto; width: 80%; }
        .input-container { padding: 15px 10% 20px; border-top: 1px solid var(--border-color); background-color: var(--input-bg); max-width: 800px; margin: 0 auto; width: 80%; transition: background-color 0.3s ease, border-color 0.3s ease; display: none; }

        /* Sidebar Elements (No changes needed) */
         .sidebar-header { padding: 10px 20px; font-size: 1.1em; font-weight: 600; color: var(--text-primary); }
         .sidebar-section { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; margin-top: 10px; }
         .sidebar-section-title { padding: 5px 20px; font-size: 0.85em; font-weight: 600; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px; flex-shrink: 0; }
         #all-tests-section { border-bottom: 1px solid var(--border-color); margin-bottom: 10px; padding-bottom: 10px; flex-shrink: 0; display: flex; flex-direction: column; max-height: 40%; display: none; }
         #all-tests-section.visible { display: flex; }
         #test-search-input { width: calc(100% - 40px); padding: 8px 10px; margin: 5px 15px 10px 15px; border: 1px solid var(--input-border-color); background-color: var(--input-bg); color: var(--text-primary); border-radius: 6px; font-size: 0.9em; box-sizing: border-box; }
         #test-search-input:focus { outline: none; border-color: var(--input-focus-border-color); }
         #all-tests-list { overflow-y: auto; padding: 0 15px; flex-grow: 1; }
         #all-tests-list::-webkit-scrollbar { width: 6px; } #all-tests-list::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 3px;} #all-tests-list::-webkit-scrollbar-thumb:hover { background: var(--scrollbar-thumb-hover); }
         .test-list-item { padding: 8px 10px; margin-bottom: 5px; border-radius: 6px; background-color: var(--button-bg); cursor: default; transition: background-color 0.2s ease; display: flex; flex-direction: column; gap: 5px; border: 1px solid var(--border-color); }
         .test-list-item.hidden-by-search { display: none; }
         .test-list-item .no-search-results { padding:10px;color:var(--text-secondary);font-size:0.9em; }
         .test-item-info { font-size: 0.9em; color: var(--text-primary); position: relative; padding-right: 50px; }
         .test-item-title { font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: block; }
         .test-item-details { font-size: 0.8em; color: var(--text-secondary); }
         .test-item-actions { display: flex; justify-content: flex-start; gap: 8px; margin-top: 5px; }
         .test-item-actions button, .test-item-actions select { background-color: var(--main-bg); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 4px; padding: 4px 8px; font-size: 0.8em; cursor: pointer; transition: background-color 0.2s ease, color 0.2s ease; }
         .test-item-actions button:hover, .test-item-actions select:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
         .test-item-actions select:disabled { opacity: 0.6; cursor: not-allowed; }
        .test-item-controls { position: absolute; right: 5px; top: 0; display: flex; gap: 5px; }
        .test-item-controls button { background: none; border: none; color: var(--delete-button-color); cursor: pointer; font-size: 1.1em; padding: 0 3px; line-height: 1; opacity: 0.7; transition: color 0.2s ease, opacity 0.2s ease; }
        .test-item-controls button:hover { opacity: 1; color: var(--delete-button-hover-color); }
        .test-item-edit-mode { display: flex; align-items: center; }
        .test-item-edit-mode input[type="text"] { flex-grow: 1; padding: 2px 4px; margin-right: 5px; border: 1px solid var(--input-focus-border-color); background-color: var(--input-bg); color: var(--text-primary); border-radius: 3px; font-size: 0.95em; }
        .test-item-edit-mode button { font-size: 0.9em; padding: 2px 5px; background-color: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 3px; cursor: pointer; margin-left: 3px; }
        .test-item-edit-mode button:hover { background-color: var(--button-hover-bg); }
         .start-chat-button { display: flex; align-items: center; gap: 8px; background-color: var(--main-bg); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 8px; padding: 10px 15px; margin: 0 15px 10px 15px; font-size: 0.95em; font-weight: 500; cursor: pointer; text-align: left; transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease; flex-shrink: 0; }
         .start-chat-button:hover { background-color: var(--button-hover-bg); } .start-chat-button svg { fill: currentColor; width: 16px; height: 16px; }
         .start-chat-button:disabled { opacity: 0.6; cursor: not-allowed; }
         .chat-list { overflow-y: auto; padding: 0 15px; margin-bottom: 10px; flex-grow: 1; }
         .chat-list::-webkit-scrollbar { width: 6px; } .chat-list::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 3px;} .chat-list::-webkit-scrollbar-thumb:hover { background: var(--scrollbar-thumb-hover); }
         .chat-list-item { padding: 8px 30px 8px 10px; margin-bottom: 4px; border-radius: 6px; font-size: 0.9em; cursor: pointer; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-secondary); transition: background-color 0.2s ease, color 0.2s ease; position: relative; }
         .chat-list-item:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
         .chat-list-item.active { background-color: var(--active-item-bg); color: var(--text-primary); font-weight: 500; }
         .delete-chat-button { position: absolute; right: 6px; top: 50%; transform: translateY(-50%); width: 18px; height: 18px; background: none; border: none; color: var(--delete-button-color); cursor: pointer; font-size: 1.3em; line-height: 1; padding: 0; display: none; opacity: 0.7; transition: color 0.2s ease, opacity 0.2s ease; }
         .chat-list-item:hover .delete-chat-button { display: block; }
         .delete-chat-button:hover { color: var(--delete-button-hover-color); opacity: 1; }
         .sidebar-footer { border-top: 1px solid var(--border-color); padding: 10px 15px; transition: border-color 0.3s ease; flex-shrink: 0; }
         .sidebar-controls { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; flex-wrap: wrap; gap: 10px;} /* Added wrap and gap */
         .text-size-controls, .theme-toggle { display: flex; align-items: center; gap: 5px; }
         .text-size-controls span, .theme-toggle span { font-size: 0.85em; color: var(--text-secondary); }
         .text-size-buttons button, .theme-toggle button { background: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 4px; padding: 2px 8px; cursor: pointer; font-size: 1.1em; line-height: 1; transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease; }
         .text-size-buttons button:hover, .theme-toggle button:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
         .text-size-buttons button:disabled, .theme-toggle button:disabled { opacity: 0.6; cursor: not-allowed; }
         .model-selector-container { margin-top: 10px; width: 100%; }
         .model-selector-container label { font-size: 0.85em; color: var(--text-secondary); display: block; margin-bottom: 4px; }
         #model-selector { width: 100%; padding: 6px 8px; border: 1px solid var(--selector-border); background-color: var(--selector-bg); color: var(--selector-text); border-radius: 6px; font-size: 0.85em; -webkit-appearance: none; appearance: none; background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23${'var(--text-secondary)'.substring(4, 10)}%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.4-12.8z%22%2F%3E%3C%2Fsvg%3E'); background-repeat: no-repeat; background-position: right 8px top 50%; background-size: .65em auto; }
         #model-selector:disabled { opacity: 0.6; cursor: not-allowed; background-color: var(--button-bg); }
         #model-selector:focus { outline: none; border-color: var(--input-focus-border-color); }
         .account-info { display: flex; align-items: center; gap: 10px; font-size: 0.9em; margin-top: 10px; }
         .account-avatar { width: 30px; height: 30px; border-radius: 50%; background-color: #6c757d; color: white; display: flex; align-items: center; justify-content: center; font-weight: 600; }
         .account-details { overflow: hidden; }
         .account-email { font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-primary); }
         .account-plan { font-size: 0.85em; color: var(--text-secondary); }
         #auth-controls { margin-top: 15px; text-align: center; }
         #auth-controls button { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 8px 15px; cursor: pointer; font-size: 0.9em; transition: background-color 0.2s ease; }
         #auth-controls button:hover { background-color: var(--button-hover-bg); }
         #logout-btn { display: none; }

        /* Chat Area Elements */
        .greeting { font-size: 1.8em; font-weight: 600; margin-bottom: 40px; color: var(--text-primary); } .greeting .asterisk { color: var(--accent-color); font-size: 1.2em; margin-right: 5px; display: inline-block; vertical-align: middle; }
        .message-wrapper { /* New wrapper for message and actions */
            display: flex;
            align-items: flex-start; /* Align actions vertically with start of message */
            gap: 8px; /* Space between message and actions */
            margin-bottom: 15px;
            position: relative; /* Needed for absolute positioning of copy feedback */
        }
        .message-wrapper.user-wrapper { flex-direction: row-reverse; /* User messages on right */ }
        .message-wrapper.ai-wrapper { flex-direction: row; /* AI messages on left */ }
        .message {
            padding: 10px 15px; /* Adjusted padding slightly */
            border-radius: 18px;
            max-width: calc(100% - 50px); /* Make space for actions */
            word-wrap: break-word;
            line-height: 1.6;
            font-size: var(--message-font-size);
            transition: background-color 0.3s ease, color 0.3s ease;
            position: relative; /* Needed for potential internal absolute elements */
        }
        .user-message { background-color: var(--user-message-bg); color: var(--user-message-text); border-bottom-right-radius: 5px; }
        .ai-message { background-color: var(--ai-message-bg); color: var(--ai-message-text); border-bottom-left-radius: 5px; }
        .ai-message strong { font-weight: 600; } .ai-message em { font-style: italic; }
        .message-actions {
            display: flex;
            flex-direction: column; /* Stack actions vertically */
            gap: 5px;
            opacity: 0; /* Hidden by default */
            transition: opacity 0.2s ease-in-out;
            padding-top: 8px; /* Align roughly with first line of text */
            flex-shrink: 0; /* Prevent shrinking */
        }
        .message-wrapper:hover .message-actions { opacity: 1; /* Show on hover of the wrapper */ }
        .message-action-button {
             background: none; border: none; color: var(--message-action-color); cursor: pointer; font-size: 1.1em; padding: 2px; line-height: 1; transition: color 0.2s ease;
        }
        .message-action-button:hover { color: var(--message-action-hover-color); }
        .message-action-button.delete:hover { color: var(--delete-button-hover-color); } /* Use existing delete hover color */
        .copied-feedback {
            position: absolute;
            top: -25px; /* Adjusted position slightly */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            z-index: 10;
            pointer-events: none; /* Don't interfere with hover */
            white-space: nowrap; /* Prevent wrapping */
        }

        /* --- Code Block Styling (No changes needed) --- */
        .ai-message pre { background-color: var(--code-bg); color: var(--text-primary); padding: 12px 15px; border-radius: 6px; overflow-x: auto; font-size: 0.9em; transition: background-color 0.3s ease, color 0.3s ease; border: 1px solid var(--border-color); margin: 10px 0; position: relative; white-space: pre; word-wrap: normal; }
        .ai-message pre > code[class*="language-"] { font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; display: block; padding: 0; margin: 0; overflow: visible; background: none; color: inherit; font-size: 1em; line-height: inherit; text-shadow: none; white-space: inherit; word-wrap: inherit; }
        .ai-message :not(pre) > code { background-color: var(--code-bg); color: var(--text-primary); padding: 2px 5px; border-radius: 4px; font-size: 0.9em; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; transition: background-color 0.3s ease, color 0.3s ease; white-space: normal; word-wrap: break-word; }
        div.code-toolbar { position: relative; }
        div.code-toolbar > .toolbar { position: absolute; top: 0.5em; right: 0.5em; transition: opacity 0.3s ease-in-out; opacity: 0; z-index: 1; }
        div.code-toolbar:hover > .toolbar { opacity: 1; }
        div.code-toolbar > .toolbar .toolbar-item > button { background: var(--button-bg); color: var(--text-secondary); border: 1px solid var(--border-color); border-radius: 4px; padding: 3px 8px; font-size: 0.8em; cursor: pointer; transition: background-color 0.2s ease, color 0.2s ease; box-shadow: none; display: inline-flex; align-items: center; }
        div.code-toolbar > .toolbar .toolbar-item > button:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
        body.dark-theme div.code-toolbar > .toolbar .toolbar-item > button { background: var(--button-bg); color: var(--text-secondary); border-color: var(--border-color); }
        body.dark-theme div.code-toolbar > .toolbar .toolbar-item > button:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }

        .ai-message.thinking { /* Needs to be inside a wrapper */ background-color: transparent; color: var(--text-secondary); font-style: italic; padding: 12px 18px; }
        .error-message { background-color: var(--error-bg); color: var(--error-text); border: 1px solid var(--error-border); transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;}
        .info-message { text-align: center; color: var(--text-secondary); padding: 50px 20px; font-style: italic; }
        .message .multi-media-indicator { font-size: 0.9em; color: var(--text-secondary); margin-top: 8px; display: block; font-style: italic;}
        .message mjx-container { color: inherit !important; font-size: inherit !important; }
        /* Updated image styling for preview and modal */
        .message img.chat-image, .message img.uploaded-image {
            max-width: 250px; /* Smaller preview size */
            max-height: 150px;
            height: auto;
            width: auto; /* Let aspect ratio control width */
            border-radius: 8px;
            margin-top: 8px;
            cursor: pointer;
            display: block;
            border: 1px solid var(--border-color);
            transition: transform 0.2s ease;
        }
        .message img.chat-image:hover, .message img.uploaded-image:hover {
             transform: scale(1.03);
        }
        /* ***** TAMIL ***** Audio Player Styling in Chat */
        .message .chat-audio-player {
            margin-top: 10px;
        }
        .message .chat-audio-player audio {
            width: 100%; /* Take full width of container */
            max-width: 350px; /* Limit max width */
            height: 40px; /* Standard height */
            display: block;
            background-color: var(--audio-player-bg); /* Use theme color */
            border-radius: 5px;
            filter: invert(0); /* Default for light theme */
        }
        body.dark-theme .message .chat-audio-player audio {
             filter: invert(1) hue-rotate(180deg); /* Invert colors for dark theme */
        }
        /* Basic styling for controls (browser dependent) */
        .message .chat-audio-player audio::-webkit-media-controls-panel {
            background-color: var(--audio-player-bg);
            color: var(--audio-player-controls);
        }
        .message .chat-audio-player audio::-webkit-media-controls-play-button,
        .message .chat-audio-player audio::-webkit-media-controls-mute-button,
        .message .chat-audio-player audio::-webkit-media-controls-volume-slider {
             color: var(--audio-player-controls); /* Example */
        }
         .message .pdf-indicator, .message .audio-indicator {
             display: inline-flex; align-items: center; gap: 5px; font-size: 0.9em; color: var(--text-secondary); margin-top: 8px; padding: 3px 6px; background-color: var(--button-bg); border: 1px solid var(--border-color); border-radius: 4px;
        }

        /* YouTube Embed Styling (No change needed) */
        .message .youtube-embed-container { margin-top: 10px; position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; background: #000; border-radius: 8px; }
        .message iframe.chat-video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; }

        /* Input Area Elements */
        .suggestions { display: none; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; }
        .suggestion-chip { background-color: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 16px; padding: 8px 15px; font-size: 0.9em; cursor: pointer; transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease; }
        .suggestion-chip:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
        .input-box { display: flex; align-items: flex-end; background-color: var(--main-bg); border: 1px solid var(--input-border-color); border-radius: 12px; padding: 5px 5px 5px 15px; position: relative; transition: background-color 0.3s ease, border-color 0.3s ease; }
        .input-box:focus-within { border-color: var(--input-focus-border-color); }
        .input-buttons { display: flex; align-self: center; margin-right: 5px; gap: 3px; }
        /* ***** TAMIL ***** '+', 'üéôÔ∏è' button styling */
        #unified-upload-button, #record-audio-button { background: none; border: none; color: var(--text-secondary); cursor: pointer; font-size: 1.6em; /* Slightly larger */ padding: 0 4px; line-height: 1; transition: color 0.2s ease, opacity 0.2s ease; font-weight: bold; }
        #unified-upload-button:hover:not(:disabled), #record-audio-button:hover:not(.recording):not(:disabled) { color: var(--text-primary); }
        #unified-upload-button:disabled, #record-audio-button:disabled:not(.recording) { opacity: 0.5; cursor: not-allowed; color: var(--text-secondary); }
        #record-audio-button.recording { color: var(--record-button-bg); animation: pulse 1.5s infinite; }
        #record-audio-button.recording:disabled { color: var(--stop-button-bg); opacity: 0.7; animation: none; cursor: default; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }

        #user-input { flex-grow: 1; border: none; outline: none; padding: 10px 5px; font-size: 1rem; background-color: transparent; resize: none; min-height: 48px; max-height: 250px; line-height: 1.5; color: var(--text-primary); font-family: var(--font-family); }
        #user-input::placeholder { color: var(--text-placeholder); }
        #user-input:disabled { background-color: var(--button-bg); cursor: not-allowed; opacity: 0.7; }
        .mcq-mode-control { display: flex; align-items: center; margin-left: 10px; padding-bottom: 8px; flex-shrink: 0; }
        .mcq-mode-control input[type="checkbox"] { margin-right: 5px; accent-color: var(--accent-color); cursor: pointer;}
        .mcq-mode-control label { font-size: 0.85em; color: var(--text-secondary); cursor: pointer; user-select: none;}
        #send-button { background-color: var(--send-button-bg); color: var(--send-button-text); border: none; border-radius: 8px; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; cursor: pointer; margin-left: 10px; transition: background-color 0.2s ease; padding: 0; flex-shrink: 0; }
        #send-button:hover:not(:disabled) { background-color: var(--send-button-hover-bg); }
        #send-button:disabled { background-color: #cccccc; cursor: not-allowed; opacity: 0.6; }
        #send-button svg { width: 20px; height: 20px; fill: currentColor; }

        /* Media Previews (No changes needed) */
        #media-preview-container { margin-bottom: 10px; padding: 8px; background-color: var(--preview-bg); border: 1px solid var(--preview-border); border-radius: 8px; display: none; flex-direction: column; gap: 8px; }
        #image-previews-list { display: flex; gap: 8px; flex-wrap: wrap; max-height: 120px; overflow-y: auto; }
        .pdf-preview-item { background-color: var(--main-bg); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; padding: 4px 8px; font-size: 0.85em; display: flex; align-items: center; gap: 6px; max-width: 100%; box-sizing: border-box; }
        .pdf-preview-item span { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex-grow: 1; }
        .pdf-preview-item button { background: none; border: none; color: var(--remove-btn-color); cursor: pointer; font-size: 1.1em; line-height: 1; padding: 0 2px; margin-left: 4px; flex-shrink: 0; }
        .pdf-preview-item button:hover { color: var(--remove-btn-hover-color); }
        .image-preview-item { position: relative; }
        .image-preview-item img { max-height: 50px; max-width: 80px; height: auto; width: auto; border-radius: 4px; object-fit: cover; display: block; border: 1px solid var(--border-color); }
        .remove-image-item-button { position: absolute; top: -5px; right: -5px; background-color: rgba(0, 0, 0, 0.6); color: white; border: none; border-radius: 50%; width: 16px; height: 16px; font-size: 10px; line-height: 16px; text-align: center; cursor: pointer; opacity: 0.8; transition: opacity 0.2s ease; }
        .remove-image-item-button:hover { opacity: 1; }
        #preview-audio-container { display: flex; align-items: center; gap: 8px; display: none; }
        #preview-audio-container audio { height: 30px; max-width: 250px; }
        .media-preview-footer { display: flex; align-items: center; width: 100%; }
        #media-preview-info { font-size: 0.85em; color: var(--text-secondary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex-grow: 1; }
        #remove-media-button { background: none; border: none; color: var(--remove-btn-color); cursor: pointer; font-size: 1.4em; line-height: 1; padding: 0 5px; transition: color 0.2s ease; margin-left: auto; flex-shrink: 0; }
        #remove-media-button:hover { color: var(--remove-btn-hover-color); }

         #recording-status { font-size: 0.85em; color: var(--text-secondary); margin-bottom: 5px; display: none; text-align: center; padding: 3px 0; }
         #recording-status.visible { display: block; }

        .thinking::after { content: ' .'; animation: dots 1s steps(3, end) infinite; display: inline-block; }
        @keyframes dots { 0%, 20% { content: ' .'; } 40% { content: ' ..'; } 60%, 100% { content: ' ...'; } }
         .start-test-button { background-color: var(--accent-color); color: var(--send-button-text); border: none; border-radius: 6px; padding: 8px 15px; margin-top: 10px; cursor: pointer; font-weight: 500; display: inline-block; transition: background-color 0.2s ease; }
         .start-test-button:hover { background-color: var(--send-button-hover-bg); }

        /* Mock Test & Review View Styles (No changes needed) */
        .mock-test-view { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--main-bg); z-index: 100; flex-direction: column; padding: 20px; box-sizing: border-box; transition: background-color 0.3s ease; }
        .mock-test-view.active { display: flex; }
        .test-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); flex-shrink: 0; }
        .test-header h2 { margin: 0; font-size: 1.3em; color: var(--text-primary); }
        .test-info { display: flex; align-items: center; }
        .test-info span { margin-left: 15px; font-size: 0.95em; color: var(--text-secondary); }
        #test-language-toggle, #review-language-toggle { margin-left: 15px; padding: 3px 8px; font-size: 0.8em; cursor: pointer; background-color: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 4px; transition: background-color 0.2s ease, color 0.2s ease; }
        #test-language-toggle:hover, #review-language-toggle:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
        .test-content { flex-grow: 1; overflow-y: auto; padding: 10px 20px; }
        .test-question-container { margin-bottom: 25px; }
        .test-question-number { font-weight: bold; margin-bottom: 8px; color: var(--text-secondary); }
        .test-question { font-size: 1.1em; line-height: 1.5; margin-bottom: 15px; color: var(--text-primary); }
        .test-options label { display: block; margin-bottom: 12px; background-color: var(--button-bg); padding: 12px 15px; border-radius: 6px; border: 1px solid var(--border-color); cursor: pointer; transition: background-color 0.2s ease, border-color 0.2s ease; color: var(--text-primary); }
        .test-options label:hover { background-color: var(--button-hover-bg); }
        .test-options input[type="radio"] { margin-right: 10px; accent-color: var(--accent-color); cursor: pointer;}
        .test-navigation { display: flex; justify-content: space-between; padding-top: 15px; border-top: 1px solid var(--border-color); margin-top: auto; flex-shrink: 0; }
        .test-navigation button { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 10px 20px; cursor: pointer; font-size: 0.95em; transition: background-color 0.2s ease; }
        .test-navigation button:hover:not(:disabled) { background-color: var(--button-hover-bg); }
        .test-navigation button#submit-test-btn { background-color: var(--accent-color); color: var(--send-button-text); border-color: var(--accent-color); }
        .test-navigation button#submit-test-btn:hover:not(:disabled) { background-color: var(--send-button-hover-bg); }
        .test-navigation button:disabled { opacity: 0.5; cursor: not-allowed; }
        .review-view { padding: 20px; box-sizing: border-box; background-color: var(--main-bg); }
        .review-header { margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid var(--border-color); }
        .review-header h2 { margin: 0 0 10px 0; font-size: 1.3em; color: var(--text-primary); }
        .review-summary { display: inline; }
        .review-summary span { margin-right: 20px; font-size: 1em; color: var(--text-primary); }
        .review-summary .score-correct { color: #28a745; font-weight: bold;} .review-summary .score-incorrect { color: #dc3545; font-weight: bold;} .review-summary .score-skipped { color: #fd7e14; font-weight: bold;}
        .review-filters { margin-top: 10px; margin-bottom: 15px; }
        .review-filters button { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 5px 12px; margin-right: 8px; cursor: pointer; font-size: 0.9em; transition: background-color 0.2s ease, border-color 0.2s ease; }
        .review-filters button:hover { background-color: var(--button-hover-bg); }
        .review-filters button.active-filter { background-color: var(--accent-color); color: var(--send-button-text); border-color: var(--accent-color);}
        .review-content { flex-grow: 1; overflow-y: auto; padding-right: 10px; }
        .review-item { margin-bottom: 15px; padding: 15px; border: 1px solid var(--border-color); border-radius: 6px; background-color: var(--button-bg); transition: background-color 0.3s ease, border-color 0.3s ease; }
        .review-item.hidden-by-filter { display: none; }
        .review-item-qnum { font-weight: bold; margin-bottom: 8px; color: var(--text-secondary); }
        .review-item-question { margin-bottom: 10px; line-height: 1.5; color: var(--text-primary); }
        .review-item-details span { display: block; margin-bottom: 5px; font-size: 0.95em; color: var(--text-primary); }
        .review-item-details .correct-answer { color: #28a745; font-weight: bold; }
        .review-item-details .user-answer-correct { color: #28a745; } .review-item-details .user-answer-incorrect { color: #dc3545; text-decoration: line-through; } .review-item-details .user-answer-skipped { color: #fd7e14; font-style: italic; }
        .review-item-explanation { margin-top: 8px; font-size: 0.9em; color: var(--text-secondary); border-left: 3px solid var(--border-color); padding-left: 8px; line-height: 1.4; }
        .review-footer { text-align: center; padding-top: 20px; border-top: 1px solid var(--border-color); margin-top: auto; flex-shrink: 0; display: flex; justify-content: center; gap: 15px; }
        #exit-review-btn, #save-review-btn { background-color: var(--accent-color); color: var(--send-button-text); border: none; border-radius: 6px; padding: 10px 25px; cursor: pointer; font-size: 1em; transition: background-color 0.2s ease; display: none; }
        #exit-review-btn:hover, #save-review-btn:hover:not(:disabled) { background-color: var(--send-button-hover-bg); }
        #save-review-btn { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); }
        #save-review-btn:hover:not(:disabled) { background-color: var(--button-hover-bg); }
        #save-review-btn:disabled { opacity: 0.6; cursor: not-allowed; background-color: #cccccc; border-color: #aaaaaa; }

        /* Image Modal Styles (No changes needed) */
        .image-modal-overlay {
            display: none; /* Hidden by default */
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: var(--modal-bg);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        .image-modal-content {
            position: relative;
            max-width: 90vw;
            max-height: 90vh;
            background-color: var(--modal-content-bg);
            padding: 5px;
            border-radius: 5px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .image-modal-content img {
            display: block;
            max-width: 100%;
            max-height: calc(90vh - 40px); /* Account for padding/close button */
            object-fit: contain;
        }
        .image-modal-close {
            position: absolute;
            top: -10px; right: -10px;
            background-color: rgba(0,0,0,0.5);
            color: var(--modal-close-color);
            border: none;
            border-radius: 50%;
            width: 30px; height: 30px;
            font-size: 20px;
            font-weight: bold;
            line-height: 30px;
            text-align: center;
            cursor: pointer;
            transition: color 0.2s ease, background-color 0.2s ease;
        }
        .image-modal-close:hover {
            color: var(--modal-close-hover-color);
            background-color: rgba(0,0,0,0.7);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            :root { --sidebar-width: 200px; }
            .sidebar { padding: 10px 0; }
            .chat-area, .input-container { width: 95%; padding-left: 2.5%; padding-right: 2.5%; max-width: none; }
            .chat-area { padding-top: 15px; padding-bottom: 10px; }
            .input-container { padding-top: 10px; padding-bottom: 10px; }
            .message { max-width: calc(100% - 45px); font-size: calc(var(--message-font-size) * 0.95); } /* Adjust max-width for smaller screens */
            .message img.chat-image, .message img.uploaded-image { max-width: 200px; max-height: 120px; } /* Smaller previews on mobile */
            /* ***** TAMIL ***** Mobile Audio Player */
            .message .chat-audio-player audio { max-width: 280px; height: 35px; }
            #unified-upload-button, #record-audio-button { font-size: 1.4em; padding: 0 3px; }
            #media-preview-container { padding: 6px; gap: 6px; }
            #image-previews-list { gap: 5px; max-height: 100px; }
            .pdf-preview-item { padding: 3px 6px; font-size: 0.8em; }
            .image-preview-item img { max-height: 40px; }
            .remove-image-item-button, .pdf-preview-item button { width: 14px; height: 14px; font-size: 9px; line-height: 14px; }
            #preview-audio-container audio { max-width: 180px; height: 28px; }
            #media-preview-info { font-size: 0.8em; }
            #remove-media-button { font-size: 1.3em; }
            .input-box { padding: 5px 5px 5px 10px; }
             #user-input { min-height: 40px; font-size: 0.95rem; }
             #send-button { width: 32px; height: 32px; }
             .mcq-mode-control label { font-size: 0.8em; }
             .message-actions { padding-top: 6px; gap: 4px; }
             .message-action-button { font-size: 1em; }
            /* Responsive Sidebar Footer */
            .sidebar-footer { padding: 10px; }
            .sidebar-controls { flex-direction: column; align-items: flex-start; gap: 12px; }
            .model-selector-container { margin-top: 5px; }
            .account-info { margin-top: 15px; }
            #auth-controls { margin-top: 12px; }

            /* Mock Test & Review (No changes needed) */
            .mock-test-view, .review-view { padding: 10px; }
            .test-header, .review-header { margin-bottom: 15px; padding-bottom: 8px; flex-direction: column; align-items: flex-start; }
            .test-header h2, .review-header h2 { font-size: 1.1em; margin-bottom: 5px;}
            .test-info, .review-summary { margin-bottom: 5px; }
            .test-info span, .review-summary span { margin-left: 0; margin-right: 10px; font-size: 0.9em; display: inline-block; margin-bottom: 3px;}
            #test-language-toggle, #review-language-toggle { margin-left: 0; margin-top: 5px; font-size: 0.75em;}
            .test-content, .review-content { padding: 5px; }
            .test-question, .review-item-question { font-size: 1em; }
            .test-options label, .review-item { padding: 10px; font-size: 0.95em;}
            .review-filters { margin-top: 5px; }
            .review-filters button { padding: 4px 8px; font-size: 0.85em; margin-right: 5px;}
            .test-navigation, .review-footer { padding-top: 10px; }
            .test-navigation button, #exit-review-btn, #save-review-btn { padding: 8px 15px; font-size: 0.9em; }
        }
    </style>
</head>
<body>

    <div class="app-container" id="app-container">
        <!-- Sidebar (No Changes Needed)-->
        <div class="sidebar">
             <div class="sidebar-header">Gemini Chat</div>
             <div id="all-tests-section"> <div class="sidebar-section-title">All Tests</div> <input type="search" id="test-search-input" placeholder="Search tests..." disabled> <div class="all-tests-list" id="all-tests-list"> <div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">Login to see saved tests.</div> </div> </div>
             <div class="sidebar-section"> <button class="start-chat-button" id="start-chat" disabled> <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"></path></svg> Start new chat </button> <div class="sidebar-section-title">Chats</div> <div class="chat-list" id="chat-list"> <div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">Please log in to see chats.</div> </div> </div>
             <div class="sidebar-footer"> <div class="sidebar-controls"> <div class="text-size-controls"> <span>Text Size</span> <div class="text-size-buttons"> <button id="decrease-text-size" title="Decrease text size" disabled>-</button> <button id="increase-text-size" title="Increase text size" disabled>+</button> </div> </div> <div class="theme-toggle"> <button id="theme-toggle-button" title="Toggle Theme" disabled>‚òÄÔ∏è</button> </div> </div> <div class="model-selector-container"> <label for="model-selector">AI Model</label> <select id="model-selector" disabled> </select> </div> <div id="auth-controls"> <button id="login-google-btn">Login with Google</button> <button id="logout-btn" style="display: none;">Logout</button> </div> <div class="account-info"> <div class="account-avatar" id="account-avatar">?</div> <div class="account-details"> <div class="account-email" id="account-email">Not logged in</div> <div class="account-plan" id="account-plan"></div> </div> </div> </div>
        </div>

        <!-- Main container -->
        <div class="main-container">
            <div class="main-content active" id="main-content-chat">
                 <div class="chat-area" id="chat-area">
                     <!-- Messages will be added here by JS -->
                 </div>
                 <div class="input-container" id="input-container">
                     <div class="suggestions" id="suggestions"> <button class="suggestion-chip" data-prompt="Summarize this document">Summarize this document</button> <button class="suggestion-chip" data-prompt="Extract key points from this PDF">Extract key points from this PDF</button> <button class="suggestion-chip" data-prompt="Describe this image">Describe this image</button> <button class="suggestion-chip" data-prompt="Summarize this video">Summarize this video</button> </div>
                    <div id="media-preview-container"> <div id="image-previews-list"> </div> <div id="preview-audio-container"> <audio id="preview-audio" controls></audio> </div> <div class="media-preview-footer"> <span id="media-preview-info"></span> <button id="remove-media-button" title="Remove all media">&times;</button> </div> </div>
                    <div id="recording-status">Recording... <span>0s</span></div>
                    <div class="input-box">
                         <!-- ***** TAMIL ***** Hidden file inputs (‡Æá‡Æ§‡Øà JS handle ‡Æ™‡Æ£‡Øç‡Æ£‡ØÅ‡ÆÆ‡Øç) -->
                         <input type="file" id="image-upload-input" accept="image/png, image/jpeg, image/webp, image/heic, image/heif" style="display: none;" multiple>
                         <input type="file" id="pdf-upload-input" accept="application/pdf" style="display: none;" multiple>
                         <input type="file" id="audio-upload-input" accept="audio/wav, audio/mp3, audio/mpeg, audio/aac, audio/ogg, audio/flac, audio/aiff" style="display: none;">
                         <!-- ***** TAMIL ***** Combined input for the '+' button -->
                         <input type="file" id="unified-upload-input" accept="image/png, image/jpeg, image/webp, image/heic, image/heif, application/pdf, audio/wav, audio/mp3, audio/mpeg, audio/aac, audio/ogg, audio/flac, audio/aiff" style="display: none;" multiple>

                         <div class="input-buttons">
                             <!-- ***** TAMIL ***** '+' button (image, pdf, audio upload) -->
                             <button id="unified-upload-button" title="Upload File (Image, PDF, Audio)" disabled>+</button>
                             <!-- ***** TAMIL ***** Record button -->
                             <button id="record-audio-button" title="Record audio" disabled>üéôÔ∏è</button>
                         </div>
                         <textarea id="user-input" placeholder="Enter prompt, attach media, or paste URL" rows="1" disabled></textarea>
                         <div class="mcq-mode-control"> <input type="checkbox" id="mcq-mode-checkbox" title="Generate MCQs based on prompt/media" disabled> <label for="mcq-mode-checkbox">MCQs?</label> </div>
                         <button id="send-button" title="Send message" disabled> <svg viewBox="0 0 24 24"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"></path></svg>
                        </button>
                    </div>
                 </div>
            </div>
            <!-- Review View (No Changes Needed) -->
            <div class="review-view" id="review-view"> <div class="review-header"> <h2 id="review-title">Test Review</h2> <div> <div class="review-summary" id="review-summary"></div> </div> <div class="review-filters" id="review-filters" style="display: none;"> <button data-filter="all" class="active-filter">All</button> <button data-filter="incorrect">Incorrect</button> <button data-filter="skipped">Skipped</button> </div> </div> <div class="review-content" id="review-content"></div> <div class="review-footer"> <button id="save-review-btn">Save Review</button> <button id="exit-review-btn">Back</button> </div> </div>
        </div>
    </div>

    <!-- Mock Test View (No Changes Needed) -->
    <div class="mock-test-view" id="mock-test-view"> <div class="test-header"> <h2 id="test-title">Mock Test</h2> <div class="test-info"> <span id="question-counter">Q: 1 / N</span> <span id="test-timer">Time: 00:00</span> </div> </div> <div class="test-content"> <div class="test-question-container"> <div class="test-question-number" id="test-question-number"></div> <div class="test-question" id="test-question"></div> <div class="test-options" id="test-options"></div> </div> </div> <div class="test-navigation"> <button id="prev-question-btn" disabled>Previous</button> <button id="next-question-btn">Next</button> <button id="submit-test-btn">Submit Test</button> </div> </div>

    <!-- Image Modal Structure (No changes needed) -->
    <div class="image-modal-overlay" id="image-modal">
        <div class="image-modal-content">
            <button class="image-modal-close" id="image-modal-close" title="Close image">&times;</button>
            <img src="" alt="Enlarged image" id="modal-image-content">
        </div>
    </div>


    <script>
        // --- Firebase Config ---
        // ***** TAMIL ***** User ‡Æï‡Øä‡Æü‡ØÅ‡Æ§‡Øç‡Æ§ Firebase config-‡Æê ‡Æá‡Æô‡Øç‡Æï use ‡Æ™‡Æ£‡Øç‡Æ±‡Øã‡ÆÆ‡Øç.
        const firebaseConfig = {
          apiKey: "AIzaSyDgw604fe5jnNu4kTOv1cQ-3n7PL8gcN58",
          authDomain: "krish-c5db8.firebaseapp.com",
          projectId: "krish-c5db8",
          storageBucket: "krish-c5db8.appspot.com",
          messagingSenderId: "217175257890",
          appId: "1:217175257890:web:209f0f290eabab6b1fab7b",
          measurementId: "G-97SHYGL2J4"
        };

        // --- Initialize Firebase ---
        firebase.initializeApp(firebaseConfig);
        const fbAuth = firebase.auth();
        const db = firebase.firestore();

        // --- DOM Elements ---
        // ***** TAMIL *****
        // HTML elements-‡Æê ‡Æá‡Æô‡Øç‡Æï variables-‡Æ≤ store ‡Æ™‡Æ£‡Øç‡Æ±‡Øã‡ÆÆ‡Øç. ‡Æ™‡ØÜ‡Æ∞‡ØÅ‡ÆÆ‡Øç‡Æ™‡Ææ‡Æ≤‡ØÅ‡ÆÆ‡Øç ‡Æ™‡Æ¥‡Øà‡ÆØ code ‡Æ§‡Ææ‡Æ©‡Øç.
        const appContainer = document.getElementById('app-container');
        const chatArea = document.getElementById('chat-area');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const suggestionsContainer = document.getElementById('suggestions');
        const startChatButton = document.getElementById('start-chat');
        const chatListContainer = document.getElementById('chat-list');
        const allTestsSection = document.getElementById('all-tests-section');
        const testSearchInput = document.getElementById('test-search-input');
        const allTestsListContainer = document.getElementById('all-tests-list');
        const accountEmail = document.getElementById('account-email');
        const accountAvatar = document.getElementById('account-avatar');
        const accountPlan = document.getElementById('account-plan');
        const decreaseTextBtn = document.getElementById('decrease-text-size');
        const increaseTextBtn = document.getElementById('increase-text-size');
        const themeToggleButton = document.getElementById('theme-toggle-button');
        const modelSelector = document.getElementById('model-selector');
        const mainContainer = document.querySelector('.main-container');
        const chatView = document.getElementById('main-content-chat');
        const testView = document.getElementById('mock-test-view');
        const reviewView = document.getElementById('review-view');
        const inputContainer = document.getElementById('input-container');
        const mcqModeCheckbox = document.getElementById('mcq-mode-checkbox');
        const loginBtn = document.getElementById('login-google-btn');
        const logoutBtn = document.getElementById('logout-btn');
        // Test & Review Elements
        const testTitle = document.getElementById('test-title');
        const questionCounter = document.getElementById('question-counter');
        const testTimer = document.getElementById('test-timer');
        const testQuestionNumber = document.getElementById('test-question-number');
        const testQuestion = document.getElementById('test-question');
        const testOptionsContainer = document.getElementById('test-options');
        const prevQuestionBtn = document.getElementById('prev-question-btn');
        const nextQuestionBtn = document.getElementById('next-question-btn');
        const submitTestBtn = document.getElementById('submit-test-btn');
        const reviewTitle = document.getElementById('review-title');
        const reviewSummary = document.getElementById('review-summary');
        const reviewContent = document.getElementById('review-content');
        const exitReviewBtn = document.getElementById('exit-review-btn');
        const reviewFilters = document.getElementById('review-filters');
        const saveReviewBtn = document.getElementById('save-review-btn');
        // Media Elements (New/Updated)
        const unifiedUploadButton = document.getElementById('unified-upload-button');
        const unifiedUploadInput = document.getElementById('unified-upload-input');
        const imageUploadInput = document.getElementById('image-upload-input');
        const pdfUploadInput = document.getElementById('pdf-upload-input');
        const audioUploadInput = document.getElementById('audio-upload-input');
        const recordAudioButton = document.getElementById('record-audio-button');
        const mediaPreviewContainer = document.getElementById('media-preview-container');
        const imagePreviewsList = document.getElementById('image-previews-list');
        const previewAudioContainer = document.getElementById('preview-audio-container');
        const previewAudio = document.getElementById('preview-audio');
        const mediaPreviewInfo = document.getElementById('media-preview-info');
        const removeMediaButton = document.getElementById('remove-media-button');
        const recordingStatus = document.getElementById('recording-status');
        const recordingTimerSpan = recordingStatus.querySelector('span');
        const imageModal = document.getElementById('image-modal');
        const modalImageContent = document.getElementById('modal-image-content');
        const imageModalClose = document.getElementById('image-modal-close');


        // --- Config & Constants ---
        // ***** TAMIL *****
        // Config ‡ÆÆ‡Ææ‡Æ±‡Æø‡Æ≤‡Æø‡Æï‡Æ≥‡Øç ‡Æ™‡ØÜ‡Æ∞‡ØÅ‡ÆÆ‡Øç‡Æ™‡Ææ‡Æ≤‡ØÅ‡ÆÆ‡Øç ‡ÆÖ‡Æ™‡Øç‡Æ™‡Æü‡Æø‡ÆØ‡Øá ‡Æá‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ.
        const AVAILABLE_MODELS = [
            { id: "gemini-1.5-flash-latest", name: "Gemini 1.5 Flash Latest", supportsCaching: false, maxTokens: 8192 },
            { id: "gemini-1.5-pro-latest", name: "Gemini 1.5 Pro Latest", supportsCaching: false, maxTokens: 8192 },
            { id: "gemini-2.0-flash", name: "Gemini 2.0 Flash (New)", supportsCaching: false, maxTokens: 8192 },
            { id: "gemini-2.5-pro-exp-03-25", name: "Gemini 2.5 Pro Exp (New)", supportsCaching: false, maxTokens: 65536 }, // Specific large token limit
            { id: "gemini-1.5-flash-001", name: "Gemini 1.5 Flash 001 (Cache OK)", supportsCaching: true, maxTokens: 8192 }, // Specific version for caching
            { id: "gemini-1.5-pro-001", name: "Gemini 1.5 Pro 001 (Cache OK)", supportsCaching: true, maxTokens: 8192 }, // Specific version for caching
        ];
        const DEFAULT_MODEL_ID = AVAILABLE_MODELS[0].id;
        const DEFAULT_MAX_TOKENS = 8192;
        const STORAGE_KEY_API_KEY = 'geminiApiKey_insecureDemo';
        const STORAGE_KEY_MODEL_ID = 'geminiSelectedModelId';
        const NEW_CHAT_TITLE = "(New Chat)";
        const TEXT_SIZE_STEP = 0.1;
        const MIN_TEXT_SIZE_MULTIPLIER = 0.7;
        const MAX_TEXT_SIZE_MULTIPLIER = 1.5;
        const LIGHT_THEME_ICON = '‚òÄÔ∏è';
        const DARK_THEME_ICON = 'üåô';
        const DELETE_ICON = '√ó';
        const EDIT_TEST_ICON = '‚úèÔ∏è';
        const DELETE_TEST_ICON = 'üóëÔ∏è';
        const COPY_ICON_SVG = '<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512"><path fill="currentColor" d="M384 336H192c-8.8 0-16-7.2-16-16V64c0-8.8 7.2-16 16-16l140.1 0L400 115.9V320c0 8.8-7.2 16-16 16zM192 384H384c35.3 0 64-28.7 64-64V115.9c0-12.7-5.1-24.9-14.1-33.9L366.1 14.1c-9-9-21.2-14.1-33.9-14.1H192c-35.3 0-64 28.7-64 64V320c0 35.3 28.7 64 64 64zM64 128c-35.3 0-64 28.7-64 64V448c0 35.3 28.7 64 64 64H256c35.3 0 64-28.7 64-64V416H272v32c0 8.8-7.2 16-16 16H64c-8.8 0-16-7.2-16-16V192c0-8.8 7.2-16 16-16H96V128H64z"/></svg>'; // Copy Icon
        const DELETE_MESSAGE_ICON_SVG = '<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512"><path fill="currentColor" d="M135.2 17.7L128 32H32C14.3 32 0 46.3 0 64S14.3 96 32 96H416c17.7 0 32-14.3 32-32s-14.3-32-32-32H320l-7.2-14.3C307.4 6.8 296.3 0 284.2 0H163.8c-12.1 0-23.2 6.8-28.6 17.7zM416 128H32L53.2 467c1.6 25.3 22.6 45 47.9 45H346.9c25.3 0 46.3-19.7 47.9-45L416 128z"/></svg>'; // Trash Icon

        const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:watch\?v=|embed\/|v\/)|youtu\.be\/)([a-zA-Z0-9_-]{11})(?:\S+)?/i;
        const imageUrlRegex = /(?<!src=["'])(?<!href=["'])(https?:\/\/[^\s()<>]+?\.(?:jpg|jpeg|png|gif|webp|bmp|heic|heif))/gi;
        const MAX_IMAGE_SIZE_MB = 4;
        const MAX_TOTAL_IMAGE_SIZE_MB = 16;
        const MAX_IMAGE_COUNT = 10;
        const MAX_PDF_SIZE_MB = 50; // Note: File API limit is 2GB, but this is for easy display/preview handling
        const MAX_PDF_COUNT = 5;
        const MAX_AUDIO_SIZE_MB = 15;
        const SUPPORTED_AUDIO_MIMES = ['audio/wav', 'audio/mp3', 'audio/mpeg', 'audio/aiff', 'audio/aac', 'audio/ogg', 'audio/flac'];
        const SUPPORTED_IMAGE_MIMES = ['image/png', 'image/jpeg', 'image/webp', 'image/heic', 'image/heif'];
        const RECORDING_TIME_LIMIT_SECONDS = 300; // 5 minutes
        const FILE_API_POLLING_INTERVAL_MS = 5000; // 5 seconds
        const FILE_API_PROCESSING_TIMEOUT_MS = 180000; // 3 minutes
        const CACHE_TTL_SECONDS = 3600; // 1 hour

        // --- State Variables ---
        let API_KEY = '';
        let genAI = null;
        let HarmCategory = null;
        let HarmBlockThreshold = null;
        let currentUser = null;
        let activeChatId = null;
        let currentChatHistory = []; // Stores { role, parts, firestoreId }
        let selectedModelId = DEFAULT_MODEL_ID;
        let currentTextSizeMultiplier = 1.0;
        let currentTheme = 'light';
        let isTestMode = false;
        let isReviewMode = false;
        let currentTestMCQs = [];
        let currentQuestionIndex = 0;
        let userAnswers = [];
        let testStartTime = null;
        let testTimerInterval = null;
        let reviewResultsCache = null;
        let cameFromAllTestsList = false;
        let activeChatListener = null;
        let chatListListener = null;
        let testListListener = null;
        let isDeletingChat = false;
        let isDeletingMessage = false; // Flag for message deletion
        let allSavedTestsData = [];
        let selectedMediaItems = []; // { type: 'image'/'audio'/'pdf', file, base64?, mimeType?, name, id }
        let nextMediaId = 0;
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;
        let recordingStartTime = null;
        let recordingTimerInterval = null;
        let recorderStream = null;
        let isAISdkReady = false;
        let currentMediaCacheName = null;
        let cachedMediaUris = [];


        // --- Initialization ---
        initializeApp();

        // --- Event Listeners ---
        sendButton.addEventListener('click', handleSendMessage);
        userInput.addEventListener('input', () => { autoGrowTextarea(); updateButtonStates(); });
        userInput.addEventListener('paste', () => { setTimeout(updateButtonStates, 50); });
        userInput.addEventListener('keydown', handleInputKeydown);
        suggestionsContainer.addEventListener('click', handleSuggestionClick);
        startChatButton.addEventListener('click', createNewChat);
        chatListContainer.addEventListener('click', handleChatListClick);
        allTestsListContainer.addEventListener('click', handleAllTestsListClick);
        testSearchInput.addEventListener('input', filterTestsInSidebar);
        decreaseTextBtn.addEventListener('click', () => adjustTextSize(-TEXT_SIZE_STEP));
        increaseTextBtn.addEventListener('click', () => adjustTextSize(TEXT_SIZE_STEP));
        themeToggleButton.addEventListener('click', toggleTheme);
        modelSelector.addEventListener('change', handleModelSelectionChange);
        prevQuestionBtn.addEventListener('click', () => handleTestNavigation('prev'));
        nextQuestionBtn.addEventListener('click', () => handleTestNavigation('next'));
        submitTestBtn.addEventListener('click', submitTest);
        exitReviewBtn.addEventListener('click', exitReview);
        chatArea.addEventListener('click', handleChatAreaClick);
        reviewFilters.addEventListener('click', handleReviewFilterClick);
        saveReviewBtn.addEventListener('click', saveTestReviewToCloud);
        loginBtn.addEventListener('click', signInWithGoogle);
        logoutBtn.addEventListener('click', signOut);
        unifiedUploadButton.addEventListener('click', () => {
            if (!unifiedUploadButton.disabled) unifiedUploadInput.click();
        });
        unifiedUploadInput.addEventListener('change', handleUnifiedFileSelect);
        recordAudioButton.addEventListener('click', () => { if (!recordAudioButton.disabled || isRecording) { toggleRecording(); } });
        removeMediaButton.addEventListener('click', removeAllSelectedMedia);
        imageModalClose.addEventListener('click', hideImageModal);
        imageModal.addEventListener('click', (e) => { if (e.target === imageModal) { hideImageModal(); } }); // Close on overlay click

        // SDK Loaded Listener
        window.addEventListener('google-ai-sdk-loaded', () => {
            console.log("Caught 'google-ai-sdk-loaded' event.");
            isAISdkReady = true;
            HarmCategory = window.HarmCategory;
            HarmBlockThreshold = window.HarmBlockThreshold;
            if (API_KEY && !genAI) {
                 initializeGenAIInstance();
                 if(currentUser) { console.log("Re-evaluating button states after SDK load."); updateButtonStates(); }
            }
        });


        // --- Initialization Functions ---
        // (initializeApp, populateModelSelector, loadGeminiApiKey, initializeGenAIInstance remain the same)
        async function initializeApp() { console.log("App Initializing (v10.5)..."); setLoadingState(true, "Initializing..."); chatArea.innerHTML = ''; populateModelSelector(); loadUserSettingsFromLocalStorage(); await loadGeminiApiKey(); fbAuth.onAuthStateChanged(handleAuthStateChange); switchView('chat'); userInput.focus(); console.log("App Initialization Complete."); }
        function populateModelSelector() { modelSelector.innerHTML = ''; AVAILABLE_MODELS.forEach(model => { const option = document.createElement('option'); option.value = model.id; option.textContent = model.name; if (model.id === selectedModelId) { option.selected = true; } modelSelector.appendChild(option); }); console.log("Model selector populated."); }
        async function loadGeminiApiKey() { console.log("Attempting to load Gemini API Key..."); API_KEY = localStorage.getItem(STORAGE_KEY_API_KEY); if(!API_KEY){ console.warn("!!! SECURITY WARNING !!! Using insecure API key storage. Use Cloud Functions in production."); if(API_KEY){ localStorage.setItem(STORAGE_KEY_API_KEY, API_KEY); console.log("Using potentially hardcoded insecure API Key."); } else { console.error("Gemini API Key is required. Please configure it in the script or localStorage."); displayMessage("Error: Gemini API Key is not configured. AI features are disabled.", 'ai', ['error-message']); API_KEY = ''; genAI = null; isAISdkReady = false; updateButtonStates(); return false; } } else { console.log("Loaded insecure API Key from localStorage."); } if (API_KEY && isAISdkReady && !genAI) { return initializeGenAIInstance(); } else if (API_KEY && !isAISdkReady) { console.log("API Key loaded, but AI SDK not ready yet. Waiting for 'google-ai-sdk-loaded' event."); return true; } else { return !!API_KEY; } }
        function initializeGenAIInstance() { if (!API_KEY || !isAISdkReady) { console.warn("Skipping genAI initialization. Conditions not met:", { API_KEY: !!API_KEY, isAISdkReady }); return false; } if (!HarmCategory || !HarmBlockThreshold) { console.error("HarmCategory or HarmBlockThreshold enums not loaded from SDK. Cannot initialize safety settings correctly."); displayError("Error: Failed to load required safety components from AI SDK."); genAI = null; isAISdkReady = false; updateButtonStates(); return false; } if (genAI) { genAI = null; console.log("Re-initializing genAI instance."); } console.log("Initializing GoogleGenerativeAI SDK instance..."); try { if (window.GoogleGenerativeAI) { genAI = new window.GoogleGenerativeAI(API_KEY); console.log("genAI object created:", genAI != null); const supportsFiles = !!genAI?.files?.upload; const supportsCaching = !!genAI?.caching?.createCachedContent; console.log(`SDK Capabilities Check: File API: ${supportsFiles}, Caching API: ${supportsCaching}`); if (supportsFiles) { console.log("SUCCESS: GoogleGenerativeAI SDK instance created successfully with File API support (`genAI.files` FOUND)."); } else { console.warn("WARNING: GoogleGenerativeAI SDK instance created, but `genAI.files` is MISSING. File uploads might fail or use older methods."); } if (!supportsCaching) { console.warn("WARNING: GoogleGenerativeAI SDK instance created, but `genAI.caching` is MISSING. Context Caching feature will be disabled."); } return true; } else { console.error("ERROR: GoogleGenerativeAI SDK constructor not found on window object."); displayError("Error: AI SDK loaded but failed to initialize."); genAI = null; isAISdkReady = false; return false; } } catch (e) { console.error("CRITICAL ERROR initializing GoogleGenerativeAI:", e); displayError(`Critical Error initializing AI SDK: ${e.message}. Check API Key & Console.`); API_KEY = ''; localStorage.removeItem(STORAGE_KEY_API_KEY); genAI = null; isAISdkReady = false; return false; } finally { console.log("Updating button states finally after genAI initialization attempt."); updateButtonStates(); } }


        // --- Authentication Functions ---
        // (signInWithGoogle, signOut remain the same)
        async function signInWithGoogle() { const provider = new firebase.auth.GoogleAuthProvider(); try { setLoadingState(true, "Logging in..."); await fbAuth.signInWithPopup(provider); } catch (error) { console.error("Google Sign-In Error:", error); displayError(`Login failed: ${error.message || 'Unknown error'}`); setLoadingState(false); } }
        async function signOut() { try { setLoadingState(true, "Logging out..."); await fbAuth.signOut(); } catch (error) { console.error("Sign Out Error:", error); displayError(`Logout failed: ${error.message || 'Unknown error'}`); setLoadingState(false); } }

        // (handleAuthStateChange, renderGreetingOrLoginPrompt remain the same)
        function handleAuthStateChange(user) { console.log("Auth state changed. User:", user ? user.uid : 'None'); setLoadingState(true, user ? "Loading user data..." : "Logging out..."); if (activeChatListener) { activeChatListener(); activeChatListener = null; console.log("Cleared active chat listener."); } if (chatListListener) { chatListListener(); chatListListener = null; console.log("Cleared chat list listener.");} if (testListListener) { testListListener(); testListListener = null; console.log("Cleared test list listener."); } stopRecording(true); chatArea.innerHTML = ''; chatListContainer.innerHTML = `<div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">${user ? 'Loading chats...' : 'Please log in...'}</div>`; allTestsListContainer.innerHTML = `<div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">${user ? 'Loading tests...' : 'Login to see tests.'}</div>`; allTestsSection.classList.remove('visible'); testSearchInput.value = ''; activeChatId = null; currentChatHistory = []; isDeletingChat = false; allSavedTestsData = []; currentMediaCacheName = null; cachedMediaUris = []; removeAllSelectedMedia(); if (user) { currentUser = user; console.log("User logged in:", currentUser.uid); loginBtn.style.display = 'none'; logoutBtn.style.display = 'inline-block'; accountEmail.textContent = currentUser.email || currentUser.displayName || `User`; accountAvatar.textContent = (currentUser.displayName || currentUser.email || 'U')[0].toUpperCase(); accountPlan.textContent = "Firebase User"; inputContainer.style.display = 'block'; suggestionsContainer.style.display = 'flex'; allTestsSection.classList.add('visible'); loadUserSettings(currentUser.uid); loadAndListenForChats(currentUser.uid); loadAndListenForTests(currentUser.uid); renderGreetingOrLoginPrompt(); } else { currentUser = null; console.log("User logged out"); loginBtn.style.display = 'inline-block'; logoutBtn.style.display = 'none'; accountEmail.textContent = "Not logged in"; accountAvatar.textContent = '?'; accountPlan.textContent = ""; inputContainer.style.display = 'none'; suggestionsContainer.style.display = 'none'; allTestsSection.classList.remove('visible'); renderGreetingOrLoginPrompt(); currentTheme = 'light'; applyTheme(); currentTextSizeMultiplier = 1.0; applyTextSize(); selectedModelId = DEFAULT_MODEL_ID; applyModelSelection(); } console.log("Updating button states after auth change."); updateButtonStates(); setLoadingState(false); }
        function renderGreetingOrLoginPrompt() { chatArea.innerHTML = ''; const greetingElement = document.createElement('div'); greetingElement.classList.add('greeting'); if (currentUser) { greetingElement.innerHTML = `<span class="asterisk">*</span>Good day, ${currentUser.displayName || 'User'}!`; chatArea.appendChild(greetingElement); if (!activeChatId) { displayMessage("Select a chat from the list or start a new one.", 'ai'); } else if (!API_KEY || !genAI) { displayMessage("API Key missing or AI SDK failed to initialize. AI features are disabled. Please check API Key or reload.", 'ai', ['error-message']); } else if (genAI && !genAI.files) { displayMessage("File API is unavailable with the current AI configuration. PDF/Large File uploads are disabled.", 'ai', ['error-message']); } } else { greetingElement.innerHTML = `<span class="asterisk">*</span>Welcome!`; chatArea.appendChild(greetingElement); displayMessage("Please log in with Google to use the chat and save your history.", 'ai'); } scrollToBottom(true); }


        // --- Settings (Theme/Text Size/Model) ---
        // (loadUserSettingsFromLocalStorage, loadUserSettings, saveUserSettings, applyTheme, toggleTheme, applyTextSize, adjustTextSize, applyModelSelection, handleModelSelectionChange remain the same)
        function loadUserSettingsFromLocalStorage() { const savedTheme = localStorage.getItem('chatTheme'); const savedTextSize = localStorage.getItem('chatTextSizeMultiplier'); const savedModelId = localStorage.getItem(STORAGE_KEY_MODEL_ID); currentTheme = savedTheme || 'light'; currentTextSizeMultiplier = savedTextSize ? parseFloat(savedTextSize) : 1.0; selectedModelId = AVAILABLE_MODELS.some(m => m.id === savedModelId) ? savedModelId : DEFAULT_MODEL_ID; applyTheme(); applyTextSize(); applyModelSelection(); }
        async function loadUserSettings(userId) { const userDocRef = db.collection('users').doc(userId); try { const docSnap = await userDocRef.get(); if (docSnap.exists) { const settings = docSnap.data(); currentTheme = settings.theme || currentTheme; currentTextSizeMultiplier = settings.textSizeMultiplier || currentTextSizeMultiplier; const firestoreModelId = settings.selectedModelId; selectedModelId = AVAILABLE_MODELS.some(m => m.id === firestoreModelId) ? firestoreModelId : selectedModelId; console.log("Loaded user settings from Firestore:", settings); } else { console.log("No user settings found in Firestore, using local/defaults."); } } catch (error) { console.error("Error loading user settings from Firestore:", error); } finally { applyTheme(); applyTextSize(); applyModelSelection(); } }
        async function saveUserSettings() { localStorage.setItem('chatTheme', currentTheme); localStorage.setItem('chatTextSizeMultiplier', currentTextSizeMultiplier.toString()); localStorage.setItem(STORAGE_KEY_MODEL_ID, selectedModelId); if (!currentUser) return; const userDocRef = db.collection('users').doc(currentUser.uid); const settings = { theme: currentTheme, textSizeMultiplier: currentTextSizeMultiplier, selectedModelId: selectedModelId }; try { await userDocRef.set(settings, { merge: true }); console.log("User settings saved to Firestore:", settings); } catch (error) { console.error("Error saving user settings to Firestore:", error); } }
        function applyTheme() { if(currentTheme==='dark'){ document.body.classList.add('dark-theme'); themeToggleButton.textContent=LIGHT_THEME_ICON; themeToggleButton.title="Switch to Light Theme"; } else { document.body.classList.remove('dark-theme'); themeToggleButton.textContent=DARK_THEME_ICON; themeToggleButton.title="Switch to Dark Theme"; } }
        function toggleTheme() { currentTheme = (currentTheme === 'light') ? 'dark' : 'light'; applyTheme(); saveUserSettings(); }
        function applyTextSize() { const newSize = `calc(var(--message-font-size-base) * ${currentTextSizeMultiplier})`; document.documentElement.style.setProperty('--message-font-size', newSize); updateButtonStates(); }
        function adjustTextSize(change) { let newMultiplier = Math.max(MIN_TEXT_SIZE_MULTIPLIER, Math.min(MAX_TEXT_SIZE_MULTIPLIER, currentTextSizeMultiplier + change)); newMultiplier = Math.round(newMultiplier * 10) / 10; if (newMultiplier !== currentTextSizeMultiplier) { currentTextSizeMultiplier = newMultiplier; applyTextSize(); saveUserSettings(); } }
        function applyModelSelection() { if (modelSelector) { modelSelector.value = selectedModelId; console.log(`Applied model selection: ${selectedModelId}`); } const modelInfo = AVAILABLE_MODELS.find(m => m.id === selectedModelId); if (currentMediaCacheName && (!modelInfo || !modelInfo.supportsCaching)) { console.warn(`Model ${selectedModelId} does not support caching or is unknown. Clearing active cache state.`); currentMediaCacheName = null; cachedMediaUris = []; } }
        function handleModelSelectionChange(event) { const newModelId = event.target.value; if (newModelId !== selectedModelId) { console.log(`Model selection changed to: ${newModelId}`); selectedModelId = newModelId; applyModelSelection(); saveUserSettings(); const modelInfo = AVAILABLE_MODELS.find(m => m.id === selectedModelId); if (modelInfo && !modelInfo.supportsCaching) { console.warn(`Selected model ${selectedModelId} does not support or is not configured for context caching.`); } else if (modelInfo && modelInfo.supportsCaching) { console.log(`Selected model ${selectedModelId} supports context caching.`); } } }


        // --- Chat Storage & Loading (Firestore) ---
        // (loadAndListenForChats, renderSidebarChatList, highlightActiveChatInSidebar remain the same)
        function loadAndListenForChats(userId) { if (chatListListener) { chatListListener(); chatListListener = null; } const chatsRef = db.collection('chats').where('userId', '==', userId).orderBy('lastUpdated', 'desc'); console.log(`Listening for chats for user ${userId}`); chatListListener = chatsRef.onSnapshot(snapshot => { if (isDeletingChat) { console.log("Skipping chat list update during delete."); return; } const chats = []; snapshot.forEach(doc => { chats.push({ id: doc.id, ...doc.data() }); }); console.log("Received chat list snapshot:", chats.length, "chats"); renderSidebarChatList(chats); let chatToLoad = activeChatId; if (!chatToLoad || !chats.some(c => c.id === chatToLoad)) { chatToLoad = chats.length > 0 ? chats[0].id : null; if (chatToLoad) console.log("Active chat gone or none selected, switching to newest:", chatToLoad); else console.log("No active chat and no existing chats found."); } if (chatToLoad && chatToLoad !== activeChatId) { switchChat(chatToLoad); } else if (chatToLoad && chatToLoad === activeChatId) { highlightActiveChatInSidebar(); console.log("Chat list updated, keeping same active chat. Updating button states."); updateButtonStates(); setLoadingState(false); } else { activeChatId = null; currentChatHistory = []; if (activeChatListener) { activeChatListener(); activeChatListener = null; } renderGreetingOrLoginPrompt(); console.log("No chat selected. Updating button states."); updateButtonStates(); setLoadingState(false); currentMediaCacheName = null; cachedMediaUris = []; } }, error => { console.error("Error listening for chats:", error); displayError("Could not load chat list."); chatListContainer.innerHTML = '<div style="padding:10px;color:var(--error-text);">Error loading chats.</div>'; setLoadingState(false); }); }
        function renderSidebarChatList(chats) { chatListContainer.innerHTML = ''; if (!currentUser) { chatListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);">Please log in.</div>'; return; } if (chats.length === 0) { chatListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);">No chats yet. Start one!</div>'; } else { chats.forEach(chatData => { const itemElement = document.createElement('div'); itemElement.classList.add('chat-list-item'); let title = chatData.title; if (typeof title !== 'string' || !title.trim()) { title = '(Untitled Chat)'; } title = title.trim(); itemElement.textContent = title; itemElement.dataset.id = chatData.id; itemElement.title = title; const deleteBtn = document.createElement('button'); deleteBtn.classList.add('delete-chat-button'); deleteBtn.innerHTML = DELETE_ICON; deleteBtn.title = "Delete chat"; deleteBtn.dataset.id = chatData.id; itemElement.appendChild(deleteBtn); chatListContainer.appendChild(itemElement); }); } highlightActiveChatInSidebar(); }
        function highlightActiveChatInSidebar() { const items = chatListContainer.querySelectorAll('.chat-list-item'); items.forEach(item => { item.classList.toggle('active', item.dataset.id === activeChatId); }); }


        // --- Media Handling Functions ---

        // (handleUnifiedFileSelect, handleImageFileSelect, handlePdfFileSelect, handleAudioFileSelect remain the same)
        function handleUnifiedFileSelect(event) {
            const files = event.target.files;
            if (!files || files.length === 0) { unifiedUploadInput.value = ''; return; }
            console.log(`handleUnifiedFileSelect: ${files.length} file(s) selected.`);
            const firstFile = files[0]; const fileType = firstFile.type;
            if (selectedMediaItems.length > 0) { const existingType = selectedMediaItems[0].type; if ( (SUPPORTED_IMAGE_MIMES.includes(fileType) && existingType !== 'image') || (fileType === 'application/pdf' && existingType !== 'pdf') || (SUPPORTED_AUDIO_MIMES.includes(fileType) && existingType !== 'audio') ) { alert(`Cannot add ${fileType.split('/')[0]} when ${existingType}(s) are already selected. Please remove existing media first.`); unifiedUploadInput.value = ''; return; } }
            if (SUPPORTED_IMAGE_MIMES.includes(fileType)) { console.log("Detected image files."); handleImageFileSelect(event); } else if (fileType === 'application/pdf') { console.log("Detected PDF files."); handlePdfFileSelect(event); } else if (SUPPORTED_AUDIO_MIMES.includes(fileType)) { console.log("Detected audio file."); if (files.length > 1) { alert("Please select only one audio file at a time."); unifiedUploadInput.value = ''; return; } handleAudioFileSelect(event); } else { alert(`Unsupported file type: ${fileType}. Please select an image, PDF, or audio file.`); unifiedUploadInput.value = ''; }
        }
        function handleImageFileSelect(event) {
            console.log("Processing image selection..."); if (selectedMediaItems.length > 0 && !selectedMediaItems.every(item => item.type === 'image')) { alert("Cannot select images when PDF or audio is already selected."); unifiedUploadInput.value = ''; return; } if (youtubeRegex.test(userInput.value.trim())) { alert("Cannot upload images when a YouTube URL is present."); unifiedUploadInput.value = ''; return; } const files = event.target.files; if (!files) { unifiedUploadInput.value = ''; return; } let currentImageCount = selectedMediaItems.filter(item => item.type === 'image').length; let addedCount = 0; let totalSizeMB = selectedMediaItems.reduce((sum, item) => sum + (item.file?.size || 0), 0) / 1024 / 1024; const allowedTypes = SUPPORTED_IMAGE_MIMES; for (const file of files) { if (!allowedTypes.includes(file.type)) continue; if (currentImageCount >= MAX_IMAGE_COUNT) { alert(`Maximum ${MAX_IMAGE_COUNT} images allowed.`); break; } const fileSizeMB = file.size / 1024 / 1024; if (fileSizeMB > MAX_IMAGE_SIZE_MB) { alert(`Image "${file.name}" (${fileSizeMB.toFixed(1)}MB) exceeds ${MAX_IMAGE_SIZE_MB}MB limit.`); continue; } if (totalSizeMB + fileSizeMB > MAX_TOTAL_IMAGE_SIZE_MB) { alert(`Adding "${file.name}" would exceed total image size limit of ${MAX_TOTAL_IMAGE_SIZE_MB}MB.`); continue; } const mediaId = nextMediaId++; selectedMediaItems.push({ id: mediaId, type: 'image', file: file, base64: null, mimeType: file.type, name: file.name }); currentImageCount++; totalSizeMB += fileSizeMB; addedCount++; } if (addedCount > 0) { console.log(`Added ${addedCount} images. Total images: ${currentImageCount}`); displayMediaPreview(); } unifiedUploadInput.value = '';
        }
        function handlePdfFileSelect(event) {
            console.log("Processing PDF selection..."); if (selectedMediaItems.length > 0 && !selectedMediaItems.every(item => item.type === 'pdf')) { alert("Cannot select PDF(s) when images or audio are already selected."); unifiedUploadInput.value = ''; return; } if (youtubeRegex.test(userInput.value.trim())) { alert("Cannot upload PDFs when a YouTube URL is present."); unifiedUploadInput.value = ''; return; } if (!genAI || !genAI.files) { alert("PDF upload is currently disabled (File API unavailable)."); unifiedUploadInput.value = ''; return; } const files = event.target.files; if (!files) { unifiedUploadInput.value = ''; return; } let currentPdfCount = selectedMediaItems.filter(item => item.type === 'pdf').length; let addedCount = 0; for (const file of files) { if (file.type !== 'application/pdf') continue; if (currentPdfCount >= MAX_PDF_COUNT) { alert(`Maximum ${MAX_PDF_COUNT} PDF files allowed.`); break; } const fileSizeMB = file.size / 1024 / 1024; if (fileSizeMB > MAX_PDF_SIZE_MB) { console.warn(`Large PDF selected: ${fileSizeMB.toFixed(1)}MB (Preview limit: ${MAX_PDF_SIZE_MB}MB)`); } const mediaId = nextMediaId++; selectedMediaItems.push({ id: mediaId, type: 'pdf', file: file, name: file.name, mimeType: file.type }); currentPdfCount++; addedCount++; } if (addedCount > 0) { console.log(`Added ${addedCount} PDFs. Total PDFs: ${currentPdfCount}`); displayMediaPreview(); } unifiedUploadInput.value = '';
        }
        function handleAudioFileSelect(event) {
             console.log("Processing audio selection..."); if (selectedMediaItems.length > 0 && !selectedMediaItems.every(item => item.type === 'audio')) { alert("Cannot select audio when images or PDF(s) are already selected."); unifiedUploadInput.value = ''; return; } if (youtubeRegex.test(userInput.value.trim())) { alert("Cannot upload audio when a YouTube URL is present."); unifiedUploadInput.value = ''; return; } const file = event.target.files[0]; if (!file) { unifiedUploadInput.value = ''; return; } removeAllSelectedMedia(); if (!SUPPORTED_AUDIO_MIMES.includes(file.type)) { alert(`Unsupported audio file type: ${file.type}.`); unifiedUploadInput.value = ''; return; } const fileSizeMB = file.size / 1024 / 1024; if (fileSizeMB > MAX_AUDIO_SIZE_MB) { alert(`Audio file too large (${fileSizeMB.toFixed(1)}MB). Max ${MAX_AUDIO_SIZE_MB}MB.`); unifiedUploadInput.value = ''; return; } const reader = new FileReader(); setLoadingState(true, "Reading audio..."); reader.onload = (e) => { const mediaId = nextMediaId++; selectedMediaItems = [{ id: mediaId, type: 'audio', file: file, base64: e.target.result, mimeType: file.type, name: file.name }]; console.log("Audio selected and read:", file.name); displayMediaPreview(); setLoadingState(false); } reader.onerror = (error) => { console.error("Error reading audio file:", error); alert("Error reading audio file."); removeAllSelectedMedia(); setLoadingState(false); }; unifiedUploadInput.value = ''; reader.readAsDataURL(file);
        }

        // (displayMediaPreview, renderImagePreviewItem, renderPdfPreviewItem remain the same)
        function displayMediaPreview() { console.log("displayMediaPreview. Items:", selectedMediaItems.length); imagePreviewsList.innerHTML = ''; previewAudioContainer.style.display = 'none'; previewAudio.removeAttribute('src'); mediaPreviewInfo.textContent = ''; imagePreviewsList.style.display = 'none'; imagePreviewsList.style.flexDirection = ''; imagePreviewsList.style.alignItems = ''; if (selectedMediaItems.length === 0) { mediaPreviewContainer.style.display = 'none'; updateButtonStates(); return; } const audioItem = selectedMediaItems.find(item => item.type === 'audio'); const imageItems = selectedMediaItems.filter(item => item.type === 'image'); const pdfItems = selectedMediaItems.filter(item => item.type === 'pdf'); let infoText = ""; if (audioItem) { imagePreviewsList.style.display = 'none'; try { previewAudio.src = audioItem.base64; previewAudio.load(); previewAudioContainer.style.display = 'flex'; infoText = `1 audio file: ${audioItem.name || 'Audio'}`; } catch (e) { console.error("Error setting audio src:", e); infoText = 'Error loading audio preview'; } } else if (imageItems.length > 0) { previewAudioContainer.style.display = 'none'; imagePreviewsList.style.display = 'flex'; imagePreviewsList.style.flexDirection = 'row'; imagePreviewsList.style.alignItems = 'flex-start'; imageItems.forEach(item => { if (!item.base64) { const reader = new FileReader(); reader.onload = (e) => { item.base64 = e.target.result; renderImagePreviewItem(item); }; reader.onerror = () => { item.base64 = '#error'; renderImagePreviewItem(item); }; reader.readAsDataURL(item.file); } else { renderImagePreviewItem(item); } }); infoText = `${imageItems.length} image(s) selected`; } else if (pdfItems.length > 0) { previewAudioContainer.style.display = 'none'; imagePreviewsList.style.display = 'flex'; imagePreviewsList.style.flexDirection = 'column'; imagePreviewsList.style.alignItems = 'stretch'; pdfItems.forEach(item => renderPdfPreviewItem(item)); infoText = `${pdfItems.length} PDF file(s) selected`; } mediaPreviewInfo.textContent = infoText; mediaPreviewContainer.style.display = 'flex'; updateButtonStates(); }
        function renderImagePreviewItem(item) { try { const existingItem = imagePreviewsList.querySelector(`.image-preview-item[data-media-id="${item.id}"]`); if (existingItem) return; const itemContainer = document.createElement('div'); itemContainer.classList.add('image-preview-item'); itemContainer.dataset.mediaId = item.id; const img = document.createElement('img'); img.src = item.base64 === '#error' ? '' : (item.base64 || ''); img.alt = item.base64 === '#error' ? 'Preview error' : (item.name || 'Image'); img.title = item.name || 'Image'; img.onerror = () => { img.alt = "Preview load error"; }; const removeBtn = document.createElement('button'); removeBtn.classList.add('remove-image-item-button'); removeBtn.innerHTML = '&times;'; removeBtn.title = `Remove ${item.name || 'image'}`; removeBtn.onclick = (e) => { e.stopPropagation(); removeSelectedMediaItem(item.id); }; itemContainer.appendChild(img); itemContainer.appendChild(removeBtn); imagePreviewsList.appendChild(itemContainer); } catch (e) { console.error("Error creating image preview element:", e); } }
        function renderPdfPreviewItem(item) { try { const existingItem = imagePreviewsList.querySelector(`.pdf-preview-item[data-media-id="${item.id}"]`); if (existingItem) return; const itemContainer = document.createElement('div'); itemContainer.classList.add('pdf-preview-item'); itemContainer.dataset.mediaId = item.id; const icon = document.createElement('span'); icon.textContent = 'üìÑ'; icon.style.marginRight = '4px'; const nameSpan = document.createElement('span'); nameSpan.textContent = item.name || 'PDF File'; nameSpan.title = item.name || 'PDF File'; const removeBtn = document.createElement('button'); removeBtn.innerHTML = '&times;'; removeBtn.title = `Remove ${item.name || 'PDF'}`; removeBtn.onclick = (e) => { e.stopPropagation(); removeSelectedMediaItem(item.id); }; itemContainer.appendChild(icon); itemContainer.appendChild(nameSpan); itemContainer.appendChild(removeBtn); imagePreviewsList.appendChild(itemContainer); } catch (e) { console.error("Error creating PDF preview element:", e); } }

        // (removeSelectedMediaItem, removeAllSelectedMedia remain the same)
        function removeSelectedMediaItem(mediaId) { console.log(`Removing media item ID: ${mediaId}`); selectedMediaItems = selectedMediaItems.filter(item => item.id !== mediaId); displayMediaPreview(); if (currentMediaCacheName && cachedMediaUris.length > 0 && !selectedMediaItems.some(item => item.type === 'pdf')) { console.log("Removed last cached media type (PDF). Clearing cache state."); currentMediaCacheName = null; cachedMediaUris = []; } }
        function removeAllSelectedMedia() { console.log("removeAllSelectedMedia called."); stopRecording(true); selectedMediaItems = []; nextMediaId = 0; imagePreviewsList.innerHTML = ''; previewAudio.removeAttribute('src'); previewAudioContainer.style.display = 'none'; mediaPreviewContainer.style.display = 'none'; mediaPreviewInfo.textContent = ''; imagePreviewsList.style.flexDirection = ''; imagePreviewsList.style.alignItems = ''; unifiedUploadInput.value = ''; if (currentMediaCacheName) { console.log("All media removed. Clearing active media cache state."); currentMediaCacheName = null; cachedMediaUris = []; } console.log("All selected media removed, inputs reset, cache state cleared."); updateButtonStates(); }


        // --- Audio Recording Functions ---
        // (toggleRecording, startRecording, stopRecording, resetRecordingUI remain the same)
        async function toggleRecording() { if (isRecording) { stopRecording(); } else { if (selectedMediaItems.some(item => item.type === 'image' || item.type === 'pdf')) { alert("Cannot record audio when images or PDFs are selected. Remove them first."); return; } if (youtubeRegex.test(userInput.value.trim())) { alert("Cannot record audio when a YouTube URL is present in the input. Please remove the URL first."); return; } if (sendButton.disabled && !isRecording) { const appReady = currentUser && API_KEY && genAI && activeChatId; if (!appReady || userInput.placeholder.includes("Generating") || userInput.placeholder.includes("Sending") || userInput.placeholder.includes("Uploading") || userInput.placeholder.includes("Recording")) { alert("Please wait for the current action to complete or ensure you are logged in with a valid API key and active chat."); return; } } await startRecording(); } }
        async function startRecording() { console.log("Attempting to start recording..."); if (selectedMediaItems.length > 0) { alert("Cannot record audio when other media is selected. Please remove it first."); return; } if (youtubeRegex.test(userInput.value.trim())) { alert("Cannot record audio when a YouTube URL is present in the input. Please remove the URL first."); return; } if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) { alert("Audio recording is not supported by your browser."); console.error("getUserMedia not supported."); return; } try { console.log("Requesting microphone access..."); if (recorderStream) { recorderStream.getTracks().forEach(track => track.stop()); recorderStream = null; console.warn("Stopped lingering recorder stream."); } const stream = await navigator.mediaDevices.getUserMedia({ audio: true }); recorderStream = stream; console.log("Microphone access granted."); recordAudioButton.disabled = true; let options = {}; const preferredMimeTypes = ['audio/ogg;codecs=opus', 'audio/webm;codecs=opus', 'audio/aac', 'audio/mp4']; for (const mimeType of preferredMimeTypes) { if (MediaRecorder.isTypeSupported(mimeType)) { options.mimeType = mimeType; break; } } if (!options.mimeType) console.warn("No preferred MIME type supported, using browser default."); mediaRecorder = new MediaRecorder(stream, options); const actualMimeType = mediaRecorder.mimeType; console.log("Initializing MediaRecorder. Options:", options, "Actual MIME type:", actualMimeType); audioChunks = []; mediaRecorder.ondataavailable = (event) => { if (event.data.size > 0) { audioChunks.push(event.data); } }; mediaRecorder.onstop = () => { console.log("MediaRecorder stopped. Chunks:", audioChunks.length); if (recorderStream) { recorderStream.getTracks().forEach(track => track.stop()); console.log("Microphone stream tracks stopped."); recorderStream = null; } isRecording = false; recordingStatus.classList.remove('visible'); recordAudioButton.classList.remove('recording'); recordAudioButton.textContent = 'üéôÔ∏è'; recordAudioButton.title = 'Record audio'; if (recordingTimerInterval) { clearInterval(recordingTimerInterval); recordingTimerInterval = null; } if (audioChunks.length === 0) { console.warn("No audio data recorded."); setLoadingState(false); updateButtonStates(); return; } const audioBlob = new Blob(audioChunks, { type: actualMimeType }); audioChunks = []; const fileSizeMB = audioBlob.size / 1024 / 1024; console.log(`Recording complete. Blob size: ${fileSizeMB.toFixed(3)} MB, Type: ${actualMimeType}`); if (audioBlob.size === 0) { console.warn("Created Blob has size 0."); alert("Recording failed: No audio data captured."); setLoadingState(false); updateButtonStates(); return; } if (fileSizeMB > MAX_AUDIO_SIZE_MB) { alert(`Recorded audio too large (${fileSizeMB.toFixed(1)}MB). Max ${MAX_AUDIO_SIZE_MB}MB.`); setLoadingState(false); updateButtonStates(); return; } const reader = new FileReader(); setLoadingState(true, "Processing audio..."); reader.onloadend = () => { if (reader.result && typeof reader.result === 'string' && reader.result.startsWith('data:')) { let finalMimeType = actualMimeType.split(';')[0]; const mediaId = nextMediaId++; selectedMediaItems = [{ id: mediaId, type: 'audio', file: new File([audioBlob], `recording.audio`, { type: finalMimeType }), base64: reader.result, mimeType: finalMimeType, name: `recording-${new Date().toISOString().substring(0, 19).replace(/[:T]/g, '-')}.${finalMimeType.split('/')[1] || 'audio'}` }]; displayMediaPreview(); } else { console.error("FileReader result invalid."); alert("Error processing recorded audio (Invalid data)."); } setLoadingState(false); }; reader.onerror = (error) => { console.error("Error converting recorded audio blob:", error); alert("Error processing recorded audio."); setLoadingState(false); updateButtonStates(); }; reader.readAsDataURL(audioBlob); }; mediaRecorder.onerror = (event) => { console.error("MediaRecorder error:", event.error || event); alert(`Recording error: ${event.error?.name || 'Unknown'}`); stopRecording(true); }; mediaRecorder.start(); isRecording = true; recordingStartTime = Date.now(); recordAudioButton.classList.add('recording'); recordAudioButton.textContent = 'üõë'; recordAudioButton.title = 'Stop recording'; recordingStatus.classList.add('visible'); recordingTimerSpan.textContent = '0s'; setLoadingState(true, "Recording..."); recordingTimerInterval = setInterval(() => { const elapsedSeconds = Math.floor((Date.now() - recordingStartTime) / 1000); recordingTimerSpan.textContent = `${elapsedSeconds}s`; if (elapsedSeconds >= RECORDING_TIME_LIMIT_SECONDS) { console.log("Recording time limit."); stopRecording(); alert(`Stopped after ${RECORDING_TIME_LIMIT_SECONDS} seconds.`); } }, 1000); console.log("Recording started..."); recordAudioButton.disabled = false; } catch (error) { console.error("Error starting recording:", error); if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') { alert("Microphone access denied. Please allow access in browser settings."); } else if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') { alert("No microphone found."); } else { alert(`Could not start recording: ${error.name}`); } stopRecording(true); } }
        function stopRecording(force = false) { console.log("stopRecording called. isRecording:", isRecording, "force:", force); if (mediaRecorder && (isRecording || force)) { try { if (mediaRecorder.state === "recording" || mediaRecorder.state === "paused") { mediaRecorder.stop(); console.log("MediaRecorder.stop() called."); if (force && !isRecording) { resetRecordingUI(); setLoadingState(false); } } else if (force) { console.log("Recorder not active, forcing cleanup."); resetRecordingUI(); setLoadingState(false); } } catch (error) { console.error("Error calling mediaRecorder.stop():", error); resetRecordingUI(); setLoadingState(false); } } else if (force) { console.log("No recorder or not recording, forced stop."); resetRecordingUI(); setLoadingState(false); } else { console.log("Not recording or recorder not available."); if (!isRecording) { setLoadingState(false); updateButtonStates(); } } }
        function resetRecordingUI() { console.log("Resetting recording UI/state."); isRecording = false; if (recordAudioButton) { recordAudioButton.classList.remove('recording'); recordAudioButton.textContent = 'üéôÔ∏è'; recordAudioButton.title = 'Record audio'; } if (recordingStatus) recordingStatus.classList.remove('visible'); if (recordingTimerInterval) { clearInterval(recordingTimerInterval); recordingTimerInterval = null; } if (recorderStream) { recorderStream.getTracks().forEach(track => track.stop()); console.log("Mic stream stopped (reset UI)."); recorderStream = null; } mediaRecorder = null; audioChunks = []; console.log("Updating button states after resetting recording UI."); updateButtonStates(); }


        // --- Chat Creation, Deletion, Switching ---
        // (createNewChat, handleChatListClick, confirmAndDeleteChat, deleteChatFromFirestore, switchChat remain the same)
        async function createNewChat() { if (!currentUser || startChatButton.disabled) { displayError("Please log in or wait for current action."); return; } setLoadingState(true, "Creating chat..."); removeAllSelectedMedia(); const newChatRef = db.collection('chats').doc(); const timestamp = firebase.firestore.FieldValue.serverTimestamp(); try { await newChatRef.set({ userId: currentUser.uid, title: NEW_CHAT_TITLE, createdAt: timestamp, lastUpdated: timestamp }); console.log("New chat created:", newChatRef.id); } catch (error) { console.error("Error creating new chat:", error); displayError("Failed to create chat."); setLoadingState(false); } }
        function handleChatListClick(event) { const target = event.target; const deleteButton = target.closest('.delete-chat-button'); if (deleteButton) { event.stopPropagation(); const chatId = deleteButton.dataset.id; const chatListItem = deleteButton.closest('.chat-list-item'); const chatTitle = chatListItem?.textContent?.replace(deleteButton.textContent, '').trim() || 'this chat'; if (chatId) { confirmAndDeleteChat(chatId, chatTitle); } return; } const item = target.closest('.chat-list-item'); const clickedId = item?.dataset?.id; if (item && clickedId && clickedId !== activeChatId) { switchChat(clickedId); } }
        function confirmAndDeleteChat(chatId, chatTitle) { if (!currentUser || !chatId) return; if (confirm(`Delete chat "${chatTitle}" permanently?`)) { deleteChatFromFirestore(chatId); } else { console.log(`Deletion cancelled for chat: ${chatId}`); } }
        async function deleteChatFromFirestore(chatId) { if (!currentUser || !chatId) return; isDeletingChat = true; console.log(`[Delete Start] Chat: ${chatId}`); setLoadingState(true, "Deleting chat..."); const chatDocRef = db.collection('chats').doc(chatId); const messagesRef = chatDocRef.collection('messages'); try { const messagesSnapshot = await messagesRef.get(); if (!messagesSnapshot.empty) { const batch = db.batch(); messagesSnapshot.docs.forEach(doc => { batch.delete(doc.ref); }); await batch.commit(); console.log(`[Delete] Deleted ${messagesSnapshot.size} messages.`); } await chatDocRef.delete(); console.log(`[Delete Success] Chat doc: ${chatId}`); const cacheNameToDelete = `cache-${chatId}-media`; try { if (genAI?.caching?.deleteCachedContent) { await genAI.caching.deleteCachedContent({ name: cacheNameToDelete }); console.log(`[Delete Cache Attempt] Tried to delete cache: ${cacheNameToDelete}`); } else { console.log("[Delete Cache Attempt] Skipped cache deletion, SDK/API unavailable."); } } catch(cacheError) { if (cacheError.message?.includes("not found")) { console.log(`[Delete Cache Attempt] Cache ${cacheNameToDelete} not found, likely already deleted or never created.`); } else { console.warn(`[Delete Cache Attempt] Error deleting cache ${cacheNameToDelete}:`, cacheError); } } if (activeChatId === chatId) { activeChatId = null; currentChatHistory = []; if (activeChatListener) { activeChatListener(); activeChatListener = null; } chatArea.innerHTML = ''; renderGreetingOrLoginPrompt(); removeAllSelectedMedia(); } } catch (error) { console.error(`[Delete Error] Chat ${chatId}:`, error); displayError(`Failed to delete chat.`); } finally { isDeletingChat = false; setLoadingState(false); console.log(`[Delete End] Chat: ${chatId}`); } }
        function switchChat(chatId) { if (!currentUser || !chatId || chatId === activeChatId) { console.log(`Switch chat skipped: currentUser=${!!currentUser}, chatId=${chatId}, activeChatId=${activeChatId}`); return; } console.log("Switching to chat:", chatId); setLoadingState(true, "Loading chat..."); activeChatId = chatId; currentMediaCacheName = null; cachedMediaUris = []; removeAllSelectedMedia(); highlightActiveChatInSidebar(); userInput.value = ''; autoGrowTextarea(); mcqModeCheckbox.checked = false; loadAndListenForActiveChat(chatId); }


        // --- Message Loading (Firestore) ---
        // (loadAndListenForActiveChat remains the same)
        function loadAndListenForActiveChat(chatId) {
            if (!currentUser || !chatId) { chatArea.innerHTML = ''; if (activeChatListener) { activeChatListener(); activeChatListener = null; } renderGreetingOrLoginPrompt(); updateButtonStates(); setLoadingState(false); return; }
            if (activeChatListener) { activeChatListener(); activeChatListener = null; }

            const messagesRef = db.collection('chats').doc(chatId).collection('messages').orderBy('timestamp', 'asc');
            chatArea.innerHTML = '';
            const loadingMsg = displayMessage("Loading chat history...", 'ai', ['thinking']);
            scrollToBottom(true);
            console.log(`Listening for messages in chat ${chatId}`);

            activeChatListener = messagesRef.onSnapshot(snapshot => {
                console.log(`Received messages snapshot for chat ${chatId}:`, snapshot.size, "messages. isDeletingMessage:", isDeletingMessage);
                if (isDeletingMessage) { console.log("Skipping message snapshot processing due to active deletion."); return; }
                removeMessageElement(loadingMsg); chatArea.innerHTML = ''; currentChatHistory = [];
                if (snapshot.empty && activeChatId === chatId) { const chatListItem = chatListContainer.querySelector(`.chat-list-item[data-id="${chatId}"]`); const chatTitle = chatListItem?.textContent?.replace(DELETE_ICON, '').trim() || ''; if (chatTitle && chatTitle !== NEW_CHAT_TITLE) { displayMessage("Chat is empty. Send a message to start!", 'ai'); } else { renderGreetingOrLoginPrompt(); } } else { snapshot.forEach(doc => { const msgData = doc.data(); const role = msgData.role === 'user' ? 'user' : 'model'; const parts = []; const firestoreId = doc.id; let historyText = msgData.text || ""; if (msgData.youtubeVideoId) { const ytUrlInText = `https://www.youtube.com/watch?v=${msgData.youtubeVideoId}`; if (!historyText.includes(ytUrlInText)) { historyText = (historyText ? historyText + "\n" : "") + ytUrlInText; } } if (historyText) { parts.push({ text: historyText }); } if (parts.length > 0) { currentChatHistory.push({ role: role, parts: parts, firestoreId: firestoreId }); } displayMessage(msgData.text || '', msgData.role, [], null, msgData, firestoreId); }); }
                scrollToBottom(true); console.log(`Finished loading/displaying ${currentChatHistory.length} history items for chat ${chatId}. Updating button states.`); updateButtonStates(); setLoadingState(false); if (!isTestMode && !isReviewMode && activeChatId) { setTimeout(() => userInput.focus(), 100); }
            }, error => {
                console.error(`Error listening messages chat ${chatId}:`, error); displayError("Could not load messages for this chat."); removeMessageElement(loadingMsg); chatArea.innerHTML = ''; currentChatHistory = []; console.error("Error loading messages. Updating button states."); updateButtonStates(); setLoadingState(false);
            });
        }


        // --- File Upload Helper (Gemini File API) ---
        // ***** TAMIL ***** PDF ‡Æ™‡Øã‡Æ©‡Øç‡Æ± ‡Æ™‡ØÜ‡Æ∞‡Æø‡ÆØ files-‡Æê File API ‡ÆÆ‡ØÇ‡Æ≤‡ÆÆ‡Øç upload ‡Æö‡ØÜ‡ÆØ‡Øç‡ÆØ‡ØÅ‡ÆÆ‡Øç function. Upload/Processing status ‡Æá‡Æô‡Øç‡Æï ‡Æï‡Ææ‡Æü‡Øç‡Æü‡ØÅ‡Æµ‡Øã‡ÆÆ‡Øç.
        async function uploadAndProcessFile(file, index, totalFiles) {
             if (!genAI?.files?.upload || !genAI?.files?.get || !genAI?.files?.delete) { console.error("[File API] Error: genAI.files service or required methods (upload, get, delete) are not available."); throw new Error("AI SDK File Service not initialized or missing methods."); }
             const progressMsg = `Uploading file ${index + 1}/${totalFiles}: ${file.name}...`; // ***** TAMIL ***** Upload ‡ÆÜ‡Æ∞‡ÆÆ‡Øç‡Æ™‡Æø‡Æï‡Øç‡Æï‡ØÅ‡ÆÆ‡Øç‡Æ™‡Øã‡Æ§‡ØÅ status message
             console.log(`[File API] ${progressMsg}`);
             setLoadingState(true, progressMsg);
             let uploadResult = null;
             try {
                 uploadResult = await genAI.files.upload({ file: file, mimeType: file.type, displayName: file.name, });
                 console.log(`[File API] Upload initiated for ${file.name}. API File Name: ${uploadResult?.file?.name}, State: ${uploadResult?.file?.state}`);
                 if (!uploadResult?.file?.name) { throw new Error(`File upload for ${file.name} did not return a valid file name.`); }
                 const apiFileName = uploadResult.file.name;
                 let fileResponse = await genAI.files.get({ name: apiFileName });
                 const startTime = Date.now();
                 while (fileResponse?.file?.state === 'PROCESSING') {
                     if (Date.now() - startTime > FILE_API_PROCESSING_TIMEOUT_MS) { throw new Error(`File processing timed out for ${file.name} after ${FILE_API_PROCESSING_TIMEOUT_MS / 1000}s.`); }
                     const processMsg = `Processing file ${index + 1}/${totalFiles}: ${file.name}... (State: ${fileResponse.file.state})`; // ***** TAMIL ***** Processing status message
                     setLoadingState(true, processMsg);
                     console.log(`[File API] File ${file.name} state: ${fileResponse.file.state}. Waiting ${FILE_API_POLLING_INTERVAL_MS / 1000}s...`);
                     await new Promise(resolve => setTimeout(resolve, FILE_API_POLLING_INTERVAL_MS));
                     try { fileResponse = await genAI.files.get({ name: apiFileName }); if (!fileResponse?.file) { throw new Error(`Polling failed: Invalid response from getFile for ${apiFileName}.`); } } catch (pollError) { console.error(`[File API] Error polling file ${apiFileName}:`, pollError); throw new Error(`Error checking processing status for ${file.name}: ${pollError.message}`); }
                 }
                 if (fileResponse.file.state !== 'ACTIVE') { console.error(`[File API] File processing failed for ${file.name}. Final State: ${fileResponse.file.state}`, fileResponse.file); try { await genAI.files.delete({ name: apiFileName }); console.log(`[File API] Deleted failed/inactive file: ${apiFileName}`); } catch (delErr) { console.warn(`[File API] Failed to delete failed/inactive file ${apiFileName}:`, delErr); } throw new Error(`File processing for ${file.name} resulted in state: ${fileResponse.file.state}.`); }
                 console.log(`[File API] File ${file.name} (API: ${apiFileName}) processed successfully. URI: ${fileResponse.file.uri}`);
                 return fileResponse.file;
             } catch (uploadError) {
                 console.error(`[File API] Error during upload/processing for ${file.name}:`, uploadError);
                 if (uploadResult?.file?.name) { try { await genAI.files.delete({ name: uploadResult.file.name }); console.log(`[File API] Cleaned up file ${uploadResult.file.name} after error.`); } catch (delErr) { console.warn(`[File API] Failed to cleanup file ${uploadResult.file.name} after error:`, delErr); } }
                 throw uploadError; // Re-throw error after attempting cleanup
             } finally {
                 // Ensure loading state is reset if this was the last file, even on error
                 if(index === totalFiles - 1) {
                     // We might transition to 'Generating response...' immediately after,
                     // so a brief reset might not be visible, but it's good practice.
                     // setLoadingState(false); // Reconsider if this causes flicker before 'Generating...'
                 }
             }
         }


        // --- Message Sending (Gemini API & Firestore Save) ---
        // (handleSendMessage remains mostly the same, but uses the enhanced uploadAndProcessFile)
        async function handleSendMessage() {
            const userMessageTextRaw = userInput.value.trim(); const mediaItemsToSend = [...selectedMediaItems]; const isMCQRequest = mcqModeCheckbox.checked; const youtubeMatch = userMessageTextRaw.match(youtubeRegex); const youtubeUrl = youtubeMatch ? youtubeMatch[0] : null;
            console.log("handleSendMessage: Text:", userMessageTextRaw ? userMessageTextRaw.substring(0, 50) + '...' : '(empty)', "Media items:", mediaItemsToSend.length, "YT URL:", youtubeUrl, "Model:", selectedModelId);
            if (!currentUser) { displayError("Please log in to send messages."); return; } if (!activeChatId) { displayError("Please select or create a chat first."); return; } if (!API_KEY || !genAI || !isAISdkReady || !HarmCategory || !HarmBlockThreshold) { displayError("API Key or AI SDK not ready/fully initialized. Cannot send message."); return; } const currentModelInfo = AVAILABLE_MODELS.find(m => m.id === selectedModelId); if (!currentModelInfo) { displayError("Selected AI model is invalid. Please choose another model."); return; } if (youtubeUrl && mediaItemsToSend.length > 0) { displayError("Cannot process a YouTube URL and uploaded media in the same message."); setLoadingState(false); return; } const hasPdfs = mediaItemsToSend.some(item => item.type === 'pdf'); if (hasPdfs && (!genAI.files || !genAI.files.upload)) { displayError("File API is unavailable. Cannot send PDF files."); return; } if (!userMessageTextRaw && mediaItemsToSend.length === 0 && !youtubeUrl) { console.log("Empty message and no media/URL. Nothing to send."); return; } if (sendButton.disabled || isRecording) { console.log("Send disabled (loading/recording)."); return; }
            setLoadingState(true, "Preparing message...");
            userInput.value = ''; autoGrowTextarea(); if (isMCQRequest) mcqModeCheckbox.checked = false;
            const timestamp = firebase.firestore.FieldValue.serverTimestamp(); const messagesColRef = db.collection('chats').doc(activeChatId).collection('messages'); const chatDocRef = db.collection('chats').doc(activeChatId);
            const userMsgData = { role: "user", text: userMessageTextRaw, timestamp: timestamp }; const singleAudioItem = mediaItemsToSend.find(item => item.type === 'audio'); const imageItems = mediaItemsToSend.filter(item => item.type === 'image'); const pdfItems = mediaItemsToSend.filter(item => item.type === 'pdf'); let potentialTestTitle = null;
            if (singleAudioItem) { userMsgData.mediaType = 'audio'; userMsgData.mediaData = singleAudioItem.base64; userMsgData.mediaMimeType = singleAudioItem.mimeType; userMsgData.mediaName = singleAudioItem.name; } else if (imageItems.length === 1) { userMsgData.mediaType = 'image'; userMsgData.mediaName = imageItems[0].name; userMsgData.mediaMimeType = imageItems[0].mimeType; if (!imageItems[0].base64) { try { imageItems[0].base64 = await readFileAsBase64(imageItems[0].file); } catch (e) { console.error("Error reading image for DB:", e); imageItems[0].base64 = '#error'; } } userMsgData.mediaData = imageItems[0].base64; } else if (imageItems.length > 1) { userMsgData.mediaType = 'multi-image'; userMsgData.mediaCount = imageItems.length; userMsgData.mediaNames = imageItems.map(img => img.name || 'image'); } else if (pdfItems.length > 0) { userMsgData.mediaType = 'multi-pdf'; userMsgData.mediaCount = pdfItems.length; userMsgData.mediaNames = pdfItems.map(pdf => pdf.name || 'pdf'); } if (youtubeUrl && youtubeMatch && youtubeMatch[1]) userMsgData.youtubeVideoId = youtubeMatch[1];
            let savedUserMessageId = null;
             try {
                 const chatSnap = await chatDocRef.get(); let isFirstUserMessageInNewChat = false; if (chatSnap.exists && chatSnap.data().title === NEW_CHAT_TITLE) { const messagesSnap = await messagesColRef.limit(1).get(); if (messagesSnap.empty) { isFirstUserMessageInNewChat = true; } }
                 const userMessageDocRef = await messagesColRef.add(userMsgData); savedUserMessageId = userMessageDocRef.id;
                 await chatDocRef.update({ lastUpdated: timestamp }); console.log("User message saved to Firestore:", savedUserMessageId);
                 const userPartsForHistory = []; let historyText = userMsgData.text; if (youtubeUrl && historyText && !historyText.includes(youtubeUrl)) { historyText += "\n" + youtubeUrl; } else if (youtubeUrl && !historyText) { historyText = youtubeUrl; } if (historyText) userPartsForHistory.push({ text: historyText });
                 if (userPartsForHistory.length > 0) { currentChatHistory.push({ role: 'user', parts: userPartsForHistory, firestoreId: savedUserMessageId }); }
                 if (isFirstUserMessageInNewChat) { let titleSource = userMessageTextRaw || (mediaItemsToSend[0]?.name) || (youtubeUrl ? 'YouTube Video Chat' : NEW_CHAT_TITLE); const generatedTitle = generateChatTitle(titleSource); if (generatedTitle && generatedTitle !== NEW_CHAT_TITLE) { await updateActiveChatTitle(generatedTitle); } }
             } catch(error) { console.error("Error saving user message:", error); displayError("Failed to save your message."); setLoadingState(false); return; }
            const thinking = displayMessage("Thinking...", 'ai', ['thinking']); scrollToBottom();
            const partsForApi = []; let fileDataPartsForApi = []; let useCache = false; let cacheToUse = null; let isYouTubeRequest = false; let generatedResponse = null; let aiResponseSaved = false; let uploadedFileUris = []; let savedAiMessageId = null;
            try {
                 let textPromptForApi = userMessageTextRaw;
                 if (youtubeUrl && mediaItemsToSend.length === 0) { isYouTubeRequest = true; const youtubePart = { fileData: { fileUri: youtubeUrl } }; partsForApi.push(youtubePart); console.log("Added YouTube URL as fileData part for API:", youtubeUrl); textPromptForApi = userMessageTextRaw.replace(youtubeUrl, '').trim(); if (isMCQRequest) { potentialTestTitle = generateChatTitle(textPromptForApi || "YouTube Video Test") + ` (${new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })})`; const mcqInstructions = `\n\nPlease generate multiple choice questions based on the provided video... [MCQ JSON instructions]`; textPromptForApi = textPromptForApi ? textPromptForApi + mcqInstructions : `Generate multiple choice questions...` + mcqInstructions; console.log("MCQ mode for YouTube: Using prompt:", textPromptForApi); } else if (!textPromptForApi) { textPromptForApi = "Summarize this video."; console.log("YouTube URL only: Using default 'Summarize' prompt."); } if (textPromptForApi) { partsForApi.push({ text: textPromptForApi }); console.log("Added text prompt part for YouTube request:", textPromptForApi); } }
                 else if (mediaItemsToSend.length > 0) { if (singleAudioItem) { if (!singleAudioItem.base64 || !singleAudioItem.mimeType) { throw new Error("Audio data is missing or invalid."); } const base64Data = singleAudioItem.base64.substring(singleAudioItem.base64.indexOf(',') + 1); partsForApi.push({ inlineData: { mimeType: singleAudioItem.mimeType, data: base64Data } }); console.log(`Added audio inlineData part.`); setLoadingState(true, "Sending message with audio..."); } else if (imageItems.length > 0) { const imageBase64Promises = imageItems.map(item => item.base64 || readFileAsBase64(item.file)); const imageBase64Results = await Promise.all(imageBase64Promises); let addedImageCount = 0; imageBase64Results.forEach((b64, index) => { if (!b64 || b64 === '#error') { console.error(`Skipping image ${imageItems[index]?.name || index}: Invalid base64 data.`); return; } const mime = imageItems[index].mimeType; const data = b64.substring(b64.indexOf(',') + 1); if(data && mime) { partsForApi.push({ inlineData: { mimeType: mime, data: data } }); addedImageCount++; } else { console.error(`Skipping image ${imageItems[index]?.name || index}: Missing data or mimeType.`); } }); console.log(`Added ${addedImageCount}/${imageItems.length} images as inlineData parts.`); if (addedImageCount === 0 && imageItems.length > 0) { throw new Error("Failed to process any selected images."); } setLoadingState(true, `Sending message with ${addedImageCount} image(s)...`); } else if (pdfItems.length > 0) { console.log(`Uploading ${pdfItems.length} PDF(s) via File API...`); const uploadPromises = pdfItems.map((item, index) => uploadAndProcessFile(item.file, index, pdfItems.length)); const uploadedFileResults = await Promise.all(uploadPromises); uploadedFileUris = uploadedFileResults.map(f => f.uri).filter(uri => uri); if (uploadedFileUris.length === 0 && pdfItems.length > 0) { throw new Error("Failed to upload or process any selected PDF files."); } fileDataPartsForApi = uploadedFileUris.map(uri => { const originalFile = uploadedFileResults.find(f => f.uri === uri); return { fileData: { mimeType: originalFile.mimeType, fileUri: uri } }; }); console.log(`Prepared ${fileDataPartsForApi.length} fileData parts for API (PDFs).`); const canAttemptCaching = currentModelInfo.supportsCaching && fileDataPartsForApi.length > 0 && !!genAI?.caching?.createCachedContent; if (canAttemptCaching) { const sortedUris = [...uploadedFileUris].sort(); if (currentMediaCacheName && cachedMediaUris.length === sortedUris.length && cachedMediaUris.every((uri, i) => uri === sortedUris[i])) { console.log(`Attempting to use existing cache: ${currentMediaCacheName}`); useCache = true; cacheToUse = currentMediaCacheName; } else { console.log("No matching PDF cache found or URIs differ. Will attempt to create new cache."); currentMediaCacheName = null; cachedMediaUris = []; } } else if (fileDataPartsForApi.length > 0) { console.log(`Caching skipped for PDFs: Model ${selectedModelId} doesn't support it, or SDK caching API missing.`); } } textPromptForApi = userMessageTextRaw; if (isMCQRequest) { potentialTestTitle = generateChatTitle(textPromptForApi || (mediaItemsToSend[0]?.name) || "Generated Test") + ` (${new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })})`; const mcqInstructions = `\n\nPlease generate multiple choice questions... [MCQ JSON instructions]`; textPromptForApi = textPromptForApi ? textPromptForApi + mcqInstructions : mcqInstructions; console.log("MCQ mode for uploaded media: Using prompt:", textPromptForApi); } if (textPromptForApi) { partsForApi.push({ text: textPromptForApi }); console.log("Added text prompt part for uploaded media request:", textPromptForApi); } }
                 else { textPromptForApi = userMessageTextRaw; if (isMCQRequest) { potentialTestTitle = generateChatTitle(textPromptForApi || "Text-Based Test") + ` (${new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })})`; const mcqInstructions = `\n\nPlease generate multiple choice questions... [MCQ JSON instructions]`; textPromptForApi = textPromptForApi ? textPromptForApi + mcqInstructions : mcqInstructions; console.log("MCQ mode for text only: Using prompt:", textPromptForApi); } if (textPromptForApi) { partsForApi.push({ text: textPromptForApi }); console.log("Added text-only prompt part:", textPromptForApi); } setLoadingState(true, "Sending message..."); }
                let finalPartsForApi = []; if (isYouTubeRequest) { finalPartsForApi = partsForApi; } else if (fileDataPartsForApi.length > 0) { if (useCache) { finalPartsForApi = partsForApi.filter(p => p.text || p.inlineData); } else { finalPartsForApi = [...fileDataPartsForApi, ...partsForApi.filter(p => p.text || p.inlineData)]; } } else { finalPartsForApi = partsForApi; }
                 if (finalPartsForApi.length === 0 && !useCache) { throw new Error("No valid content to send."); }
                console.log("Calling Gemini API via SDK..."); setLoadingState(true, "Generating response...");
                 const selectedModelConfig = AVAILABLE_MODELS.find(m => m.id === selectedModelId); const maxTokens = selectedModelConfig?.maxTokens || DEFAULT_MAX_TOKENS; console.log(`Using model: ${selectedModelId}, Setting maxOutputTokens: ${maxTokens}`);
                const model = genAI.getGenerativeModel({ model: selectedModelId, safetySettings: [ { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, ], generationConfig: { maxOutputTokens: maxTokens } });
                const historyForSDK = currentChatHistory.map(msg => ({ role: msg.role, parts: msg.parts.filter(part => typeof part.text === 'string').map(part => ({ text: part.text })) })).filter(msg => msg.parts.length > 0);
                 const contentsRequest = [ ...historyForSDK, { role: "user", parts: finalPartsForApi } ]; const generateContentRequest = { contents: contentsRequest, ...(useCache && cacheToUse && { cache: { name: cacheToUse } }) };
                 console.log("SDK Request Payload:", JSON.stringify(generateContentRequest, (k, v) => { if (k === 'data' && typeof v === 'string' && v.length > 100) return v.substring(0, 50) + '...[truncated]'; if (k === 'fileUri' && typeof v === 'string') { if (v.includes('youtube.com') || v.includes('youtu.be')) return v; else return '...' + v.split('/').pop() + ' [uri]'; } return v; }, 2));
                const result = await model.generateContent(generateContentRequest); generatedResponse = result.response;
                removeMessageElement(thinking);
                let aiMsgData = { role: "model", text: "Error: No valid response from API.", timestamp: firebase.firestore.FieldValue.serverTimestamp(), mcqData: null, mcqTitle: null }; let displayAsError = true; let rawAiText = ""; let blocked = false;
                if (generatedResponse.promptFeedback?.blockReason) { aiMsgData.text = `Blocked (Prompt): ${generatedResponse.promptFeedback.blockReason}`; blocked = true; displayAsError = true; console.warn("Prompt blocked:", generatedResponse.promptFeedback); }
                else if (generatedResponse.candidates && generatedResponse.candidates.length > 0) { const candidate = generatedResponse.candidates[0]; if (candidate.finishReason === 'SAFETY') { aiMsgData.text = `Blocked (Response Safety): ${candidate.safetyRatings?.map(r => `${r.category.replace('HARM_CATEGORY_','')} (${r.probability})`).join(', ') || 'Reason unspecified'}`; blocked = true; displayAsError = true; console.warn("Response blocked (Safety):", candidate.safetyRatings); } else if (candidate.finishReason === 'RECITATION') { aiMsgData.text = `Blocked (Response Recitation)`; blocked = true; displayAsError = true; console.warn("Response blocked (Recitation)"); } else if (candidate.content?.parts?.length > 0) { try { rawAiText = generatedResponse.text(); aiMsgData.text = rawAiText; displayAsError = false; if (isMCQRequest && !blocked) { try { const jsonMatch = rawAiText.match(/```json\s*([\s\S]*?)\s*```/); const jsonString = jsonMatch ? jsonMatch[1].trim() : rawAiText.trim(); if (jsonString.startsWith('[') && jsonString.endsWith(']')) { const mcqs = JSON.parse(jsonString); const isValid = Array.isArray(mcqs) && mcqs.length > 0 && mcqs.every(q => q.question?.en && q.options?.length === 4 && q.options.every(opt=>opt.en) && q.answer && q.explanation?.en); if (isValid) { mcqs.forEach(q => { q.question.ta = q.question.ta || q.question.en; q.explanation.ta = q.explanation.ta || q.explanation.en; q.options.forEach(opt => { opt.ta = opt.ta || opt.en; }); }); aiMsgData.text = `Generated ${mcqs.length} MCQs.`; aiMsgData.mcqData = mcqs; aiMsgData.mcqTitle = potentialTestTitle; console.log("MCQs parsed successfully."); displayAsError = false; } else { throw new Error("Invalid MCQ structure."); } } else { throw new Error("Not a JSON array."); } } catch (parseError) { console.warn("Failed to parse MCQ JSON:", parseError.message); aiMsgData.text = "MCQ format error.\n\n" + rawAiText; displayAsError = true; aiMsgData.mcqData = null; aiMsgData.mcqTitle = null; } } } catch (textError) { console.error("Error extracting text from SDK response:", textError); aiMsgData.text = "Error extracting text from response."; displayAsError = true; } } else if (candidate.finishReason === 'MAX_TOKENS') { console.warn("Response stopped: MAX_TOKENS."); aiMsgData.text = (generatedResponse.text ? generatedResponse.text() : "") + "\n\n(Response may be truncated due to token limit)"; displayAsError = false; } else if (candidate.finishReason === 'STOP' && (!candidate.content || candidate.content?.parts?.length === 0)){ aiMsgData.text = "(Model returned no content)"; displayAsError = false;} else { console.warn("API response finish reason:", candidate.finishReason); aiMsgData.text = `Response finished: ${candidate.finishReason || 'Unknown'}. ` + (generatedResponse.text ? generatedResponse.text() : ""); displayAsError = false; } }
                else { console.error("API Error: No candidates in response."); aiMsgData.text = "Error: No response data from API."; displayAsError = true; }
                 try {
                      const aiDocRef = await messagesColRef.add(aiMsgData); savedAiMessageId = aiDocRef.id;
                      await chatDocRef.update({ lastUpdated: firebase.firestore.FieldValue.serverTimestamp() }); aiResponseSaved = true; console.log("AI response/error saved to Firestore:", savedAiMessageId);
                      if (!displayAsError && !blocked && aiMsgData.text) {
                           currentChatHistory.push({ role: 'model', parts: [{ text: aiMsgData.text }], firestoreId: savedAiMessageId });
                      }
                 } catch (saveError) { console.error("Error saving AI response:", saveError); displayError(`Failed to save AI response.`); }
                 if (!isYouTubeRequest && !useCache && currentModelInfo.supportsCaching && fileDataPartsForApi.length > 0 && !!genAI?.caching?.createCachedContent) { const newCacheName = `cache-${activeChatId}-media-${Date.now()}`; console.log(`Attempting to create PDF cache: ${newCacheName} for ${fileDataPartsForApi.length} file(s). TTL: ${CACHE_TTL_SECONDS}s`); try { const cacheRequest = { model: `models/${selectedModelId}`, contents: [{ role: 'user', parts: fileDataPartsForApi }], ttlSeconds: CACHE_TTL_SECONDS, name: newCacheName }; console.log("PDF Cache Creation Request:", JSON.stringify(cacheRequest, (k, v) => (k === 'fileUri' ? '...' + v.split('/').pop() + ' [uri]' : v), 2)); genAI.caching.createCachedContent(cacheRequest).then(createdCache => { if (createdCache?.name) { currentMediaCacheName = createdCache.name; cachedMediaUris = [...uploadedFileUris].sort(); console.log(`PDF Cache ${currentMediaCacheName} creation initiated successfully for URIs:`, cachedMediaUris); } else { console.warn("PDF Cache creation call may have succeeded but did not return a valid cache object."); } }).catch(cacheError => { console.error(`Error initiating PDF cache creation for ${newCacheName}:`, cacheError); }); } catch (e) { console.error("Unexpected error setting up PDF cache creation:", e); } } else if (useCache) { console.log(`Used existing PDF cache: ${cacheToUse}`); } else if (!isYouTubeRequest && fileDataPartsForApi.length > 0) { console.log("PDF Cache creation skipped: Model/SDK doesn't support it, or no PDF files to cache."); }
            } catch (error) { console.error("Error during send process:", error); removeMessageElement(thinking); const errorText = `Error: ${error.message || "An unexpected error occurred during sending."}`; displayError(errorText); if (!aiResponseSaved) { try { await messagesColRef.add({ role: "model", text: errorText, timestamp: firebase.firestore.FieldValue.serverTimestamp() }); await chatDocRef.update({ lastUpdated: firebase.firestore.FieldValue.serverTimestamp() }); console.log("Error message saved to Firestore."); } catch (saveError) { console.error("Failed to save error message:", saveError); } }
            } finally { console.log("handleSendMessage finally block reached."); removeAllSelectedMedia(); setLoadingState(false); if (!isTestMode && !isReviewMode && activeChatId) { setTimeout(() => userInput.focus(), 100); } }
        } // End of handleSendMessage


        // --- Chat Title Generation/Update ---
        // (generateChatTitle, updateActiveChatTitle remain the same)
        function generateChatTitle(sourceText) { if (!sourceText || typeof sourceText !== 'string') return NEW_CHAT_TITLE; const text = sourceText.trim(); if (!text) return NEW_CHAT_TITLE; const title = text.split(/\s+/).slice(0, 5).join(' ').replace(/[.,!?;:]+$/, ''); return title.length > 35 ? title.substring(0, 32) + '...' : title; }
        async function updateActiveChatTitle(newTitle) { if (!currentUser || !activeChatId || !newTitle || typeof newTitle !== 'string' || !newTitle.trim() || newTitle.trim() === NEW_CHAT_TITLE) return; const finalTitle = newTitle.trim(); const chatDocRef = db.collection('chats').doc(activeChatId); try { await chatDocRef.update({ title: finalTitle }); console.log(`Chat ${activeChatId} title updated: "${finalTitle}"`); } catch (error) { console.error("Error updating chat title:", error); } }

        // --- File Reader Helper ---
        // (readFileAsBase64 remains the same)
        function readFileAsBase64(file) { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = () => resolve(reader.result); reader.onerror = (error) => reject(error); reader.readAsDataURL(file); }); }

        // --- UI & Message Display Helpers ---
        // (autoGrowTextarea, handleInputKeydown, handleSuggestionClick remain the same)
        function autoGrowTextarea() { userInput.style.height='auto'; userInput.style.height=(userInput.scrollHeight)+'px'; }
        function handleInputKeydown(event) { if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();if(!sendButton.disabled) handleSendMessage();} }
        function handleSuggestionClick(event) { if(event.target.classList.contains('suggestion-chip')){ const prompt = event.target.dataset.prompt || ''; userInput.value = prompt; if (prompt.toLowerCase().includes("video") || prompt.toLowerCase().includes("youtube")) { userInput.value += " "; userInput.placeholder = "Paste YouTube URL after the prompt..."; } autoGrowTextarea();userInput.focus(); updateButtonStates();} }
        // (displayError, scrollToBottom, removeMessageElement remain the same)
        function displayError(text) { console.error("Displaying Error:", text); displayMessage(`${text}`, 'ai', ['error-message']); scrollToBottom(); }
        function scrollToBottom(immediate = false) { chatArea.scrollTo({top:chatArea.scrollHeight,behavior:immediate?'auto':'smooth'}); }
        function removeMessageElement(element) { if(element && element.parentNode === chatArea) { try { chatArea.removeChild(element); } catch(e) { /* ignore */ } } else if (element?.parentNode?.classList.contains('message-wrapper') && element.parentNode.parentNode === chatArea) { try { chatArea.removeChild(element.parentNode); } catch(e) { /* ignore */ } } }

        // (updateButtonStates remains the same)
         function updateButtonStates(isLoading = false) {
            const isLoggedIn = !!currentUser;
            const isSdkFullyReady = isLoggedIn && !!API_KEY && !!genAI && isAISdkReady && !!HarmCategory && !!HarmBlockThreshold;
            const canUseFileAPI = isSdkFullyReady && !!genAI.files?.upload;
            const currentModelInfo = AVAILABLE_MODELS.find(m => m.id === selectedModelId);
            const canUseCachingAPI = isSdkFullyReady && !!genAI.caching?.createCachedContent;
            const canAttemptCaching = canUseCachingAPI && currentModelInfo?.supportsCaching;
            const hasYouTubeUrlInInput = youtubeRegex.test(userInput.value.trim());
            const hasSelectedMedia = selectedMediaItems.length > 0;

            const isChatSelected = !!activeChatId;
            const isAppReady = isSdkFullyReady;
            const canSendCombination = !(hasYouTubeUrlInInput && hasSelectedMedia);
            const canSendMessage = isAppReady && isChatSelected && !isLoading && !isRecording && canSendCombination && (userInput.value.trim() !== '' || hasSelectedMedia || hasYouTubeUrlInInput);

            userInput.disabled = !isAppReady || !isChatSelected || isLoading || isRecording;
            sendButton.disabled = !canSendMessage;
            mcqModeCheckbox.disabled = !canSendMessage;

            const disableFileUpload = isLoading || isRecording || !isAppReady || !isChatSelected || hasYouTubeUrlInInput;
            const disableAudioRecord = isLoading || !isAppReady || !isChatSelected || hasYouTubeUrlInInput;

            unifiedUploadButton.disabled = disableFileUpload || hasSelectedMedia;
            unifiedUploadButton.title = unifiedUploadButton.disabled ? "File upload disabled (Check login, SDK, chat, media, or recording)" : "Upload File (Image, PDF, Audio)";

            recordAudioButton.disabled = disableAudioRecord || hasSelectedMedia;
            recordAudioButton.title = recordAudioButton.disabled ? "Audio recording disabled (Check login, SDK, chat, media, or conflicting input)" : (isRecording ? "Stop recording" : "Record audio");

            if (isRecording) { recordAudioButton.disabled = false; recordAudioButton.title = "Stop recording"; }

            startChatButton.disabled = !isLoggedIn || isLoading || isRecording;
            testSearchInput.disabled = !isLoggedIn || isLoading || isRecording;

            decreaseTextBtn.disabled = isLoading || isRecording || currentTextSizeMultiplier <= MIN_TEXT_SIZE_MULTIPLIER;
            increaseTextBtn.disabled = isLoading || isRecording || currentTextSizeMultiplier >= MAX_TEXT_SIZE_MULTIPLIER;
            themeToggleButton.disabled = isLoading || isRecording;
            modelSelector.disabled = isLoading || isRecording || !isLoggedIn;

            loginBtn.disabled = isLoading;
            logoutBtn.disabled = isLoading;
         }

        // (setLoadingState remains the same)
        function setLoadingState(isLoading, message = "Generating...") { updateButtonStates(isLoading); let placeholderText = ""; const isLoggedIn = !!currentUser; const isSdkFullyReady = isLoggedIn && !!API_KEY && !!genAI && isAISdkReady && !!HarmCategory && !!HarmBlockThreshold; if (isRecording) { placeholderText = "Recording audio..."; } else if (isLoading) { placeholderText = message; } else if (!isLoggedIn) { placeholderText = "Please log in"; } else if (!isSdkFullyReady) { placeholderText = "API Key/SDK Error. Check settings/reload."; } else if (!activeChatId) { placeholderText = "Select or create a chat"; } else { placeholderText = "Enter prompt, attach media, or paste URL"; } if (userInput.placeholder !== placeholderText) { userInput.placeholder = placeholderText; } }

        // (switchView remains the same)
        function switchView(viewName, cameFromTests = false) { console.log("Switching view to:", viewName); chatView.classList.remove('active'); reviewView.classList.remove('active'); testView.classList.remove('active'); appContainer.classList.remove('hidden'); isTestMode = false; isReviewMode = false; cameFromAllTestsList = cameFromTests; saveReviewBtn.style.display = 'none'; exitReviewBtn.style.display = 'none'; if(viewName === 'test'){ appContainer.classList.add('hidden'); testView.classList.add('active'); isTestMode = true; } else if(viewName === 'review'){ reviewView.classList.add('active'); isReviewMode = true; exitReviewBtn.style.display = 'inline-block'; exitReviewBtn.textContent = cameFromAllTestsList ? "Back to All Tests" : "Back to Chat"; } else { chatView.classList.add('active'); if (currentUser && activeChatId && API_KEY && genAI && !isRecording) { setTimeout(() => userInput.focus(), 100); } } if (viewName !== 'test' && testTimerInterval) { clearInterval(testTimerInterval); testTimerInterval = null; } }

        // displayMessage: Updated for Audio Playback
        // ***** TAMIL ***** ‡Æá‡Æô‡Øç‡Æï‡Æ§‡Ææ‡Æ©‡Øç message-‡Æê chat-‡Æ≤ ‡Æï‡Ææ‡Æü‡Øç‡Æü‡ØÅ‡ÆÆ‡Øç logic ‡Æá‡Æ∞‡ØÅ‡Æï‡Øç‡Æï‡ØÅ. Audio player ‡Æá‡Æô‡Øç‡Æï ‡Æö‡Øá‡Æ∞‡Øç‡Æï‡Øç‡Æï‡Æø‡Æ±‡Øã‡ÆÆ‡Øç.
        function displayMessage(text, sender, cssClasses = [], appendHtml = null, messageData = null, firestoreId = null) {
            const messageWrapper = document.createElement('div');
            messageWrapper.classList.add('message-wrapper', `${sender}-wrapper`);
            if (firestoreId) { messageWrapper.dataset.firestoreId = firestoreId; }

            const messageElement = document.createElement('div');
            messageElement.classList.add('message', `${sender}-message`);
            if (cssClasses?.length > 0) messageElement.classList.add(...cssClasses);

            let hasContent = false; let containsCode = false;

            // --- Media Rendering (Uploaded Files) ---
            if (messageData?.mediaType === 'image' && messageData.mediaData && messageData.mediaData !== '#error') {
                try { const img = document.createElement('img'); img.src = messageData.mediaData; img.alt = messageData.mediaName || "Uploaded Image"; img.classList.add('uploaded-image'); img.loading = "lazy"; img.onerror = () => { img.alt = "Image load error"; img.src = ""; }; img.onclick = () => showImageModal(messageData.mediaData); messageElement.appendChild(img); hasContent = true; } catch (e) { console.error("Error creating image element:", e); }
            } else if (messageData?.mediaType === 'multi-image' && messageData.mediaCount > 0) {
                try { const indicator = document.createElement('div'); indicator.classList.add('multi-media-indicator'); indicator.textContent = `(${messageData.mediaCount} image${messageData.mediaCount > 1 ? 's' : ''} sent: ${messageData.mediaNames?.join(', ') || ''})`; messageElement.appendChild(indicator); hasContent = true; } catch (e) { console.error("Error creating multi-image indicator:", e); }
            } else if (messageData?.mediaType === 'multi-pdf' && messageData.mediaCount > 0) {
                try { const indicator = document.createElement('div'); indicator.classList.add('pdf-indicator'); indicator.innerHTML = `üìÑ (${messageData.mediaCount} PDF${messageData.mediaCount > 1 ? 's' : ''} sent: ${messageData.mediaNames?.join(', ') || ''})`; messageElement.appendChild(indicator); hasContent = true; } catch (e) { console.error("Error creating multi-PDF indicator:", e); }
            } else if (messageData?.mediaType === 'audio' && messageData.mediaData) {
                 // ***** TAMIL ***** Audio message ‡Æµ‡Æ®‡Øç‡Æ§‡Ææ‡Æ≤‡Øç, <audio> tag ‡Æâ‡Æ∞‡ØÅ‡Æµ‡Ææ‡Æï‡Øç‡Æï‡Æø ‡Æï‡Ææ‡Æü‡Øç‡Æü‡ØÅ‡Æï‡Æø‡Æ±‡Øã‡ÆÆ‡Øç.
                 try {
                     const audioContainer = document.createElement('div');
                     audioContainer.classList.add('chat-audio-player');
                     const audioPlayer = document.createElement('audio');
                     audioPlayer.src = messageData.mediaData; // Base64 data URL
                     audioPlayer.controls = true;
                     audioPlayer.preload = "metadata"; // Load only metadata initially
                     if(messageData.mediaName) audioPlayer.title = messageData.mediaName;
                     audioPlayer.onerror = () => {
                         console.warn("Error loading audio player for:", messageData.mediaName);
                         audioContainer.innerHTML = `<span style='font-size:0.8em; color:var(--error-text);'>üéµ (Audio load error: ${messageData.mediaName || 'Audio'})</span>`;
                     };
                     audioContainer.appendChild(audioPlayer);
                     messageElement.appendChild(audioContainer);
                     hasContent = true;
                 } catch (e) { console.error("Error creating audio element:", e); }
            }

             // --- Text Content Rendering ---
            if (text) {
                const messageContentContainer = document.createElement('div');
                 messageContentContainer.classList.add('message-content');
                try {
                    const tempDiv = document.createElement('div'); tempDiv.innerText = text; let formattedText = tempDiv.innerHTML;
                    if (messageData?.mediaType !== 'image' && messageData?.mediaType !== 'audio') { formattedText = formattedText.replace(imageUrlRegex, (match, imgUrl) => `<img src="${imgUrl}" class="chat-image" alt="Chat Image" loading="lazy" onerror="this.alt='Image URL load error'; this.src='';">`); }
                    formattedText = formattedText.replace(/```(\w*)\n?([\s\S]*?)```/g, (match, lang, code) => { containsCode = true; const safeLang = lang?.trim()?.match(/^[a-zA-Z0-9_-]+$/) ? lang.trim().toLowerCase() : 'plain'; const languageClass = `language-${safeLang}`; const escapedCode = code.replace(/</g, "&lt;").replace(/>/g, "&gt;"); return `<pre class="${languageClass}"><code class="${languageClass}">${escapedCode}</code></pre>`; });
                     formattedText = formattedText.replace(/`([^`]+?)`/g, (match, code) => { const escapedInlineCode = code.replace(/</g, "&lt;").replace(/>/g, "&gt;"); return `<code>${escapedInlineCode}</code>`; });
                    formattedText = formattedText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/(?<!\*)\*(?!\*)(.*?)(?<!\*)\*(?!\*)/g, '<em>$1</em>').replace(/\n/g, '<br>');
                    messageContentContainer.innerHTML = formattedText; messageElement.appendChild(messageContentContainer); hasContent = true;
                    if (text.includes('$') || text.includes('\\') || text.includes('^') || text.includes('_')) { if (typeof MathJax !== "undefined" && MathJax.typesetPromise) { setTimeout(() => { MathJax.typesetPromise([messageContentContainer]).catch(err => console.error('MathJax typesetting error:', err)); }, 50); } }
                } catch (e) { console.error("Error formatting text content:", e); messageContentContainer.innerText = text; if (!messageElement.contains(messageContentContainer)) { messageElement.appendChild(messageContentContainer); } hasContent = true; }
            }

            // --- YouTube Embed ---
            if (messageData?.youtubeVideoId) { try { const youtubeEmbedDiv = document.createElement('div'); youtubeEmbedDiv.classList.add('youtube-embed-container'); const iframe = document.createElement('iframe'); iframe.classList.add('chat-video'); iframe.src = `https://www.youtube.com/embed/${messageData.youtubeVideoId}`; iframe.title = "YouTube video player"; iframe.allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"; iframe.allowFullscreen = true; iframe.loading = "lazy"; iframe.onerror = () => { youtubeEmbedDiv.innerHTML = `<span style='font-size:0.8em; color:var(--error-text);'>(YouTube embed error: ID ${messageData.youtubeVideoId})</span>`; }; youtubeEmbedDiv.appendChild(iframe); messageElement.appendChild(youtubeEmbedDiv); hasContent = true; console.log(`Displaying YouTube embed for ID: ${messageData.youtubeVideoId}`); } catch (e) { console.error("Error creating YouTube embed:", e); } }

             // --- MCQ Offer ---
            if (messageData?.role === 'model' && messageData?.mcqData?.length > 0) { try { displayMCQOffer(messageData.mcqData, messageData.mcqTitle, messageElement); hasContent = true; } catch (e) { console.error("Error displaying MCQ offer:", e); } }
            // --- Append Raw HTML ---
            else if (appendHtml) { try { const appendDiv = document.createElement('div'); appendDiv.innerHTML = appendHtml; while (appendDiv.firstChild) { messageElement.appendChild(appendDiv.firstChild); } hasContent = true; } catch (e) { console.error("Error appending raw HTML:", e); } }

            // --- Message Actions (Copy/Delete) ---
            if (firestoreId && !cssClasses.includes('thinking') && !cssClasses.includes('error-message')) {
                const actionsContainer = document.createElement('div');
                actionsContainer.classList.add('message-actions');
                const copyButton = document.createElement('button'); copyButton.classList.add('message-action-button', 'copy'); copyButton.innerHTML = COPY_ICON_SVG; copyButton.title = 'Copy message'; copyButton.dataset.action = 'copy'; actionsContainer.appendChild(copyButton);
                const deleteButton = document.createElement('button'); deleteButton.classList.add('message-action-button', 'delete'); deleteButton.innerHTML = DELETE_MESSAGE_ICON_SVG; deleteButton.title = 'Delete message'; deleteButton.dataset.action = 'delete'; actionsContainer.appendChild(deleteButton);
                messageWrapper.appendChild(actionsContainer);
            }

            // --- Append Message Wrapper to Chat Area ---
            if (hasContent || cssClasses.includes('thinking') || cssClasses.includes('error-message')) {
                 messageWrapper.appendChild(messageElement);
                if (!chatArea.contains(messageWrapper)) {
                    chatArea.appendChild(messageWrapper);
                    if (containsCode && typeof Prism !== 'undefined') {
                         setTimeout(() => { try { Prism.highlightAllUnder(messageElement); console.log("Prism highlighting applied."); } catch (highlightError) { console.error("Prism highlighting error:", highlightError); } }, 0);
                     }
                }
            } else { console.warn(`Skipping display of empty message. Sender: ${sender}, Classes: ${cssClasses.join(', ')}`); }

            return messageElement;
        }

        // --- Image Modal Functions ---
        // (showImageModal, hideImageModal remain the same)
        function showImageModal(imageUrl) { if (!imageUrl || imageUrl === '#error') return; modalImageContent.src = imageUrl; imageModal.style.display = 'flex'; console.log("Showing image modal"); }
        function hideImageModal() { imageModal.style.display = 'none'; modalImageContent.src = ''; console.log("Hiding image modal"); }

        // --- Chat Area Click Handler (Updated) ---
        // (handleChatAreaClick remains the same)
        function handleChatAreaClick(event) {
            const target = event.target;
            const startButton = target.closest('.start-test-button'); if (startButton) { const mcqDataString = startButton.dataset.mcq; const titleFromButton = startButton.dataset.mcqTitle; let mcqs = null; if (mcqDataString) { try { mcqs = JSON.parse(mcqDataString); } catch (e) { console.error("Failed parse MCQ data from button:", e); displayError("Could not start test. Invalid data."); return; } } if (mcqs?.length > 0) { startMockTest(mcqs, titleFromButton || null); } else { displayError("MCQ data missing or invalid."); } return; }
            const clickedChatImage = target.closest('img.chat-image, img.uploaded-image'); if (clickedChatImage?.src && !clickedChatImage.src.startsWith('#') && clickedChatImage.src.trim() !== '') { showImageModal(clickedChatImage.src); return; }
            const actionButton = target.closest('.message-action-button'); if (actionButton) { const action = actionButton.dataset.action; const messageWrapper = actionButton.closest('.message-wrapper'); const messageId = messageWrapper?.dataset.firestoreId; if (messageId && action === 'copy') { handleCopyMessage(messageWrapper, actionButton); } else if (messageId && action === 'delete') { handleDeleteMessage(messageWrapper, messageId); } return; }
        }

        // --- Message Action Handlers ---
        // (handleCopyMessage, handleDeleteMessage remain the same)
        function handleCopyMessage(messageWrapper, copyButton) {
            const messageElement = messageWrapper.querySelector('.message .message-content');
            if (!messageElement) { console.warn("Could not find message content to copy."); return; }
            let textToCopy = messageElement.innerText || messageElement.textContent || "";
             textToCopy = textToCopy.trim();
            if (!textToCopy) { console.warn("Message content is empty, nothing to copy."); return; }
            navigator.clipboard.writeText(textToCopy).then(() => {
                console.log("Message copied to clipboard:", textToCopy.substring(0,30) + "...");
                 const feedback = document.createElement('span');
                 feedback.textContent = 'Copied!';
                 feedback.classList.add('copied-feedback');
                 messageWrapper.appendChild(feedback); // Append to wrapper
                 setTimeout(() => { try { feedback.remove(); } catch(e){} }, 1500);
            }).catch(err => {
                console.error('Failed to copy message text: ', err); alert("Could not copy message.");
            });
        }
        async function handleDeleteMessage(messageWrapper, messageId) {
            if (!currentUser || !activeChatId || !messageId || isDeletingMessage) return;
            if (confirm("Are you sure you want to delete this message?")) {
                isDeletingMessage = true; console.log(`Attempting to delete message: ${messageId} from chat: ${activeChatId}`);
                setLoadingState(true, "Deleting message...");
                 messageWrapper.style.opacity = '0.5'; messageWrapper.style.transition = 'opacity 0.3s ease';
                 setTimeout(() => { try { chatArea.removeChild(messageWrapper); } catch (e) {} }, 300);
                try {
                    const messageRef = db.collection('chats').doc(activeChatId).collection('messages').doc(messageId); await messageRef.delete(); console.log("Message deleted from Firestore successfully:", messageId);
                    const historyIndex = currentChatHistory.findIndex(msg => msg.firestoreId === messageId); if (historyIndex > -1) { currentChatHistory.splice(historyIndex, 1); console.log("Message removed from local history array."); } else { console.warn("Message deleted from Firestore, but not found in local history:", messageId); }
                } catch (error) { console.error("Error deleting message from Firestore:", error); displayError("Failed to delete message."); messageWrapper.style.opacity = '1'; } finally { setLoadingState(false); isDeletingMessage = false; }
            }
        }


        // --- MCQ/Test/Review/All Tests Functions ---
        // (No changes needed in these functions from v10.4)
        function displayMCQOffer(mcqData, mcqTitle, aiMessageElement) { if (aiMessageElement.querySelector('.start-test-button')) return; const questionCount = mcqData.length; const button = document.createElement('button'); button.classList.add('start-test-button'); button.textContent = `Start Mock Test (${questionCount} Qs)`; button.title = mcqTitle || `Start generated test`; try { button.dataset.mcq = JSON.stringify(mcqData); if (mcqTitle) { button.dataset.mcqTitle = mcqTitle; } } catch (e) { console.error("Failed stringify MCQ data for button:", e); return; } const buttonContainer = document.createElement('div'); buttonContainer.style.marginTop = '10px'; buttonContainer.appendChild(button); aiMessageElement.appendChild(buttonContainer); }
        function startMockTest(mcqs, title = null) { if (!currentUser) { displayError("Log in to start test."); return; } if (!mcqs?.length) { displayError("No questions for test."); if (cameFromAllTestsList) { switchView('chat'); } return; } console.log("Starting mock test:", mcqs.length, "Qs. Title:", title); currentTestMCQs = mcqs; currentQuestionIndex = 0; userAnswers = new Array(mcqs.length).fill(null); reviewResultsCache = null; switchView('test'); displayTestQuestion(0); startTestTimer(); const finalTitle = (title && title.trim()) ? title.trim() : `Mock Test (${mcqs.length} Qs)`; testTitle.textContent = finalTitle; }
        function displayTestQuestion(index) { if (index < 0 || index >= currentTestMCQs.length) return; currentQuestionIndex = index; const questionData = currentTestMCQs[index]; const questionText = questionData.question?.en || "(Question missing)"; testQuestionNumber.textContent = `Question ${index + 1}`; testQuestion.innerHTML = questionText; testOptionsContainer.innerHTML = ''; const options = questionData.options || []; const optionLetters = ['A', 'B', 'C', 'D']; options.forEach((optionObj, optionIndex) => { if (optionIndex >= optionLetters.length) return; const optionText = optionObj?.en || '(Option missing)'; const label = document.createElement('label'); const input = document.createElement('input'); input.type = 'radio'; input.name = `q_${index}`; input.value = optionIndex; input.checked = (userAnswers[index] === optionIndex); input.onchange = () => handleOptionSelect(optionIndex); label.appendChild(input); label.appendChild(document.createTextNode(` ${optionLetters[optionIndex]}. ${optionText}`)); testOptionsContainer.appendChild(label); }); try { if (typeof MathJax !== "undefined" && MathJax.typesetPromise) { MathJax.typesetPromise([testQuestion, testOptionsContainer]).catch(err=>console.error('MathJax Test Q Error:', err)); } } catch(e){ console.error("MathJax call failed in test:", e); } prevQuestionBtn.disabled = (index === 0); nextQuestionBtn.disabled = (index === currentTestMCQs.length - 1); questionCounter.textContent = `Q: ${index + 1} / ${currentTestMCQs.length}`; }
        function handleOptionSelect(optionIndex) { if (currentQuestionIndex >= 0 && currentQuestionIndex < userAnswers.length) { userAnswers[currentQuestionIndex] = optionIndex; console.log(`Answered Q${currentQuestionIndex + 1}: Option ${optionIndex}`); } }
        function handleTestNavigation(direction) { let newIndex = currentQuestionIndex; if (direction === 'prev' && currentQuestionIndex > 0) { newIndex--; } else if (direction === 'next' && currentQuestionIndex < currentTestMCQs.length - 1) { newIndex++; } if (newIndex !== currentQuestionIndex) { displayTestQuestion(newIndex); } }
        function startTestTimer() { if (testTimerInterval) clearInterval(testTimerInterval); testStartTime = Date.now(); testTimer.textContent = `Time: 00:00`; testTimerInterval = setInterval(() => { const elapsedSeconds = Math.floor((Date.now() - testStartTime) / 1000); const minutes = Math.floor(elapsedSeconds / 60).toString().padStart(2, '0'); const seconds = (elapsedSeconds % 60).toString().padStart(2, '0'); testTimer.textContent = `Time: ${minutes}:${seconds}`; }, 1000); }
        function submitTest() { if (!confirm("Submit test?")) return; if (testTimerInterval) clearInterval(testTimerInterval); const endTime = Date.now(); const timeTakenMs = testStartTime ? endTime - testStartTime : 0; const results = calculateResults(currentTestMCQs, userAnswers, timeTakenMs); reviewResultsCache = results; switchView('review', false); displayReview(results); }
        function calculateResults(mcqs, answers, timeMs) { let correctCount = 0, incorrectCount = 0, skippedCount = 0; const reviewQuestions = []; mcqs.forEach((q, idx) => { const uAIdx = answers[idx]; const opts = q.options || []; const cALtr = q.answer?.trim().toUpperCase(); const cAIdx = cALtr ? cALtr.charCodeAt(0) - 'A'.charCodeAt(0) : -1; const cATxtE = (cAIdx >= 0 && cAIdx < opts.length) ? (opts[cAIdx]?.en || '?') : "N/A"; let uATxtE = "Skipped"; let st = "skipped"; if (uAIdx !== null && uAIdx >= 0 && uAIdx < opts.length) { uATxtE = opts[uAIdx]?.en || '?'; if (uAIdx === cAIdx) { st = "correct"; correctCount++; } else { st = "incorrect"; incorrectCount++; } } else if (uAIdx !== null) { uATxtE = "Invalid"; st = "incorrect"; incorrectCount++; } else { skippedCount++; } reviewQuestions.push({ question: q.question?.en || '?', correctAnswer: cATxtE, userAnswer: uATxtE, status: st, explanation: q.explanation?.en || "N/A" }); }); const total = mcqs.length; const score = `${correctCount}/${total}`; const timeS = Math.round(timeMs / 1000); const mins = Math.floor(timeS / 60); const secs = timeS % 60; const timeStr = `${mins}m ${secs}s`; return { questions: reviewQuestions, summary: { score, correct: correctCount, incorrect: incorrectCount, skipped: skippedCount, timeString: timeStr }, testDate: new Date().toISOString(), timeTakenMs: timeMs, sourceChatId: activeChatId, testTitle: testTitle.textContent, originalMCQs: mcqs }; }
        function displayReview(reviewData) { reviewContent.innerHTML = ''; reviewSummary.innerHTML = ''; reviewFilters.style.display = 'none'; if (!reviewData?.questions?.length || !reviewData.summary || !reviewData.originalMCQs) { reviewSummary.innerHTML = "<span>No review data available.</span>"; saveReviewBtn.style.display = 'none'; return; } const { score, correct, incorrect, skipped, timeString } = reviewData.summary; reviewSummary.innerHTML = `<span>Score: ${score}</span> <span class="score-correct">Correct: ${correct}</span> <span class="score-incorrect">Incorrect: ${incorrect}</span> <span class="score-skipped">Skipped: ${skipped}</span> <span>Time: ${timeString}</span>`; reviewTitle.textContent = reviewData.testTitle || "Test Review"; reviewData.questions.forEach((qSum, idx) => { const origQ = reviewData.originalMCQs[idx]; if (!origQ) return; const qTxt = origQ.question?.en || '?'; const opts = origQ.options || []; const cALtr = origQ.answer?.trim().toUpperCase(); const cAIdx = cALtr ? cALtr.charCodeAt(0) - 'A'.charCodeAt(0) : -1; const cATxt = (cAIdx >= 0 && cAIdx < opts.length) ? (opts[cAIdx]?.en) : "N/A"; let uATxt = qSum.userAnswer; const st = qSum.status; if (st === 'skipped') uATxt = "Skipped"; else if (st === 'invalid') uATxt = "Invalid"; const explTxt = origQ.explanation?.en || "N/A."; let iStCls = `status-${st}`; let aDtCls = `user-answer-${st}`; const rItem = document.createElement('div'); rItem.classList.add('review-item', iStCls); rItem.dataset.status = st; let dHtml = `<span class="${aDtCls}">Your Answer: ${uATxt}</span>`; if (st !== 'correct') { dHtml += `<br><span class="correct-answer">Correct Answer: ${cATxt}</span>`; } dHtml += `<div class="review-item-explanation">Explanation: ${explTxt}</div>`; rItem.innerHTML = `<div class="review-item-qnum">Q ${idx + 1}</div> <div class="review-item-question">${qTxt}</div> <div class="review-item-details">${dHtml}</div>`; reviewContent.appendChild(rItem); }); if (incorrect > 0 || skipped > 0) reviewFilters.style.display = 'block'; else reviewFilters.style.display = 'none'; if (reviewData.savedAt) { saveReviewBtn.textContent = "Saved"; saveReviewBtn.disabled = true; saveReviewBtn.style.display = 'inline-block'; } else if (reviewResultsCache && !cameFromAllTestsList) { saveReviewBtn.textContent = "Save Review"; saveReviewBtn.disabled = !currentUser; saveReviewBtn.style.display = 'inline-block'; } else { saveReviewBtn.style.display = 'none'; } filterReviewItems('all'); reviewFilters.querySelectorAll('button').forEach(btn => { btn.classList.toggle('active-filter', btn.dataset.filter === 'all'); }); try { if (typeof MathJax !== "undefined" && MathJax.typesetPromise) { MathJax.typesetPromise([reviewContent]).catch(err=>console.error('MathJax Review Error:', err)); } } catch (e) { console.error("MathJax call failed in review:", e); } }
        function handleReviewFilterClick(event) { const button = event.target.closest('button[data-filter]'); if (button) { filterReviewItems(button.dataset.filter); } }
        function filterReviewItems(filter) { reviewFilters.querySelectorAll('button').forEach(btn => { btn.classList.toggle('active-filter', btn.dataset.filter === filter); }); reviewContent.querySelectorAll('.review-item').forEach(item => { const show = (filter === 'all') || item.dataset.status === filter; item.classList.toggle('hidden-by-filter', !show); }); }
        function exitReview() { reviewResultsCache = null; switchView('chat'); reviewSummary.innerHTML = ''; reviewContent.innerHTML = ''; reviewTitle.textContent = 'Review'; }
        async function saveTestReviewToCloud() { if (!currentUser) { alert("Please log in to save the review."); return; } if (!reviewResultsCache || reviewResultsCache.savedAt) { alert("No new review data to save or already saved."); return; } if (!reviewResultsCache.originalMCQs?.length || !reviewResultsCache.summary) { if (!confirm("Warning: Review data seems incomplete. Save anyway?")) { return; } } const dataToSave = { ...reviewResultsCache, userId: currentUser.uid, savedAt: firebase.firestore.FieldValue.serverTimestamp(), }; saveReviewBtn.disabled = true; saveReviewBtn.textContent = "Saving..."; try { const newRef = await db.collection('testReviews').add(dataToSave); console.log("Review saved:", newRef.id); alert("Review saved!"); saveReviewBtn.textContent = "Saved"; if (reviewResultsCache) reviewResultsCache.savedAt = new Date(); } catch (error) { console.error("Error saving review:", error); alert("Failed to save review."); saveReviewBtn.disabled = false; saveReviewBtn.textContent = "Save Review"; } }
        function loadAndListenForTests(userId) { if (testListListener) { testListListener(); testListListener = null; } const testsRef = db.collection('testReviews').where('userId', '==', userId).orderBy('savedAt', 'desc'); console.log(`Listening for saved tests for user ${userId}`); testListListener = testsRef.onSnapshot(snapshot => { allSavedTestsData = []; snapshot.forEach(doc => { allSavedTestsData.push({ id: doc.id, ...doc.data() }); }); console.log("Received saved tests snapshot:", allSavedTestsData.length, "tests"); renderAllTestsList(allSavedTestsData); filterTestsInSidebar(); }, error => { console.error("Error listening for saved tests:", error); allTestsListContainer.innerHTML = `<div style="padding:10px; color:var(--error-text);">Error loading saved tests.</div>`; allSavedTestsData = []; }); }
        function renderAllTestsList(tests) { allTestsListContainer.innerHTML = ''; if (!currentUser) { allTestsListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);">Login to see tests.</div>'; return; } if (tests.length === 0) { allTestsListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);">No saved tests found.</div>'; } else { tests.forEach(testData => { const item = document.createElement('div'); item.classList.add('test-list-item'); item.dataset.reviewId = testData.id; const title = testData.testTitle || '(Untitled Test)'; const date = testData.savedAt?.toDate ? testData.savedAt.toDate().toLocaleString() : 'Unknown date'; const score = testData.summary?.score || 'N/A'; const hasReattemptData = testData.originalMCQs?.length > 0 && testData.originalMCQs.every(q => q?.question && q.options && q.answer && q.explanation); const infoDiv = document.createElement('div'); infoDiv.classList.add('test-item-info'); const titleSpan = document.createElement('span'); titleSpan.classList.add('test-item-title'); titleSpan.textContent = title; titleSpan.title = title; const detailSpan = document.createElement('span'); detailSpan.classList.add('test-item-details'); detailSpan.textContent = `Saved: ${date} | Score: ${score}`; const controlsDiv = document.createElement('div'); controlsDiv.classList.add('test-item-controls'); const editButton = document.createElement('button'); editButton.innerHTML = EDIT_TEST_ICON; editButton.title = "Edit title"; editButton.dataset.action = "edit-title"; controlsDiv.appendChild(editButton); const deleteButton = document.createElement('button'); deleteButton.innerHTML = DELETE_TEST_ICON; deleteButton.title = "Delete test"; deleteButton.dataset.action = "delete-test"; controlsDiv.appendChild(deleteButton); infoDiv.appendChild(titleSpan); infoDiv.appendChild(detailSpan); infoDiv.appendChild(controlsDiv); const actionsDiv = document.createElement('div'); actionsDiv.classList.add('test-item-actions'); const viewButton = document.createElement('button'); viewButton.textContent = "Details"; viewButton.dataset.action = "view"; actionsDiv.appendChild(viewButton); const reattemptSelect = document.createElement('select'); reattemptSelect.dataset.action = "reattempt"; reattemptSelect.disabled = !hasReattemptData; reattemptSelect.title = hasReattemptData ? "Reattempt test" : "Reattempt data not available"; reattemptSelect.innerHTML = `<option value="" selected>${hasReattemptData ? 'Reattempt...' : 'N/A'}</option> <option value="mistaked" ${!hasReattemptData?'disabled':''}>Mistaked Only</option> <option value="skipped" ${!hasReattemptData?'disabled':''}>Skipped Only</option> <option value="both" ${!hasReattemptData?'disabled':''}>Mistaked/Skipped</option> <option value="full" ${!hasReattemptData?'disabled':''}>Full Test</option>`; reattemptSelect.addEventListener('change', (e) => { const selectedMode = e.target.value; if (selectedMode) { const reviewId = e.target.closest('.test-list-item')?.dataset.reviewId; if (reviewId) { startReattempt(reviewId, selectedMode); } e.target.value = ""; } }); actionsDiv.appendChild(reattemptSelect); item.appendChild(infoDiv); item.appendChild(actionsDiv); allTestsListContainer.appendChild(item); }); } }
        function filterTestsInSidebar() { const searchTerm = testSearchInput.value.toLowerCase().trim(); const items = allTestsListContainer.querySelectorAll('.test-list-item'); let visibleCount = 0; const noResultsMsg = allTestsListContainer.querySelector('.no-search-results'); if (noResultsMsg) { noResultsMsg.remove(); } items.forEach(item => { const title = item.querySelector('.test-item-title')?.textContent.toLowerCase() || ''; const details = item.querySelector('.test-item-details')?.textContent.toLowerCase() || ''; const isMatch = title.includes(searchTerm) || details.includes(searchTerm); item.classList.toggle('hidden-by-search', !isMatch); if (isMatch) visibleCount++; }); if (visibleCount === 0 && searchTerm !== '' && items.length > 0) { const msgDiv = document.createElement('div'); msgDiv.textContent = "No saved tests match your search."; msgDiv.classList.add('no-search-results'); allTestsListContainer.appendChild(msgDiv); } }
        async function handleAllTestsListClick(event) { const button = event.target.closest('button[data-action], select[data-action]'); if (!button || button.tagName === 'SELECT') return; const action = button.dataset.action; const listItem = button.closest('.test-list-item'); const reviewId = listItem?.dataset.reviewId; if (!reviewId) { console.error("Could not find review ID for action:", action); return; } switch (action) { case "view": const reviewData = allSavedTestsData.find(t => t.id === reviewId); if (reviewData) { reviewResultsCache = reviewData; switchView('review', true); displayReview(reviewData); } else { alert("Error: Could not find review data to display."); } break; case "edit-title": enterTestTitleEditMode(listItem, reviewId); break; case "delete-test": const testTitle = listItem.querySelector('.test-item-title')?.textContent || 'this test'; if (confirm(`Are you sure you want to delete the test "${testTitle}"?`)) { deleteSavedTest(reviewId, listItem); } break; } }
        function enterTestTitleEditMode(listItem, reviewId) { const infoDiv = listItem.querySelector('.test-item-info'); const titleSpan = infoDiv.querySelector('.test-item-title'); const detailSpan = infoDiv.querySelector('.test-item-details'); const controlsDiv = infoDiv.querySelector('.test-item-controls'); const currentTitle = titleSpan.textContent; titleSpan.style.display = 'none'; detailSpan.style.display = 'none'; if(controlsDiv) controlsDiv.style.display = 'none'; if (infoDiv.querySelector('.test-item-edit-mode')) return; const editContainer = document.createElement('div'); editContainer.classList.add('test-item-edit-mode'); const input = document.createElement('input'); input.type = 'text'; input.value = currentTitle; input.maxLength = 100; input.addEventListener('keydown', (e) => { if (e.key === 'Enter') { saveTestTitle(listItem, reviewId, input.value); } else if (e.key === 'Escape') { exitTestTitleEditMode(listItem, currentTitle); } }); const saveButton = document.createElement('button'); saveButton.textContent = 'Save'; saveButton.onclick = () => saveTestTitle(listItem, reviewId, input.value); const cancelButton = document.createElement('button'); cancelButton.textContent = 'Cancel'; cancelButton.onclick = () => exitTestTitleEditMode(listItem, currentTitle); editContainer.appendChild(input); editContainer.appendChild(saveButton); editContainer.appendChild(cancelButton); infoDiv.appendChild(editContainer); input.focus(); input.select(); }
        function exitTestTitleEditMode(listItem, originalTitle = null) { const infoDiv = listItem.querySelector('.test-item-info'); const titleSpan = infoDiv.querySelector('.test-item-title'); const detailSpan = infoDiv.querySelector('.test-item-details'); const controlsDiv = infoDiv.querySelector('.test-item-controls'); const editContainer = infoDiv.querySelector('.test-item-edit-mode'); if (editContainer) editContainer.remove(); if (originalTitle !== null && titleSpan) { titleSpan.textContent = originalTitle; titleSpan.title = originalTitle; } if(titleSpan) titleSpan.style.display = ''; if(detailSpan) detailSpan.style.display = ''; if(controlsDiv) controlsDiv.style.display = ''; }
        async function saveTestTitle(listItem, reviewId, newTitle) { const trimmedTitle = newTitle.trim(); if (!trimmedTitle) { alert("Test title cannot be empty."); return; } if (trimmedTitle.length > 100) { alert("Test title is too long (max 100 characters)."); return; } const docRef = db.collection('testReviews').doc(reviewId); try { await docRef.update({ testTitle: trimmedTitle }); console.log("Test title updated successfully:", reviewId); const titleSpan = listItem.querySelector('.test-item-title'); if (titleSpan) { titleSpan.textContent = trimmedTitle; titleSpan.title = trimmedTitle; } const testIndex = allSavedTestsData.findIndex(t => t.id === reviewId); if (testIndex > -1) allSavedTestsData[testIndex].testTitle = trimmedTitle; exitTestTitleEditMode(listItem); } catch (error) { console.error("Error updating test title:", error); alert("Failed to update test title."); } }
        async function deleteSavedTest(reviewId, listItem) { if (!currentUser || !reviewId) return; listItem.style.opacity = '0.5'; listItem.style.pointerEvents = 'none'; const docRef = db.collection('testReviews').doc(reviewId); try { await docRef.delete(); console.log("Saved test deleted successfully:", reviewId); allSavedTestsData = allSavedTestsData.filter(t => t.id !== reviewId); alert("Saved test deleted."); } catch (error) { console.error("Error deleting saved test:", error); alert("Failed to delete saved test."); listItem.style.opacity = '1'; listItem.style.pointerEvents = 'auto'; } }
        async function startReattempt(reviewId, mode) { console.log(`Attempting reattempt for review ID: ${reviewId}, Mode: ${mode}`); const reviewData = allSavedTestsData.find(t => t.id === reviewId); if (!reviewData) { alert("Error: Could not find the saved review data for reattempt."); return; } const originalMCQs = reviewData.originalMCQs; const hasValidData = originalMCQs?.length > 0 && originalMCQs.every(q => q?.question && q.options && q.answer && q.explanation); if (!hasValidData) { alert("Error: Cannot reattempt. Original test data is missing or invalid."); return; } const summaryQuestions = reviewData.questions || []; let questionsForReattempt = []; switch (mode) { case 'mistaked': questionsForReattempt = originalMCQs.filter((mcq, index) => summaryQuestions[index]?.status === 'incorrect'); break; case 'skipped': questionsForReattempt = originalMCQs.filter((mcq, index) => summaryQuestions[index]?.status === 'skipped'); break; case 'both': questionsForReattempt = originalMCQs.filter((mcq, index) => summaryQuestions[index]?.status === 'incorrect' || summaryQuestions[index]?.status === 'skipped'); break; case 'full': default: questionsForReattempt = [...originalMCQs]; break; } if (questionsForReattempt.length === 0) { alert(`No questions found for the selected reattempt mode ('${mode}').`); return; } const originalTitle = reviewData.testTitle || 'Test'; const reattemptTitle = `${originalTitle} (Reattempt: ${mode})`; startMockTest(questionsForReattempt, reattemptTitle); }


    </script>

</body>
</html>
