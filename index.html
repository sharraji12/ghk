<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Version Updated -->
    <title>Gemini Chat + Mock Test (v10.3 - Token Limits, Tests Popup, Pin)</title>
    <script>
        // MathJax Configuration
        window.MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']], displayMath: [['$$', '$$'], ['\\[', '\\]']] },
            svg: { fontCache: 'global' },
            options: { skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
    <!-- <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-storage-compat.js"></script> -->

    <!-- Google Generative AI SDK (Loaded as Module) -->
    <script type="module">
        // Make SDK accessible globally after import
        try {
            // ***** TAMIL *****
            // இங்க Google Generative AI SDK-ஐ import செய்கிறோம். இதுதான் Gemini API உடன் பேச உதவும்.
            const { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold } = await import("https://esm.run/@google/generative-ai");
            window.GoogleGenerativeAI = GoogleGenerativeAI;
            // பாதுகாப்பு அமைப்புகளையும் import செய்கிறோம்
            window.HarmCategory = HarmCategory;
            window.HarmBlockThreshold = HarmBlockThreshold;
            console.log("GoogleGenerativeAI SDK loaded successfully via module.");
            // SDK load ஆனதும் ஒரு event-ஐ trigger செய்கிறோம்.
            window.dispatchEvent(new Event('google-ai-sdk-loaded'));
        } catch (error) {
            console.error("Failed to load GoogleGenerativeAI SDK:", error);
            // பிழை ஏற்பட்டால் console-ல் காட்டுவதோடு, ஒரு global variable-ல் store செய்கிறோம்.
            window.googleAiSdkLoadError = error;
        }
    </script>

    <!-- Prism JS for Code Syntax Highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>


    <style>
        /* --- Styles (v10.3 - Added Sidebar Pin Styles) --- */
        :root {
            /* ... (Theme Variables remain the same) ... */
             --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; --sidebar-width: 260px; --sidebar-collapsed-width: 15px; --message-font-size-base: 1rem;
            /* LIGHT */ --sidebar-bg: #f7f7f7; --main-bg: #ffffff; --input-bg: #ffffff; --border-color: #e0e0e0; --text-primary: #2c2c2c; --text-secondary: #5f5f5f; --text-placeholder: #999999; --accent-color: #d97a7a; --user-message-bg: #cce0ff; --user-message-text: #1c1c1c; --ai-message-bg: #f0f0f0; --ai-message-text: #2c2c2c; --button-bg: #f0f0f0; --button-hover-bg: #e0e0e0; --active-item-bg: #e0e0e0; --code-bg: #e8e8e8; --scrollbar-thumb: #ccc; --scrollbar-thumb-hover: #bbb; --app-outer-bg: #e8e8e8; --send-button-bg: var(--accent-color); --send-button-hover-bg: #c76b6b; --send-button-text: #ffffff; --error-bg: #ffebee; --error-text: #c62828; --error-border: #ef9a9a; --message-font-size: var(--message-font-size-base); --delete-button-color: #aaa; --delete-button-hover-color: #dc3545; --input-border-color: var(--border-color); --input-focus-border-color: var(--accent-color); --preview-bg: var(--button-bg); --preview-border: var(--border-color); --remove-btn-color: var(--text-secondary); --remove-btn-hover-color: var(--error-text);
            /* Audio Specific */ --record-button-bg: #ff6b6b; --record-button-text: #ffffff; --stop-button-bg: #4a4a4a; --stop-button-text: #ffffff;
            /* Model Selector Specific */ --selector-bg: var(--input-bg); --selector-border: var(--border-color); --selector-text: var(--text-secondary);
            /* Pin Button */ --pin-button-color: var(--text-secondary); --pin-button-hover-color: var(--text-primary);
        }
        body.dark-theme {
            /* ... (Dark Theme Variables remain the same) ... */
             --sidebar-bg: #2a2a2e; --main-bg: #1e1e1e; --input-bg: #2a2a2e; --border-color: #404040; --text-primary: #e0e0e0; --text-secondary: #a0a0a0; --text-placeholder: #777777; --accent-color: #e58b8b; --user-message-bg: #3a4a6b; --user-message-text: #e8e8e8; --ai-message-bg: #333333; --ai-message-text: #e0e0e0; --button-bg: #404040; --button-hover-bg: #505050; --active-item-bg: #454545; --code-bg: #2c2c2e; --scrollbar-thumb: #555; --scrollbar-thumb-hover: #666; --app-outer-bg: #121212; --send-button-bg: var(--accent-color); --send-button-hover-bg: #f09f9f; --send-button-text: #1e1e1e; --error-bg: #5c2b2b; --error-text: #ffcdd2; --error-border: #8c4343; --delete-button-color: #666; --delete-button-hover-color: #f09f9f; --input-border-color: var(--border-color); --input-focus-border-color: var(--accent-color); --preview-bg: var(--button-bg); --preview-border: var(--border-color); --remove-btn-color: var(--text-secondary); --remove-btn-hover-color: var(--error-text);
            /* Audio Specific */ --record-button-bg: #ff8787; --record-button-text: #1e1e1e; --stop-button-bg: #777777; --stop-button-text: #e0e0e0;
            /* Model Selector Specific */ --selector-bg: var(--input-bg); --selector-border: var(--border-color); --selector-text: var(--text-secondary);
             /* Pin Button */ --pin-button-color: var(--text-secondary); --pin-button-hover-color: var(--text-primary);
        }
        body { font-family: var(--font-family); margin: 0; padding: 0; background-color: var(--app-outer-bg); color: var(--text-primary); font-size: 15px; transition: background-color 0.3s ease, color 0.3s ease; }

        /* Layout & Structure */
        .app-container { display: flex; height: 100vh; width: 100vw; overflow: hidden; }
        .app-container.hidden { display: none; }
        .sidebar { width: var(--sidebar-width); background-color: var(--sidebar-bg); border-right: 1px solid var(--border-color); display: flex; flex-direction: column; padding: 15px 0; box-sizing: border-box; flex-shrink: 0; transition: background-color 0.3s ease, border-color 0.3s ease, width 0.3s ease, transform 0.3s ease; position: relative; z-index: 10; /* Ensure sidebar overlaps slightly */ }
        /* Sidebar Pinning Styles */
        .sidebar.unpinned { width: var(--sidebar-width); /* Keep full width initially */ }
        .sidebar.unpinned.collapsed { width: var(--sidebar-collapsed-width); /* Collapse when not hovered */ padding-left: 0; padding-right: 0; overflow: hidden; border-right-width: 0px; }
        .sidebar.unpinned.collapsed:hover { width: var(--sidebar-width); /* Expand on hover */ overflow: visible; z-index: 11; /* Bring to front on hover */ padding-left: initial; /* Reset padding */ padding-right: initial; border-right-width: 1px; }
        .sidebar.unpinned.collapsed > *:not(.sidebar-hover-handle) { /* Hide content when collapsed */ display: none; }
        .sidebar.unpinned.collapsed:hover > * { /* Show content on hover */ display: flex; /* Or initial display type */ }
        /* Optional: Adjust main content margin when sidebar is collapsed (if needed) */
        /* .main-container.sidebar-unpinned-collapsed { margin-left: var(--sidebar-collapsed-width); } */

        .main-container { flex-grow: 1; display: flex; flex-direction: column; height: 100vh; overflow: hidden; position: relative; transition: margin-left 0.3s ease; /* Animate margin */ }
        .main-content, .review-view { display: none; flex-direction: column; background-color: var(--main-bg); height: 100%; width: 100%; overflow: hidden; transition: background-color 0.3s ease; }
        .main-content.active, .review-view.active { display: flex; }
        .chat-area { flex-grow: 1; overflow-y: auto; padding: 30px 10% 20px; display: flex; flex-direction: column; max-width: 800px; margin: 0 auto; width: 80%; }
        .input-container { padding: 15px 10% 20px; border-top: 1px solid var(--border-color); background-color: var(--input-bg); max-width: 800px; margin: 0 auto; width: 80%; transition: background-color 0.3s ease, border-color 0.3s ease; display: none; }

        /* Sidebar Elements */
         .sidebar-header { display: flex; justify-content: space-between; align-items: center; padding: 10px 15px; /* Adjusted padding */ font-size: 1.1em; font-weight: 600; color: var(--text-primary); }
         .sidebar-header span { flex-grow: 1; margin-left: 5px; }
         #pin-sidebar-button, #show-tests-button { background: none; border: none; color: var(--pin-button-color); cursor: pointer; font-size: 1.3em; padding: 0 5px; line-height: 1; transition: color 0.2s ease; opacity: 0.8; }
         #pin-sidebar-button:hover, #show-tests-button:hover { color: var(--pin-button-hover-color); opacity: 1; }
         #show-tests-button { font-size: 0.9em; padding: 4px 8px; background-color: var(--button-bg); border: 1px solid var(--border-color); border-radius: 4px; margin-left: auto; /* Pushes it right */ }
         #show-tests-button:hover { background-color: var(--button-hover-bg); }

         .sidebar-section { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; margin-top: 10px; }
         .sidebar-section-title { padding: 5px 20px; font-size: 0.85em; font-weight: 600; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px; flex-shrink: 0; }
         /* Test list styles moved to tests.html */
         .start-chat-button { display: flex; align-items: center; gap: 8px; background-color: var(--main-bg); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 8px; padding: 10px 15px; margin: 0 15px 10px 15px; font-size: 0.95em; font-weight: 500; cursor: pointer; text-align: left; transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease; flex-shrink: 0; }
         .start-chat-button:hover { background-color: var(--button-hover-bg); } .start-chat-button svg { fill: currentColor; width: 16px; height: 16px; }
         .start-chat-button:disabled { opacity: 0.6; cursor: not-allowed; }
         .chat-list { overflow-y: auto; padding: 0 15px; margin-bottom: 10px; flex-grow: 1; }
         .chat-list::-webkit-scrollbar { width: 6px; } .chat-list::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 3px;} .chat-list::-webkit-scrollbar-thumb:hover { background: var(--scrollbar-thumb-hover); }
         .chat-list-item { padding: 8px 30px 8px 10px; margin-bottom: 4px; border-radius: 6px; font-size: 0.9em; cursor: pointer; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-secondary); transition: background-color 0.2s ease, color 0.2s ease; position: relative; }
         .chat-list-item:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
         .chat-list-item.active { background-color: var(--active-item-bg); color: var(--text-primary); font-weight: 500; }
         .delete-chat-button { position: absolute; right: 6px; top: 50%; transform: translateY(-50%); width: 18px; height: 18px; background: none; border: none; color: var(--delete-button-color); cursor: pointer; font-size: 1.3em; line-height: 1; padding: 0; display: none; opacity: 0.7; transition: color 0.2s ease, opacity 0.2s ease; }
         .chat-list-item:hover .delete-chat-button { display: block; }
         .delete-chat-button:hover { color: var(--delete-button-hover-color); opacity: 1; }
         .sidebar-footer { border-top: 1px solid var(--border-color); padding: 10px 15px; transition: border-color 0.3s ease; flex-shrink: 0; }
         .sidebar-controls { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; flex-wrap: wrap; gap: 10px;} /* Added wrap and gap */
         .text-size-controls, .theme-toggle { display: flex; align-items: center; gap: 5px; }
         .text-size-controls span, .theme-toggle span { font-size: 0.85em; color: var(--text-secondary); }
         .text-size-buttons button, .theme-toggle button { background: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 4px; padding: 2px 8px; cursor: pointer; font-size: 1.1em; line-height: 1; transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease; }
         .text-size-buttons button:hover, .theme-toggle button:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
         .text-size-buttons button:disabled, .theme-toggle button:disabled { opacity: 0.6; cursor: not-allowed; }

         /* Model Selector Styling */
         .model-selector-container { margin-top: 10px; width: 100%; }
         .model-selector-container label { font-size: 0.85em; color: var(--text-secondary); display: block; margin-bottom: 4px; }
         #model-selector { width: 100%; padding: 6px 8px; border: 1px solid var(--selector-border); background-color: var(--selector-bg); color: var(--selector-text); border-radius: 6px; font-size: 0.85em; -webkit-appearance: none; appearance: none; background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23${'var(--text-secondary)'.substring(4, 10)}%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.4-12.8z%22%2F%3E%3C%2Fsvg%3E'); background-repeat: no-repeat; background-position: right 8px top 50%; background-size: .65em auto; }
         #model-selector:disabled { opacity: 0.6; cursor: not-allowed; background-color: var(--button-bg); }
         #model-selector:focus { outline: none; border-color: var(--input-focus-border-color); }

         .account-info { display: flex; align-items: center; gap: 10px; font-size: 0.9em; margin-top: 10px; }
         .account-avatar { width: 30px; height: 30px; border-radius: 50%; background-color: #6c757d; color: white; display: flex; align-items: center; justify-content: center; font-weight: 600; }
         .account-details { overflow: hidden; }
         .account-email { font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-primary); }
         .account-plan { font-size: 0.85em; color: var(--text-secondary); }
         #auth-controls { margin-top: 15px; text-align: center; }
         #auth-controls button { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 8px 15px; cursor: pointer; font-size: 0.9em; transition: background-color 0.2s ease; }
         #auth-controls button:hover { background-color: var(--button-hover-bg); }
         #logout-btn { display: none; }

        /* Chat Area Elements */
        /* ... (Message, Code Block, etc styles remain the same) ... */
        .greeting { font-size: 1.8em; font-weight: 600; margin-bottom: 40px; color: var(--text-primary); } .greeting .asterisk { color: var(--accent-color); font-size: 1.2em; margin-right: 5px; display: inline-block; vertical-align: middle; }
        .message { padding: 12px 18px; border-radius: 18px; max-width: 80%; word-wrap: break-word; line-height: 1.6; margin-bottom: 15px; font-size: var(--message-font-size); transition: background-color 0.3s ease, color 0.3s ease; }
        .user-message { background-color: var(--user-message-bg); color: var(--user-message-text); align-self: flex-end; border-bottom-right-radius: 5px; }
        .ai-message { background-color: var(--ai-message-bg); color: var(--ai-message-text); align-self: flex-start; border-bottom-left-radius: 5px; }
        .ai-message strong { font-weight: 600; } .ai-message em { font-style: italic; }
        .ai-message pre { background-color: var(--code-bg); color: var(--text-primary); padding: 10px; border-radius: 4px; overflow-x: auto; font-size: 0.9em; transition: background-color 0.3s ease, color 0.3s ease; border: 1px solid var(--border-color); margin: 8px 0; position: relative; }
        .ai-message code { font-family: monospace; }
        .ai-message pre > code[class*="language-"] { display: block; padding: 0; background: none; text-shadow: none; color: inherit; }
        .ai-message:not(pre) > code { background-color: var(--code-bg); color: var(--text-primary); padding: 2px 4px; border-radius: 3px; transition: background-color 0.3s ease, color 0.3s ease; font-size: 0.9em; }
        .ai-message.thinking { background-color: transparent; color: var(--text-secondary); font-style: italic; }
        .error-message { background-color: var(--error-bg); color: var(--error-text); border: 1px solid var(--error-border); align-self: flex-start; transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;}
        .info-message { text-align: center; color: var(--text-secondary); padding: 50px 20px; font-style: italic; }
        .message .multi-media-indicator { font-size: 0.9em; color: var(--text-secondary); margin-top: 8px; display: block; font-style: italic;}
        .message mjx-container { color: inherit !important; font-size: inherit !important; }
        .message img.chat-image, .message img.uploaded-image { max-width: 100%; height: auto; border-radius: 8px; margin-top: 8px; cursor: pointer; display: block; }
        .message img.uploaded-image { border: 1px solid var(--border-color); margin-bottom: 5px; }
        .message .youtube-embed-container { margin-top: 10px; position: relative; padding-bottom: 56.25%; /* 16:9 Aspect Ratio */ height: 0; overflow: hidden; max-width: 100%; background: #000; border-radius: 8px; }
        .message iframe.chat-video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; }
        .message .chat-audio-player { margin-top: 10px; width: 100%; max-width: 350px; }
        .message .chat-audio-player audio { width: 100%; height: 40px; border-radius: 20px; }

        /* Input Area Elements */
        /* ... (Input, Buttons, Preview styles remain the same) ... */
        .suggestions { display: none; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; }
        .suggestion-chip { background-color: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 16px; padding: 8px 15px; font-size: 0.9em; cursor: pointer; transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease; }
        .suggestion-chip:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
        .input-box { display: flex; align-items: flex-end; background-color: var(--main-bg); border: 1px solid var(--input-border-color); border-radius: 12px; padding: 5px 5px 5px 15px; position: relative; transition: background-color 0.3s ease, border-color 0.3s ease; }
        .input-box:focus-within { border-color: var(--input-focus-border-color); }
        .input-buttons { display: flex; align-self: center; margin-right: 5px; gap: 3px; }
        #image-upload-button, #pdf-upload-button, #audio-upload-button, #record-audio-button { background: none; border: none; color: var(--text-secondary); cursor: pointer; font-size: 1.4em; padding: 0 4px; line-height: 1; transition: color 0.2s ease, opacity 0.2s ease; }
        #image-upload-button:hover, #pdf-upload-button:hover:not(:disabled), #audio-upload-button:hover, #record-audio-button:hover:not(.recording) { color: var(--text-primary); } /* Only hover if not disabled */
        #image-upload-button:disabled, #pdf-upload-button:disabled, #audio-upload-button:disabled, #record-audio-button:disabled:not(.recording) { opacity: 0.5; cursor: not-allowed; color: var(--text-secondary); }
        #record-audio-button.recording { color: var(--record-button-bg); animation: pulse 1.5s infinite; }
        #record-audio-button.recording:disabled { color: var(--stop-button-bg); opacity: 0.7; animation: none; cursor: default; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
        #user-input { flex-grow: 1; border: none; outline: none; padding: 10px 5px; font-size: 1rem; background-color: transparent; resize: none; min-height: 48px; max-height: 250px; line-height: 1.5; color: var(--text-primary); font-family: var(--font-family); }
        #user-input::placeholder { color: var(--text-placeholder); }
        #user-input:disabled { background-color: var(--button-bg); cursor: not-allowed; opacity: 0.7; } /* Style for disabled input */
        .mcq-mode-control { display: flex; align-items: center; margin-left: 10px; padding-bottom: 8px; flex-shrink: 0; }
        .mcq-mode-control input[type="checkbox"] { margin-right: 5px; accent-color: var(--accent-color); cursor: pointer;}
        .mcq-mode-control label { font-size: 0.85em; color: var(--text-secondary); cursor: pointer; user-select: none;}
        #send-button { background-color: var(--send-button-bg); color: var(--send-button-text); border: none; border-radius: 8px; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; cursor: pointer; margin-left: 10px; transition: background-color 0.2s ease; padding: 0; flex-shrink: 0; }
        #send-button:hover:not(:disabled) { background-color: var(--send-button-hover-bg); }
        #send-button:disabled { background-color: #cccccc; cursor: not-allowed; opacity: 0.6; }
        #send-button svg { width: 20px; height: 20px; fill: currentColor; }
        #media-preview-container { margin-bottom: 10px; padding: 8px; background-color: var(--preview-bg); border: 1px solid var(--preview-border); border-radius: 8px; display: none; flex-direction: column; gap: 8px; }
        #image-previews-list { display: flex; gap: 8px; flex-wrap: wrap; max-height: 120px; overflow-y: auto; }
        .pdf-preview-item { background-color: var(--main-bg); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; padding: 4px 8px; font-size: 0.85em; display: flex; align-items: center; gap: 6px; max-width: 100%; box-sizing: border-box; }
        .pdf-preview-item span { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex-grow: 1; }
        .pdf-preview-item button { background: none; border: none; color: var(--remove-btn-color); cursor: pointer; font-size: 1.1em; line-height: 1; padding: 0 2px; margin-left: 4px; flex-shrink: 0; }
        .pdf-preview-item button:hover { color: var(--remove-btn-hover-color); }
        .image-preview-item { position: relative; }
        .image-preview-item img { max-height: 50px; max-width: 80px; height: auto; width: auto; border-radius: 4px; object-fit: cover; display: block; border: 1px solid var(--border-color); }
        .remove-image-item-button { position: absolute; top: -5px; right: -5px; background-color: rgba(0, 0, 0, 0.6); color: white; border: none; border-radius: 50%; width: 16px; height: 16px; font-size: 10px; line-height: 16px; text-align: center; cursor: pointer; opacity: 0.8; transition: opacity 0.2s ease; }
        .remove-image-item-button:hover { opacity: 1; }
        #preview-audio-container { display: flex; align-items: center; gap: 8px; display: none; }
        #preview-audio-container audio { height: 30px; max-width: 250px; }
        .media-preview-footer { display: flex; align-items: center; width: 100%; }
        #media-preview-info { font-size: 0.85em; color: var(--text-secondary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex-grow: 1; }
        #remove-media-button { background: none; border: none; color: var(--remove-btn-color); cursor: pointer; font-size: 1.4em; line-height: 1; padding: 0 5px; transition: color 0.2s ease; margin-left: auto; flex-shrink: 0; }
        #remove-media-button:hover { color: var(--remove-btn-hover-color); }
        #recording-status { font-size: 0.85em; color: var(--text-secondary); margin-bottom: 5px; display: none; text-align: center; padding: 3px 0; }
        #recording-status.visible { display: block; }
        .thinking::after { content: ' .'; animation: dots 1s steps(3, end) infinite; display: inline-block; }
        @keyframes dots { 0%, 20% { content: ' .'; } 40% { content: ' ..'; } 60%, 100% { content: ' ...'; } }
        .start-test-button { background-color: var(--accent-color); color: var(--send-button-text); border: none; border-radius: 6px; padding: 8px 15px; margin-top: 10px; cursor: pointer; font-weight: 500; display: inline-block; transition: background-color 0.2s ease; }
        .start-test-button:hover { background-color: var(--send-button-hover-bg); }

        /* Mock Test & Review View Styles */
        /* ... (Test/Review styles remain the same) ... */
        .mock-test-view { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--main-bg); z-index: 100; flex-direction: column; padding: 20px; box-sizing: border-box; transition: background-color 0.3s ease; }
        .mock-test-view.active { display: flex; }
        .test-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); flex-shrink: 0; }
        .test-header h2 { margin: 0; font-size: 1.3em; color: var(--text-primary); }
        .test-info { display: flex; align-items: center; }
        .test-info span { margin-left: 15px; font-size: 0.95em; color: var(--text-secondary); }
        #test-language-toggle, #review-language-toggle { margin-left: 15px; padding: 3px 8px; font-size: 0.8em; cursor: pointer; background-color: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 4px; transition: background-color 0.2s ease, color 0.2s ease; }
        #test-language-toggle:hover, #review-language-toggle:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
        .test-content { flex-grow: 1; overflow-y: auto; padding: 10px 20px; }
        .test-question-container { margin-bottom: 25px; }
        .test-question-number { font-weight: bold; margin-bottom: 8px; color: var(--text-secondary); }
        .test-question { font-size: 1.1em; line-height: 1.5; margin-bottom: 15px; color: var(--text-primary); }
        .test-options label { display: block; margin-bottom: 12px; background-color: var(--button-bg); padding: 12px 15px; border-radius: 6px; border: 1px solid var(--border-color); cursor: pointer; transition: background-color 0.2s ease, border-color 0.2s ease; color: var(--text-primary); }
        .test-options label:hover { background-color: var(--button-hover-bg); }
        .test-options input[type="radio"] { margin-right: 10px; accent-color: var(--accent-color); cursor: pointer;}
        .test-navigation { display: flex; justify-content: space-between; padding-top: 15px; border-top: 1px solid var(--border-color); margin-top: auto; flex-shrink: 0; }
        .test-navigation button { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 10px 20px; cursor: pointer; font-size: 0.95em; transition: background-color 0.2s ease; }
        .test-navigation button:hover:not(:disabled) { background-color: var(--button-hover-bg); }
        .test-navigation button#submit-test-btn { background-color: var(--accent-color); color: var(--send-button-text); border-color: var(--accent-color); }
        .test-navigation button#submit-test-btn:hover:not(:disabled) { background-color: var(--send-button-hover-bg); }
        .test-navigation button:disabled { opacity: 0.5; cursor: not-allowed; }
        .review-view { padding: 20px; box-sizing: border-box; background-color: var(--main-bg); }
        .review-header { margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid var(--border-color); }
        .review-header h2 { margin: 0 0 10px 0; font-size: 1.3em; color: var(--text-primary); }
        .review-summary { display: inline; }
        .review-summary span { margin-right: 20px; font-size: 1em; color: var(--text-primary); }
        .review-summary .score-correct { color: #28a745; font-weight: bold;} .review-summary .score-incorrect { color: #dc3545; font-weight: bold;} .review-summary .score-skipped { color: #fd7e14; font-weight: bold;}
        .review-filters { margin-top: 10px; margin-bottom: 15px; }
        .review-filters button { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 5px 12px; margin-right: 8px; cursor: pointer; font-size: 0.9em; transition: background-color 0.2s ease, border-color 0.2s ease; }
        .review-filters button:hover { background-color: var(--button-hover-bg); }
        .review-filters button.active-filter { background-color: var(--accent-color); color: var(--send-button-text); border-color: var(--accent-color);}
        .review-content { flex-grow: 1; overflow-y: auto; padding-right: 10px; }
        .review-item { margin-bottom: 15px; padding: 15px; border: 1px solid var(--border-color); border-radius: 6px; background-color: var(--button-bg); transition: background-color 0.3s ease, border-color 0.3s ease; }
        .review-item.hidden-by-filter { display: none; }
        .review-item-qnum { font-weight: bold; margin-bottom: 8px; color: var(--text-secondary); }
        .review-item-question { margin-bottom: 10px; line-height: 1.5; color: var(--text-primary); }
        .review-item-details span { display: block; margin-bottom: 5px; font-size: 0.95em; color: var(--text-primary); }
        .review-item-details .correct-answer { color: #28a745; font-weight: bold; }
        .review-item-details .user-answer-correct { color: #28a745; } .review-item-details .user-answer-incorrect { color: #dc3545; text-decoration: line-through; } .review-item-details .user-answer-skipped { color: #fd7e14; font-style: italic; }
        .review-item-explanation { margin-top: 8px; font-size: 0.9em; color: var(--text-secondary); border-left: 3px solid var(--border-color); padding-left: 8px; line-height: 1.4; }
        .review-footer { text-align: center; padding-top: 20px; border-top: 1px solid var(--border-color); margin-top: auto; flex-shrink: 0; display: flex; justify-content: center; gap: 15px; }
        #exit-review-btn, #save-review-btn { background-color: var(--accent-color); color: var(--send-button-text); border: none; border-radius: 6px; padding: 10px 25px; cursor: pointer; font-size: 1em; transition: background-color 0.2s ease; display: none; }
        #exit-review-btn:hover, #save-review-btn:hover:not(:disabled) { background-color: var(--send-button-hover-bg); }
        #save-review-btn { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); }
        #save-review-btn:hover:not(:disabled) { background-color: var(--button-hover-bg); }
        #save-review-btn:disabled { opacity: 0.6; cursor: not-allowed; background-color: #cccccc; border-color: #aaaaaa; }

        /* Responsive Design */
        @media (max-width: 768px) {
            :root { --sidebar-width: 200px; --sidebar-collapsed-width: 10px;}
            .sidebar { padding: 10px 0; }
            /* Adjust pin behaviour on smaller screens if needed */
            .sidebar.unpinned.collapsed { width: var(--sidebar-collapsed-width); }
            .sidebar.unpinned.collapsed:hover { width: var(--sidebar-width); }

            .chat-area, .input-container { width: 95%; padding-left: 2.5%; padding-right: 2.5%; max-width: none; }
            .chat-area { padding-top: 15px; padding-bottom: 10px; }
            .input-container { padding-top: 10px; padding-bottom: 10px; }
            .message { max-width: 90%; font-size: calc(var(--message-font-size) * 0.95); }
            #image-upload-button, #pdf-upload-button, #audio-upload-button, #record-audio-button { font-size: 1.3em; padding: 0 3px; }
            #media-preview-container { padding: 6px; gap: 6px; }
            #image-previews-list { gap: 5px; max-height: 100px; }
            .pdf-preview-item { padding: 3px 6px; font-size: 0.8em; }
            .image-preview-item img { max-height: 40px; }
            .remove-image-item-button, .pdf-preview-item button { width: 14px; height: 14px; font-size: 9px; line-height: 14px; }
            #preview-audio-container audio { max-width: 180px; height: 28px; }
            #media-preview-info { font-size: 0.8em; }
            #remove-media-button { font-size: 1.3em; }
            .input-box { padding: 5px 5px 5px 10px; }
             #user-input { min-height: 40px; font-size: 0.95rem; }
             #send-button { width: 32px; height: 32px; }
             .mcq-mode-control label { font-size: 0.8em; }
            /* Responsive Sidebar Footer */
            .sidebar-footer { padding: 10px; }
            .sidebar-controls { flex-direction: column; align-items: flex-start; gap: 12px; }
            .model-selector-container { margin-top: 5px; }
            .account-info { margin-top: 15px; }
            #auth-controls { margin-top: 12px; }

            .mock-test-view, .review-view { padding: 10px; }
            .test-header, .review-header { margin-bottom: 15px; padding-bottom: 8px; flex-direction: column; align-items: flex-start; }
            .test-header h2, .review-header h2 { font-size: 1.1em; margin-bottom: 5px;}
            .test-info, .review-summary { margin-bottom: 5px; }
            .test-info span, .review-summary span { margin-left: 0; margin-right: 10px; font-size: 0.9em; display: inline-block; margin-bottom: 3px;}
            #test-language-toggle, #review-language-toggle { margin-left: 0; margin-top: 5px; font-size: 0.75em;}
            .test-content, .review-content { padding: 5px; }
            .test-question, .review-item-question { font-size: 1em; }
            .test-options label, .review-item { padding: 10px; font-size: 0.95em;}
            .review-filters { margin-top: 5px; }
            .review-filters button { padding: 4px 8px; font-size: 0.85em; margin-right: 5px;}
            .test-navigation, .review-footer { padding-top: 10px; }
            .test-navigation button, #exit-review-btn, #save-review-btn { padding: 8px 15px; font-size: 0.9em; }
        }
    </style>
</head>
<body>

    <div class="app-container" id="app-container">
        <!-- Sidebar -->
        <div class="sidebar" id="sidebar">
             <!-- ***** TAMIL ***** -->
             <!-- Sidebar header இப்போ pin button மற்றும் tests button-ஐயும் கொண்டுள்ளது -->
             <div class="sidebar-header">
                  <button id="pin-sidebar-button" title="Pin sidebar">📌</button>
                  <span>Gemini Chat</span>
                  <button id="show-tests-button" title="Show saved tests" disabled>Tests</button>
             </div>
             <!-- ***** TAMIL ***** -->
             <!-- All Tests section அகற்றப்பட்டது -->
             <!-- <div id="all-tests-section"> ... </div> -->

             <div class="sidebar-section">
                 <button class="start-chat-button" id="start-chat" disabled>
                      <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"></path></svg>
                      Start new chat
                 </button>
                 <div class="sidebar-section-title">Chats</div>
                 <div class="chat-list" id="chat-list">
                      <div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">Please log in to see chats.</div>
                 </div>
             </div>
             <div class="sidebar-footer">
                  <div class="sidebar-controls">
                      <div class="text-size-controls">
                          <span>Text Size</span>
                          <div class="text-size-buttons"> <button id="decrease-text-size" title="Decrease text size" disabled>-</button> <button id="increase-text-size" title="Increase text size" disabled>+</button> </div>
                      </div>
                      <div class="theme-toggle"> <button id="theme-toggle-button" title="Toggle Theme" disabled>☀️</button> </div>
                  </div>
                   <!-- Model Selector -->
                   <div class="model-selector-container">
                       <label for="model-selector">AI Model</label>
                       <select id="model-selector" disabled>
                            <!-- Options will be populated by JavaScript -->
                       </select>
                   </div>
                   <div id="auth-controls"> <button id="login-google-btn">Login with Google</button> <button id="logout-btn" style="display: none;">Logout</button> </div>
                   <div class="account-info">
                       <div class="account-avatar" id="account-avatar">?</div>
                       <div class="account-details"> <div class="account-email" id="account-email">Not logged in</div> <div class="account-plan" id="account-plan"></div> </div>
                   </div>
             </div>
        </div>

        <!-- Main container -->
        <div class="main-container" id="main-container">
            <div class="main-content active" id="main-content-chat">
                 <div class="chat-area" id="chat-area">
                     <!-- Greeting or Login Prompt -->
                 </div>
                 <div class="input-container" id="input-container">
                     <div class="suggestions" id="suggestions">
                          <button class="suggestion-chip" data-prompt="Summarize this document">Summarize this document</button>
                          <button class="suggestion-chip" data-prompt="Extract key points from this PDF">Extract key points from this PDF</button>
                          <button class="suggestion-chip" data-prompt="Describe this image">Describe this image</button>
                          <button class="suggestion-chip" data-prompt="Summarize this video">Summarize this video</button>
                     </div>
                    <div id="media-preview-container">
                        <div id="image-previews-list"></div>
                        <div id="preview-audio-container">
                           <audio id="preview-audio" controls></audio>
                        </div>
                        <div class="media-preview-footer">
                            <span id="media-preview-info"></span>
                            <button id="remove-media-button" title="Remove all media">&times;</button>
                        </div>
                    </div>
                    <div id="recording-status">Recording... <span>0s</span></div>
                    <div class="input-box">
                         <input type="file" id="image-upload-input" accept="image/*" style="display: none;" multiple>
                         <input type="file" id="pdf-upload-input" accept="application/pdf" style="display: none;" multiple>
                         <input type="file" id="audio-upload-input" accept="audio/wav, audio/mp3, audio/mpeg, audio/aac, audio/ogg, audio/flac, audio/aiff" style="display: none;">
                         <div class="input-buttons">
                             <button id="image-upload-button" title="Upload image(s)" disabled>📎</button>
                             <button id="pdf-upload-button" title="Upload PDF file(s)" disabled>📄</button>
                             <button id="audio-upload-button" title="Upload audio file" disabled>🎵</button>
                             <button id="record-audio-button" title="Record audio" disabled>🎙️</button>
                         </div>
                         <textarea id="user-input" placeholder="Enter prompt, attach media, or paste URL" rows="1" disabled></textarea>
                         <div class="mcq-mode-control"> <input type="checkbox" id="mcq-mode-checkbox" title="Generate MCQs based on prompt/media" disabled> <label for="mcq-mode-checkbox">MCQs?</label> </div>
                         <button id="send-button" title="Send message" disabled> <svg viewBox="0 0 24 24"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"></path></svg>
                        </button>
                    </div>
                 </div>
            </div>
            <!-- Review View -->
            <div class="review-view" id="review-view">
                 <div class="review-header">
                     <h2 id="review-title">Test Review</h2>
                     <div>
                         <div class="review-summary" id="review-summary"></div>
                      </div>
                     <div class="review-filters" id="review-filters" style="display: none;"> <button data-filter="all" class="active-filter">All</button> <button data-filter="incorrect">Incorrect</button> <button data-filter="skipped">Skipped</button> </div>
                 </div>
                 <div class="review-content" id="review-content"></div>
                 <div class="review-footer"> <button id="save-review-btn">Save Review</button> <button id="exit-review-btn">Back</button> </div>
              </div>
        </div>
    </div>
    <!-- Mock Test View -->
    <div class="mock-test-view" id="mock-test-view">
         <div class="test-header">
            <h2 id="test-title">Mock Test</h2>
            <div class="test-info">
                <span id="question-counter">Q: 1 / N</span>
                <span id="test-timer">Time: 00:00</span>
             </div>
         </div>
         <div class="test-content">
            <div class="test-question-container"> <div class="test-question-number" id="test-question-number"></div> <div class="test-question" id="test-question"></div> <div class="test-options" id="test-options"></div> </div>
         </div>
         <div class="test-navigation"> <button id="prev-question-btn" disabled>Previous</button> <button id="next-question-btn">Next</button> <button id="submit-test-btn">Submit Test</button> </div>
    </div>


    <script>
        // --- Firebase Config ---
        // ***** TAMIL *****
        // இது உங்கள் Firebase project-ன் configuration. இதை மாற்ற வேண்டாம்.
        const firebaseConfig = {
          apiKey: "AIzaSyDgw604fe5jnNu4kTOv1cQ-3n7PL8gcN58", // <- REPLACE IF NEEDED
          authDomain: "krish-c5db8.firebaseapp.com", // <- REPLACE IF NEEDED
          projectId: "krish-c5db8", // <- REPLACE IF NEEDED
          storageBucket: "krish-c5db8.appspot.com", // <- REPLACE IF NEEDED
          messagingSenderId: "217175257890", // <- REPLACE IF NEEDED
          appId: "1:217175257890:web:209f0f290eabab6b1fab7b", // <- REPLACE IF NEEDED
          measurementId: "G-97SHYGL2J4" // <- REPLACE IF NEEDED
        };

        // --- Initialize Firebase ---
        firebase.initializeApp(firebaseConfig);
        const fbAuth = firebase.auth();
        const db = firebase.firestore();

        // --- DOM Elements ---
        // ***** TAMIL *****
        // இங்க HTML-ல் உள்ள elements-ஐ JavaScript-ல் பயன்படுத்துவதற்காக variables-ல் store செய்கிறோம்.
        const appContainer = document.getElementById('app-container');
        const sidebar = document.getElementById('sidebar'); // Sidebar element
        const chatArea = document.getElementById('chat-area');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const suggestionsContainer = document.getElementById('suggestions');
        const startChatButton = document.getElementById('start-chat');
        const chatListContainer = document.getElementById('chat-list');
        // const allTestsSection = document.getElementById('all-tests-section'); // Removed
        // const testSearchInput = document.getElementById('test-search-input'); // Moved to tests.html
        // const allTestsListContainer = document.getElementById('all-tests-list'); // Moved to tests.html
        const showTestsButton = document.getElementById('show-tests-button'); // New button
        const pinSidebarButton = document.getElementById('pin-sidebar-button'); // New button
        const accountEmail = document.getElementById('account-email');
        const accountAvatar = document.getElementById('account-avatar');
        const accountPlan = document.getElementById('account-plan');
        const decreaseTextBtn = document.getElementById('decrease-text-size');
        const increaseTextBtn = document.getElementById('increase-text-size');
        const themeToggleButton = document.getElementById('theme-toggle-button');
        const modelSelector = document.getElementById('model-selector');
        const mainContainer = document.getElementById('main-container'); // Main container element
        const chatView = document.getElementById('main-content-chat');
        const testView = document.getElementById('mock-test-view');
        const reviewView = document.getElementById('review-view');
        const inputContainer = document.getElementById('input-container');
        const mcqModeCheckbox = document.getElementById('mcq-mode-checkbox');
        const loginBtn = document.getElementById('login-google-btn');
        const logoutBtn = document.getElementById('logout-btn');
        // Test & Review Elements
        const testTitle = document.getElementById('test-title');
        const questionCounter = document.getElementById('question-counter');
        const testTimer = document.getElementById('test-timer');
        const testQuestionNumber = document.getElementById('test-question-number');
        const testQuestion = document.getElementById('test-question');
        const testOptionsContainer = document.getElementById('test-options');
        const prevQuestionBtn = document.getElementById('prev-question-btn');
        const nextQuestionBtn = document.getElementById('next-question-btn');
        const submitTestBtn = document.getElementById('submit-test-btn');
        const reviewTitle = document.getElementById('review-title');
        const reviewSummary = document.getElementById('review-summary');
        const reviewContent = document.getElementById('review-content');
        const exitReviewBtn = document.getElementById('exit-review-btn');
        const reviewFilters = document.getElementById('review-filters');
        const saveReviewBtn = document.getElementById('save-review-btn');
        // Media Elements
        const imageUploadButton = document.getElementById('image-upload-button');
        const imageUploadInput = document.getElementById('image-upload-input');
        const pdfUploadButton = document.getElementById('pdf-upload-button');
        const pdfUploadInput = document.getElementById('pdf-upload-input');
        const audioUploadButton = document.getElementById('audio-upload-button');
        const audioUploadInput = document.getElementById('audio-upload-input');
        const recordAudioButton = document.getElementById('record-audio-button');
        // Media Preview Elements
        const mediaPreviewContainer = document.getElementById('media-preview-container');
        const imagePreviewsList = document.getElementById('image-previews-list');
        const previewAudioContainer = document.getElementById('preview-audio-container');
        const previewAudio = document.getElementById('preview-audio');
        const mediaPreviewInfo = document.getElementById('media-preview-info');
        const removeMediaButton = document.getElementById('remove-media-button');
        // Recording Status
        const recordingStatus = document.getElementById('recording-status');
        const recordingTimerSpan = recordingStatus.querySelector('span');

        // --- Config & Constants ---
        // ***** TAMIL *****
        // இங்க application-க்கான சில முக்கியமான மாறிலிகளை (constants) அமைக்கிறோம்.
        const AVAILABLE_MODELS = [
            { id: "gemini-1.5-flash-latest", name: "Gemini 1.5 Flash Latest", supportsCaching: false },
            { id: "gemini-1.5-pro-latest", name: "Gemini 1.5 Pro Latest", supportsCaching: false },
            { id: "gemini-2.0-flash", name: "Gemini 2.0 Flash (New)", supportsCaching: false }, // New model, assume no caching
            { id: "gemini-2.5-pro-exp-03-25", name: "Gemini 2.5 Pro Exp (New)", supportsCaching: false }, // New experimental, assume no caching
            { id: "gemini-1.5-flash-001", name: "Gemini 1.5 Flash 001 (Cache OK)", supportsCaching: true }, // Specific version for caching
            { id: "gemini-1.5-pro-001", name: "Gemini 1.5 Pro 001 (Cache OK)", supportsCaching: true }, // Specific version for caching
        ];
        const MODEL_OUTPUT_TOKENS = {
             "gemini-2.5-pro-exp-03-25": 65536, // Special case
             "default": 8192 // Default for others
        };
        const DEFAULT_MODEL_ID = AVAILABLE_MODELS[0].id;
        const STORAGE_KEY_API_KEY = 'geminiApiKey_insecureDemo';
        const STORAGE_KEY_MODEL_ID = 'geminiSelectedModelId';
        const STORAGE_KEY_SIDEBAR_PIN = 'geminiSidebarPinned'; // Key for sidebar pin state
        const NEW_CHAT_TITLE = "(New Chat)";
        const TEXT_SIZE_STEP = 0.1;
        const MIN_TEXT_SIZE_MULTIPLIER = 0.7;
        const MAX_TEXT_SIZE_MULTIPLIER = 1.5;
        const LIGHT_THEME_ICON = '☀️';
        const DARK_THEME_ICON = '🌙';
        const PIN_ICON = '📌'; // Material design pin icon (filled)
        const UNPIN_ICON = '&#xE140;'; // Material design pin icon (outline - using HTML entity)
        const DELETE_ICON = '×';
        const EDIT_TEST_ICON = '✏️'; // Moved here for tests.html access if needed
        const DELETE_TEST_ICON = '🗑️'; // Moved here for tests.html access if needed
        const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:watch\?v=|embed\/|v\/)|youtu\.be\/)([a-zA-Z0-9_-]{11})(?:\S+)?/i;
        const imageUrlRegex = /(?<!src=["'])(?<!href=["'])(https?:\/\/[^\s()<>]+?\.(?:jpg|jpeg|png|gif|webp|bmp))/gi;
        const MAX_IMAGE_SIZE_MB = 4; const MAX_TOTAL_IMAGE_SIZE_MB = 16; const MAX_IMAGE_COUNT = 5;
        const MAX_PDF_SIZE_MB = 50; const MAX_PDF_COUNT = 5; const MAX_AUDIO_SIZE_MB = 10;
        const SUPPORTED_AUDIO_MIMES = ['audio/wav', 'audio/mp3', 'audio/mpeg', 'audio/aiff', 'audio/aac', 'audio/ogg', 'audio/flac'];
        const RECORDING_TIME_LIMIT_SECONDS = 300;
        const FILE_API_POLLING_INTERVAL_MS = 5000;
        const FILE_API_PROCESSING_TIMEOUT_MS = 180000;
        const CACHE_TTL_SECONDS = 3600;
        const TESTS_POPUP_URL = 'tests.html'; // URL for the tests popup window

        // --- State Variables ---
        // ***** TAMIL *****
        // இங்க application-ன் நிலையை (state) track செய்ய variables-ஐ பயன்படுத்துகிறோம்.
        let API_KEY = '';
        let genAI = null;
        let HarmCategory = null;
        let HarmBlockThreshold = null;
        let currentUser = null;
        let activeChatId = null;
        let currentChatHistory = [];
        let selectedModelId = DEFAULT_MODEL_ID;
        let currentTextSizeMultiplier = 1.0;
        let currentTheme = 'light';
        let isSidebarPinned = true; // Default to pinned
        let isTestMode = false;
        let isReviewMode = false;
        let currentTestMCQs = [];
        let currentQuestionIndex = 0;
        let userAnswers = [];
        let testStartTime = null;
        let testTimerInterval = null;
        let reviewResultsCache = null;
        let cameFromAllTestsList = false; // Set when switching to review from tests popup
        let activeChatListener = null;
        let chatListListener = null;
        let testListListener = null; // Listener remains, but data used by popup
        let isDeletingChat = false;
        let allSavedTestsData = []; // Still needed for reattempts/details triggered from popup
        let selectedMediaItems = [];
        let nextMediaId = 0;
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;
        let recordingStartTime = null;
        let recordingTimerInterval = null;
        let recorderStream = null;
        let isAISdkReady = false;
        let currentMediaCacheName = null;
        let cachedMediaUris = [];
        let testsPopupWindow = null; // Reference to the tests popup window

        // --- Initialization ---
        initializeApp();

        // --- Event Listeners ---
        // ***** TAMIL *****
        // இங்க user actions-க்கு (click, input etc.) ஏற்ப functions-ஐ trigger செய்ய listeners-ஐ அமைக்கிறோம்.
        sendButton.addEventListener('click', handleSendMessage);
        userInput.addEventListener('input', autoGrowTextarea);
        userInput.addEventListener('keydown', handleInputKeydown);
        suggestionsContainer.addEventListener('click', handleSuggestionClick);
        startChatButton.addEventListener('click', createNewChat);
        chatListContainer.addEventListener('click', handleChatListClick);
        // allTestsListContainer.addEventListener('click', handleAllTestsListClick); // Moved to tests.html
        // testSearchInput.addEventListener('input', filterTestsInSidebar); // Moved to tests.html
        showTestsButton.addEventListener('click', showTestsWindow); // Listener for new tests button
        pinSidebarButton.addEventListener('click', toggleSidebarPin); // Listener for pin button
        decreaseTextBtn.addEventListener('click', () => adjustTextSize(-TEXT_SIZE_STEP));
        increaseTextBtn.addEventListener('click', () => adjustTextSize(TEXT_SIZE_STEP));
        themeToggleButton.addEventListener('click', toggleTheme);
        modelSelector.addEventListener('change', handleModelSelectionChange);
        prevQuestionBtn.addEventListener('click', () => handleTestNavigation('prev'));
        nextQuestionBtn.addEventListener('click', () => handleTestNavigation('next'));
        submitTestBtn.addEventListener('click', submitTest);
        exitReviewBtn.addEventListener('click', exitReview);
        chatArea.addEventListener('click', handleChatAreaClick);
        reviewFilters.addEventListener('click', handleReviewFilterClick);
        saveReviewBtn.addEventListener('click', saveTestReviewToCloud);
        loginBtn.addEventListener('click', signInWithGoogle);
        logoutBtn.addEventListener('click', signOut);
        // Media Listeners
        imageUploadButton.addEventListener('click', () => { if (!imageUploadButton.disabled) imageUploadInput.click(); });
        imageUploadInput.addEventListener('change', handleImageFileSelect);
        pdfUploadButton.addEventListener('click', () => { if (!pdfUploadButton.disabled) pdfUploadInput.click(); });
        pdfUploadInput.addEventListener('change', handlePdfFileSelect);
        audioUploadButton.addEventListener('click', () => { if (!audioUploadButton.disabled) audioUploadInput.click(); });
        audioUploadInput.addEventListener('change', handleAudioFileSelect);
        recordAudioButton.addEventListener('click', () => { if (!recordAudioButton.disabled || isRecording) { toggleRecording(); } });
        removeMediaButton.addEventListener('click', removeAllSelectedMedia);

        // Listen for SDK loaded event
        window.addEventListener('google-ai-sdk-loaded', () => {
            console.log("Caught 'google-ai-sdk-loaded' event.");
            isAISdkReady = true;
            HarmCategory = window.HarmCategory;
            HarmBlockThreshold = window.HarmBlockThreshold;
            if (API_KEY && !genAI) {
                 initializeGenAIInstance();
                 if(currentUser) { updateButtonStates(); }
            }
        });


        // --- Initialization Functions ---
        // ***** TAMIL *****
        // இந்த function app-ஐ ஆரம்பிக்கும்போது முதலில் run ஆகும்.
        async function initializeApp() {
            console.log("App Initializing (v10.3)...");
            setLoadingState(true, "Initializing...");
            chatArea.innerHTML = '';
            populateModelSelector();
            loadUserSettingsFromLocalStorage(); // Loads theme, text size, model, AND pin state
            applySidebarPinState(); // Apply pin state early
            await loadGeminiApiKey();
            fbAuth.onAuthStateChanged(handleAuthStateChange);
            switchView('chat');
            userInput.focus();
            console.log("App Initialization Complete.");
        }

        // populateModelSelector remains the same
        function populateModelSelector() {
            modelSelector.innerHTML = '';
            AVAILABLE_MODELS.forEach(model => {
                const option = document.createElement('option'); option.value = model.id; option.textContent = model.name;
                if (model.id === selectedModelId) { option.selected = true; }
                modelSelector.appendChild(option);
            });
            console.log("Model selector populated.");
        }

        // loadGeminiApiKey remains the same
        async function loadGeminiApiKey() {
             console.log("Attempting to load Gemini API Key...");
             API_KEY = localStorage.getItem(STORAGE_KEY_API_KEY);
             if(!API_KEY){
                 console.warn("!!! SECURITY WARNING !!! Using insecure API key storage...");
                 if(API_KEY){ localStorage.setItem(STORAGE_KEY_API_KEY, API_KEY); console.log("Using potentially hardcoded insecure API Key."); }
                 else { console.error("Gemini API Key is required."); displayMessage("Error: Gemini API Key is not configured...", 'ai', ['error-message']); API_KEY = ''; genAI = null; isAISdkReady = false; updateButtonStates(); return false; }
             } else { console.log("Loaded insecure API Key from localStorage."); }
             if (API_KEY && isAISdkReady && !genAI) { return initializeGenAIInstance(); }
             else if (API_KEY && !isAISdkReady) { console.log("API Key loaded, waiting for AI SDK..."); return true; }
             else { return !!API_KEY; }
        }

        // initializeGenAIInstance remains the same
        function initializeGenAIInstance() {
            if (!API_KEY || !isAISdkReady || !HarmCategory || !HarmBlockThreshold) { console.warn("Skipping genAI initialization. Conditions not met.", { API_KEY: !!API_KEY, isAISdkReady, HarmCategory: !!HarmCategory, HarmBlockThreshold: !!HarmBlockThreshold }); return false; }
            if (genAI) { genAI = null; console.log("Re-initializing genAI instance."); }
            console.log("Initializing GoogleGenerativeAI SDK instance...");
            try {
                 if (window.GoogleGenerativeAI) {
                     genAI = new window.GoogleGenerativeAI(API_KEY);
                     const supportsFiles = !!genAI?.files?.upload; const supportsCaching = !!genAI?.caching?.createCachedContent;
                     console.log(`SDK Instance created. File API: ${supportsFiles}, Caching API: ${supportsCaching}`);
                     if (!supportsFiles) { console.warn("WARNING: `genAI.files` is MISSING. File uploads might fail."); }
                     if (!supportsCaching) { console.warn("WARNING: `genAI.caching` is MISSING. Context Caching disabled."); }
                    return true;
                 } else { console.error("ERROR: GoogleGenerativeAI SDK constructor not found."); displayError("Error: AI SDK failed to initialize."); genAI = null; isAISdkReady = false; return false; }
            } catch (e) { console.error("CRITICAL ERROR initializing GoogleGenerativeAI:", e); displayError(`Critical Error initializing AI SDK: ${e.message}.`); API_KEY = ''; localStorage.removeItem(STORAGE_KEY_API_KEY); genAI = null; isAISdkReady = false; return false; }
            finally { updateButtonStates(); }
        }


        // --- Authentication Functions ---
        // signInWithGoogle, signOut remain the same
        async function signInWithGoogle() { const provider = new firebase.auth.GoogleAuthProvider(); try { setLoadingState(true, "Logging in..."); await fbAuth.signInWithPopup(provider); } catch (error) { console.error("Google Sign-In Error:", error); displayError(`Login failed: ${error.message || 'Unknown error'}`); setLoadingState(false); } }
        async function signOut() { try { setLoadingState(true, "Logging out..."); if (testsPopupWindow && !testsPopupWindow.closed) { testsPopupWindow.close(); testsPopupWindow = null; console.log("Closed tests popup window on logout."); } await fbAuth.signOut(); } catch (error) { console.error("Sign Out Error:", error); displayError(`Logout failed: ${error.message || 'Unknown error'}`); setLoadingState(false); } }

        // handleAuthStateChange: Updates tests button state
        // ***** TAMIL *****
        // User login/logout செய்யும்போது இந்த function run ஆகும். Sidebar pin state-ஐயும் load செய்யும்.
        function handleAuthStateChange(user) {
            console.log("Auth state changed. User:", user ? user.uid : 'None');
            setLoadingState(true, user ? "Loading user data..." : "Logging out...");

            // Clear previous state and listeners
            if (activeChatListener) { activeChatListener(); activeChatListener = null; }
            if (chatListListener) { chatListListener(); chatListListener = null; }
            if (testListListener) { testListListener(); testListListener = null; } // Stop listening here, popup will listen
            stopRecording(true);
            chatArea.innerHTML = '';
            chatListContainer.innerHTML = `<div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">${user ? 'Loading chats...' : 'Please log in...'}</div>`;
            // allTestsListContainer.innerHTML = ''; // Removed: No longer in main UI
            activeChatId = null; currentChatHistory = []; isDeletingChat = false; allSavedTestsData = [];
            currentMediaCacheName = null; cachedMediaUris = [];
            removeAllSelectedMedia();

            if (user) {
                currentUser = user; console.log("User logged in:", currentUser.uid);
                loginBtn.style.display = 'none'; logoutBtn.style.display = 'inline-block';
                accountEmail.textContent = currentUser.email || currentUser.displayName || `User`;
                accountAvatar.textContent = (currentUser.displayName || currentUser.email || 'U')[0].toUpperCase();
                accountPlan.textContent = "Firebase User";

                inputContainer.style.display = 'block';
                suggestionsContainer.style.display = 'flex';
                // allTestsSection.classList.add('visible'); // Removed

                loadUserSettings(currentUser.uid); // Loads theme, text size, model, pin state
                loadAndListenForChats(currentUser.uid);
                loadAndListenForTests(currentUser.uid); // Load test data for popup interaction
                renderGreetingOrLoginPrompt();

            } else {
                currentUser = null; console.log("User logged out");
                loginBtn.style.display = 'inline-block'; logoutBtn.style.display = 'none';
                accountEmail.textContent = "Not logged in"; accountAvatar.textContent = '?'; accountPlan.textContent = "";

                inputContainer.style.display = 'none';
                suggestionsContainer.style.display = 'none';
                // allTestsSection.classList.remove('visible'); // Removed

                renderGreetingOrLoginPrompt();
                // Reset settings visually
                currentTheme = 'light'; applyTheme();
                currentTextSizeMultiplier = 1.0; applyTextSize();
                selectedModelId = DEFAULT_MODEL_ID; applyModelSelection();
                isSidebarPinned = true; applySidebarPinState(); // Reset pin state to default (pinned)
            }

            updateButtonStates();
            setLoadingState(false);
        }

        // renderGreetingOrLoginPrompt remains the same
        function renderGreetingOrLoginPrompt() {
             chatArea.innerHTML = '';
             const greetingElement = document.createElement('div'); greetingElement.classList.add('greeting');
             if (currentUser) {
                 greetingElement.innerHTML = `<span class="asterisk">*</span>Good day, ${currentUser.displayName || 'User'}!`; chatArea.appendChild(greetingElement);
                 if (!activeChatId) { displayMessage("Select a chat from the list or start a new one.", 'ai'); }
                 else if (!API_KEY || !genAI) { displayMessage("API Key/SDK Error. AI features disabled.", 'ai', ['error-message']); }
                 else if (genAI && !genAI.files) { displayMessage("File API unavailable. PDF/Large File uploads disabled.", 'ai', ['error-message']); }
             } else {
                 greetingElement.innerHTML = `<span class="asterisk">*</span>Welcome!`; chatArea.appendChild(greetingElement);
                 displayMessage("Please log in with Google to use the chat and save your history.", 'ai');
             }
             scrollToBottom(true);
         }

        // --- Settings (Theme/Text Size/Model/Pin) ---
        // ***** TAMIL *****
        // இந்த functions theme, text size, model selection, sidebar pin state ஆகியவற்றை load/save செய்கின்றன.
        function loadUserSettingsFromLocalStorage() {
             const savedTheme = localStorage.getItem('chatTheme');
             const savedTextSize = localStorage.getItem('chatTextSizeMultiplier');
             const savedModelId = localStorage.getItem(STORAGE_KEY_MODEL_ID);
             const savedPinState = localStorage.getItem(STORAGE_KEY_SIDEBAR_PIN); // Load pin state

             currentTheme = savedTheme || 'light';
             currentTextSizeMultiplier = savedTextSize ? parseFloat(savedTextSize) : 1.0;
             selectedModelId = AVAILABLE_MODELS.some(m => m.id === savedModelId) ? savedModelId : DEFAULT_MODEL_ID;
             isSidebarPinned = savedPinState ? (savedPinState === 'true') : true; // Default to true if not found

             applyTheme();
             applyTextSize();
             applyModelSelection();
             applySidebarPinState(); // Apply pin state
        }
        async function loadUserSettings(userId) {
            const userDocRef = db.collection('users').doc(userId);
            try {
                const docSnap = await userDocRef.get();
                if (docSnap.exists) {
                    const settings = docSnap.data();
                    currentTheme = settings.theme || currentTheme;
                    currentTextSizeMultiplier = settings.textSizeMultiplier || currentTextSizeMultiplier;
                    const firestoreModelId = settings.selectedModelId;
                    selectedModelId = AVAILABLE_MODELS.some(m => m.id === firestoreModelId) ? firestoreModelId : selectedModelId;
                    isSidebarPinned = typeof settings.isSidebarPinned === 'boolean' ? settings.isSidebarPinned : isSidebarPinned; // Load pin state from FS
                    console.log("Loaded user settings from Firestore:", settings);
                } else { console.log("No user settings found in Firestore, using local/defaults."); }
            } catch (error) { console.error("Error loading user settings from Firestore:", error); }
            finally {
                applyTheme(); applyTextSize(); applyModelSelection(); applySidebarPinState(); // Apply pin state
            }
        }
        async function saveUserSettings() {
            localStorage.setItem('chatTheme', currentTheme);
            localStorage.setItem('chatTextSizeMultiplier', currentTextSizeMultiplier.toString());
            localStorage.setItem(STORAGE_KEY_MODEL_ID, selectedModelId);
            localStorage.setItem(STORAGE_KEY_SIDEBAR_PIN, isSidebarPinned.toString()); // Save pin state

            if (!currentUser) return;
            const userDocRef = db.collection('users').doc(currentUser.uid);
            const settings = {
                theme: currentTheme,
                textSizeMultiplier: currentTextSizeMultiplier,
                selectedModelId: selectedModelId,
                isSidebarPinned: isSidebarPinned // Save pin state to FS
            };
            try { await userDocRef.set(settings, { merge: true }); console.log("User settings saved to Firestore:", settings); }
            catch (error) { console.error("Error saving user settings to Firestore:", error); }
        }
        // applyTheme, toggleTheme, applyTextSize, adjustTextSize remain the same
        function applyTheme() { if(currentTheme==='dark'){ document.body.classList.add('dark-theme'); themeToggleButton.textContent=LIGHT_THEME_ICON; themeToggleButton.title="Switch to Light Theme"; } else { document.body.classList.remove('dark-theme'); themeToggleButton.textContent=DARK_THEME_ICON; themeToggleButton.title="Switch to Dark Theme"; } }
        function toggleTheme() { currentTheme = (currentTheme === 'light') ? 'dark' : 'light'; applyTheme(); saveUserSettings(); }
        function applyTextSize() { const newSize = `calc(var(--message-font-size-base) * ${currentTextSizeMultiplier})`; document.documentElement.style.setProperty('--message-font-size', newSize); updateButtonStates(); }
        function adjustTextSize(change) { let newMultiplier = Math.max(MIN_TEXT_SIZE_MULTIPLIER, Math.min(MAX_TEXT_SIZE_MULTIPLIER, currentTextSizeMultiplier + change)); newMultiplier = Math.round(newMultiplier * 10) / 10; if (newMultiplier !== currentTextSizeMultiplier) { currentTextSizeMultiplier = newMultiplier; applyTextSize(); saveUserSettings(); } }
        // applyModelSelection, handleModelSelectionChange remain the same
        function applyModelSelection() {
            if (modelSelector) { modelSelector.value = selectedModelId; console.log(`Applied model selection: ${selectedModelId}`); }
            const modelInfo = AVAILABLE_MODELS.find(m => m.id === selectedModelId);
            if (currentMediaCacheName && (!modelInfo || !modelInfo.supportsCaching)) { console.warn(`Model ${selectedModelId} doesn't support caching. Clearing cache state.`); currentMediaCacheName = null; cachedMediaUris = []; }
        }
        function handleModelSelectionChange(event) {
            const newModelId = event.target.value;
            if (newModelId !== selectedModelId) {
                selectedModelId = newModelId; applyModelSelection(); saveUserSettings();
                const modelInfo = AVAILABLE_MODELS.find(m => m.id === selectedModelId);
                if (modelInfo && !modelInfo.supportsCaching) { console.warn(`Selected model ${selectedModelId} does not support context caching.`); }
                else if (modelInfo && modelInfo.supportsCaching) { console.log(`Selected model ${selectedModelId} supports context caching.`); }
            }
        }
        // ***** TAMIL *****
        // Sidebar pin/unpin செய்வதற்கான functions.
        function applySidebarPinState() {
            if (isSidebarPinned) {
                sidebar.classList.remove('unpinned', 'collapsed');
                mainContainer.classList.remove('sidebar-unpinned-collapsed');
                pinSidebarButton.innerHTML = PIN_ICON;
                pinSidebarButton.title = "Unpin sidebar";
            } else {
                sidebar.classList.add('unpinned', 'collapsed'); // Start collapsed when unpinned
                mainContainer.classList.add('sidebar-unpinned-collapsed');
                pinSidebarButton.innerHTML = UNPIN_ICON;
                pinSidebarButton.title = "Pin sidebar";
            }
            console.log(`Sidebar pin state applied: ${isSidebarPinned ? 'Pinned' : 'Unpinned'}`);
        }
        function toggleSidebarPin() {
            isSidebarPinned = !isSidebarPinned;
            applySidebarPinState();
            saveUserSettings(); // Save the new state
        }


        // --- Chat Storage & Loading (Firestore) ---
        // loadAndListenForChats, renderSidebarChatList, highlightActiveChatInSidebar remain the same
        function loadAndListenForChats(userId) {
            if (chatListListener) { chatListListener(); chatListListener = null; }
            const chatsRef = db.collection('chats').where('userId', '==', userId).orderBy('lastUpdated', 'desc');
            chatListListener = chatsRef.onSnapshot(snapshot => {
                 if (isDeletingChat) { return; }
                const chats = []; snapshot.forEach(doc => { chats.push({ id: doc.id, ...doc.data() }); });
                renderSidebarChatList(chats);
                let chatToLoad = activeChatId;
                if (!chatToLoad || !chats.some(c => c.id === chatToLoad)) { chatToLoad = chats.length > 0 ? chats[0].id : null; }
                if (chatToLoad && chatToLoad !== activeChatId) { switchChat(chatToLoad); }
                else if (chatToLoad && chatToLoad === activeChatId) { highlightActiveChatInSidebar(); updateButtonStates(); setLoadingState(false); }
                else { activeChatId = null; currentChatHistory = []; if (activeChatListener) { activeChatListener(); activeChatListener = null; } renderGreetingOrLoginPrompt(); updateButtonStates(); setLoadingState(false); currentMediaCacheName = null; cachedMediaUris = []; }
            }, error => { console.error("Error listening for chats:", error); displayError("Could not load chat list."); chatListContainer.innerHTML = '<div style="padding:10px;color:var(--error-text);">Error loading chats.</div>'; setLoadingState(false); });
        }
        function renderSidebarChatList(chats) {
            chatListContainer.innerHTML = ''; if (!currentUser) { chatListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);">Please log in.</div>'; return; }
            if (chats.length === 0) { chatListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);">No chats yet. Start one!</div>'; }
            else { chats.forEach(chatData => { const itemElement = document.createElement('div'); itemElement.classList.add('chat-list-item'); let title = chatData.title; if (typeof title !== 'string' || !title.trim()) { title = '(Untitled Chat)'; } title = title.trim(); itemElement.textContent = title; itemElement.dataset.id = chatData.id; itemElement.title = title; const deleteBtn = document.createElement('button'); deleteBtn.classList.add('delete-chat-button'); deleteBtn.innerHTML = DELETE_ICON; deleteBtn.title = "Delete chat"; deleteBtn.dataset.id = chatData.id; itemElement.appendChild(deleteBtn); chatListContainer.appendChild(itemElement); }); }
            highlightActiveChatInSidebar();
        }
        function highlightActiveChatInSidebar() { const items = chatListContainer.querySelectorAll('.chat-list-item'); items.forEach(item => { item.classList.toggle('active', item.dataset.id === activeChatId); }); }


        // --- Media Handling Functions ---
        // handleImageFileSelect, handlePdfFileSelect, handleAudioFileSelect, displayMediaPreview,
        // renderImagePreviewItem, renderPdfPreviewItem, removeSelectedMediaItem, removeAllSelectedMedia
        // remain the same
         function handleImageFileSelect(event) {
            if (selectedMediaItems.length > 0 && selectedMediaItems.some(item => item.type === 'pdf' || item.type === 'audio')) { alert("Cannot select images with PDF(s)/audio."); imageUploadInput.value = ''; return; }
             if (youtubeRegex.test(userInput.value.trim())) { alert("Cannot upload images with a YouTube URL."); imageUploadInput.value = ''; return; }
            const files = event.target.files; if (!files || files.length === 0) { imageUploadInput.value = ''; return; }
            let currentCount = selectedMediaItems.filter(i => i.type === 'image').length; let added = 0; let totalSizeMB = selectedMediaItems.reduce((s, i) => s + (i.file?.size || 0), 0) / 1024 / 1024;
            const allowed = ['image/jpeg', 'image/png', 'image/webp', 'image/gif', 'image/bmp'];
            for (const file of files) {
                if (currentCount >= MAX_IMAGE_COUNT) { alert(`Max ${MAX_IMAGE_COUNT} images.`); break; }
                if (!allowed.includes(file.type)) { console.warn(`Skip type: ${file.name} (${file.type})`); continue; }
                const sizeMB = file.size / 1024 / 1024; if (sizeMB > MAX_IMAGE_SIZE_MB) { alert(`"${file.name}" > ${MAX_IMAGE_SIZE_MB}MB.`); continue; }
                if (totalSizeMB + sizeMB > MAX_TOTAL_IMAGE_SIZE_MB) { alert(`Adding "${file.name}" exceeds total ${MAX_TOTAL_IMAGE_SIZE_MB}MB.`); continue; }
                selectedMediaItems.push({ id: nextMediaId++, type: 'image', file: file, base64: null, mimeType: file.type, name: file.name }); currentCount++; totalSizeMB += sizeMB; added++;
            }
            if (added > 0) { displayMediaPreview(); } imageUploadInput.value = '';
        }
        function handlePdfFileSelect(event) {
            if (selectedMediaItems.length > 0 && selectedMediaItems.some(item => item.type === 'image' || item.type === 'audio')) { alert("Cannot select PDF(s) with image(s)/audio."); pdfUploadInput.value = ''; return; }
             if (youtubeRegex.test(userInput.value.trim())) { alert("Cannot upload PDFs with a YouTube URL."); pdfUploadInput.value = ''; return; }
             if (!genAI?.files) { alert("PDF upload disabled (File API unavailable)."); pdfUploadInput.value = ''; return; }
            const files = event.target.files; if (!files || files.length === 0) { pdfUploadInput.value = ''; return; }
            let currentCount = selectedMediaItems.filter(i => i.type === 'pdf').length; let added = 0;
            for (const file of files) {
                if (currentCount >= MAX_PDF_COUNT) { alert(`Max ${MAX_PDF_COUNT} PDFs.`); break; }
                if (file.type !== 'application/pdf') { console.warn(`Skip non-PDF: ${file.name} (${file.type})`); continue; }
                const sizeMB = file.size / 1024 / 1024; if (sizeMB > MAX_PDF_SIZE_MB) { alert(`PDF "${file.name}" (${sizeMB.toFixed(1)}MB) > ${MAX_PDF_SIZE_MB}MB (UI limit).`); console.warn(`Large PDF: ${sizeMB.toFixed(1)}MB`); }
                 selectedMediaItems.push({ id: nextMediaId++, type: 'pdf', file: file, name: file.name, mimeType: file.type }); currentCount++; added++;
            }
            if (added > 0) { displayMediaPreview(); } pdfUploadInput.value = '';
        }
        function handleAudioFileSelect(event) {
            if (selectedMediaItems.length > 0 && selectedMediaItems.some(item => item.type === 'image' || item.type === 'pdf')) { alert("Cannot select audio with image(s)/PDF(s)."); audioUploadInput.value = ''; return; }
             if (youtubeRegex.test(userInput.value.trim())) { alert("Cannot upload audio with a YouTube URL."); audioUploadInput.value = ''; return; }
            removeAllSelectedMedia(); const file = event.target.files[0]; if (!file) { audioUploadInput.value = ''; return; }
            if (!SUPPORTED_AUDIO_MIMES.includes(file.type)) { alert(`Unsupported audio type: ${file.type}.`); audioUploadInput.value = ''; return; }
            const sizeMB = file.size / 1024 / 1024; if (sizeMB > MAX_AUDIO_SIZE_MB) { alert(`Audio > ${MAX_AUDIO_SIZE_MB}MB.`); audioUploadInput.value = ''; return; }
            const reader = new FileReader();
            reader.onload = (e) => { selectedMediaItems = [{ id: nextMediaId++, type: 'audio', file: file, base64: e.target.result, mimeType: file.type, name: file.name }]; displayMediaPreview(); }
            reader.onerror = (error) => { console.error("Error reading audio:", error); alert("Error reading audio."); removeAllSelectedMedia(); };
            audioUploadInput.value = ''; reader.readAsDataURL(file);
        }
        function displayMediaPreview() {
            imagePreviewsList.innerHTML = ''; previewAudioContainer.style.display = 'none'; previewAudio.removeAttribute('src');
            mediaPreviewInfo.textContent = ''; imagePreviewsList.style.display = 'none'; imagePreviewsList.style.flexDirection = ''; imagePreviewsList.style.alignItems = '';
            if (selectedMediaItems.length === 0) { mediaPreviewContainer.style.display = 'none'; return; }
            const audioItem = selectedMediaItems.find(i => i.type === 'audio'); const imageItems = selectedMediaItems.filter(i => i.type === 'image'); const pdfItems = selectedMediaItems.filter(i => i.type === 'pdf'); let infoText = "";
            if (audioItem) { imagePreviewsList.style.display = 'none'; try { previewAudio.src = audioItem.base64; previewAudio.load(); previewAudioContainer.style.display = 'flex'; infoText = `1 audio: ${audioItem.name || 'Audio'}`; } catch (e) { infoText = 'Error audio preview'; } }
            else if (imageItems.length > 0) { previewAudioContainer.style.display = 'none'; imagePreviewsList.style.display = 'flex'; imagePreviewsList.style.flexDirection = 'row'; imagePreviewsList.style.alignItems = 'flex-start'; imageItems.forEach(item => { if (!item.base64) { const reader = new FileReader(); reader.onload = (e) => { item.base64 = e.target.result; renderImagePreviewItem(item); }; reader.onerror = () => { item.base64 = '#error'; renderImagePreviewItem(item); }; reader.readAsDataURL(item.file); } else { renderImagePreviewItem(item); } }); infoText = `${imageItems.length} image(s)`; }
            else if (pdfItems.length > 0) { previewAudioContainer.style.display = 'none'; imagePreviewsList.style.display = 'flex'; imagePreviewsList.style.flexDirection = 'column'; imagePreviewsList.style.alignItems = 'stretch'; pdfItems.forEach(item => renderPdfPreviewItem(item)); infoText = `${pdfItems.length} PDF(s)`; }
            mediaPreviewInfo.textContent = infoText; mediaPreviewContainer.style.display = 'flex';
        }
        function renderImagePreviewItem(item) {
             try { if (imagePreviewsList.querySelector(`[data-media-id="${item.id}"]`)) return; const itemCont = document.createElement('div'); itemCont.classList.add('image-preview-item'); itemCont.dataset.mediaId = item.id; const img = document.createElement('img'); img.src = item.base64 === '#error' ? '' : (item.base64 || ''); img.alt = item.base64 === '#error' ? 'Preview error' : (item.name || 'Image'); img.title = item.name || 'Image'; img.onerror = () => { img.alt = "Load error"; }; const remBtn = document.createElement('button'); remBtn.classList.add('remove-image-item-button'); remBtn.innerHTML = '&times;'; remBtn.title = `Remove ${item.name || 'image'}`; remBtn.onclick = (e) => { e.stopPropagation(); removeSelectedMediaItem(item.id); }; itemCont.appendChild(img); itemCont.appendChild(remBtn); imagePreviewsList.appendChild(itemCont); } catch (e) { console.error("Error image preview:", e); }
        }
        function renderPdfPreviewItem(item) {
             try { if (imagePreviewsList.querySelector(`[data-media-id="${item.id}"]`)) return; const itemCont = document.createElement('div'); itemCont.classList.add('pdf-preview-item'); itemCont.dataset.mediaId = item.id; const icon = document.createElement('span'); icon.textContent = '📄'; icon.style.marginRight = '4px'; const nameSpan = document.createElement('span'); nameSpan.textContent = item.name || 'PDF'; nameSpan.title = item.name || 'PDF'; const remBtn = document.createElement('button'); remBtn.innerHTML = '&times;'; remBtn.title = `Remove ${item.name || 'PDF'}`; remBtn.onclick = (e) => { e.stopPropagation(); removeSelectedMediaItem(item.id); }; itemCont.appendChild(icon); itemCont.appendChild(nameSpan); itemCont.appendChild(remBtn); imagePreviewsList.appendChild(itemCont); } catch (e) { console.error("Error PDF preview:", e); }
        }
        function removeSelectedMediaItem(mediaId) {
             selectedMediaItems = selectedMediaItems.filter(item => item.id !== mediaId); displayMediaPreview();
             if (currentMediaCacheName && !selectedMediaItems.some(i => i.type === 'pdf')) { console.log("Removed last PDF. Clearing cache state."); currentMediaCacheName = null; cachedMediaUris = []; }
        }
        function removeAllSelectedMedia() {
            stopRecording(true); selectedMediaItems = []; nextMediaId = 0; imagePreviewsList.innerHTML = ''; previewAudio.removeAttribute('src'); previewAudioContainer.style.display = 'none'; mediaPreviewContainer.style.display = 'none'; mediaPreviewInfo.textContent = ''; imagePreviewsList.style.flexDirection = ''; imagePreviewsList.style.alignItems = ''; imageUploadInput.value = ''; pdfUploadInput.value = ''; audioUploadInput.value = '';
            if (currentMediaCacheName) { console.log("All media removed. Clearing cache state."); currentMediaCacheName = null; cachedMediaUris = []; }
        }


        // --- Audio Recording Functions ---
        // toggleRecording, startRecording, stopRecording, resetRecordingUI remain the same
        async function toggleRecording() { if (isRecording) { stopRecording(); } else { if (selectedMediaItems.some(i => i.type === 'image' || i.type === 'pdf')) { alert("Cannot record with images/PDFs."); return; } if (youtubeRegex.test(userInput.value.trim())) { alert("Cannot record with a YouTube URL."); return; } if (sendButton.disabled && !isRecording) { const appReady = currentUser && API_KEY && genAI && activeChatId; if (!appReady || userInput.placeholder.includes("Generating") || userInput.placeholder.includes("Sending") || userInput.placeholder.includes("Uploading") || userInput.placeholder.includes("Recording")) { alert("Please wait or check login/API key/chat."); return; } } await startRecording(); } }
        async function startRecording() { if (selectedMediaItems.length > 0) { alert("Cannot record with other media."); return; } if (youtubeRegex.test(userInput.value.trim())) { alert("Cannot record with a YouTube URL."); return; } if (!navigator.mediaDevices?.getUserMedia) { alert("Audio recording not supported."); return; } try { if (recorderStream) { recorderStream.getTracks().forEach(t => t.stop()); recorderStream = null; } const stream = await navigator.mediaDevices.getUserMedia({ audio: true }); recorderStream = stream; recordAudioButton.disabled = true; let options = {}; const preferred = ['audio/ogg;codecs=opus', 'audio/webm;codecs=opus', 'audio/aac', 'audio/mp4']; for (const mime of preferred) { if (MediaRecorder.isTypeSupported(mime)) { options.mimeType = mime; break; } } mediaRecorder = new MediaRecorder(stream, options); const actualMime = mediaRecorder.mimeType; console.log("MediaRecorder init. Options:", options, "Actual:", actualMime); audioChunks = []; mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) { audioChunks.push(e.data); } }; mediaRecorder.onstop = () => { console.log("Recorder stopped. Chunks:", audioChunks.length); if (recorderStream) { recorderStream.getTracks().forEach(t => t.stop()); recorderStream = null; } isRecording = false; recordingStatus.classList.remove('visible'); recordAudioButton.classList.remove('recording'); recordAudioButton.textContent = '🎙️'; recordAudioButton.title = 'Record audio'; if (recordingTimerInterval) { clearInterval(recordingTimerInterval); recordingTimerInterval = null; } if (audioChunks.length === 0) { console.warn("No audio data."); setLoadingState(false); updateButtonStates(); return; } const blob = new Blob(audioChunks, { type: actualMime }); audioChunks = []; const sizeMB = blob.size / 1024 / 1024; console.log(`Blob size: ${sizeMB.toFixed(3)} MB, Type: ${actualMime}`); if (blob.size === 0) { alert("Recording failed: No data."); setLoadingState(false); updateButtonStates(); return; } if (sizeMB > MAX_AUDIO_SIZE_MB) { alert(`Audio > ${MAX_AUDIO_SIZE_MB}MB.`); setLoadingState(false); updateButtonStates(); return; } const reader = new FileReader(); setLoadingState(true, "Processing audio..."); reader.onloadend = () => { if (reader.result?.startsWith('data:')) { let finalMime = actualMime.split(';')[0]; selectedMediaItems = [{ id: nextMediaId++, type: 'audio', file: new File([blob], `rec.audio`, { type: finalMime }), base64: reader.result, mimeType: finalMime, name: `rec-${new Date().toISOString().substring(0, 19).replace(/[:T]/g, '-')}.${finalMime.split('/')[1] || 'audio'}` }]; displayMediaPreview(); } else { alert("Error processing audio."); } setLoadingState(false); updateButtonStates(); }; reader.onerror = (error) => { console.error("Error reading blob:", error); alert("Error processing audio."); setLoadingState(false); updateButtonStates(); }; reader.readAsDataURL(blob); }; mediaRecorder.onerror = (e) => { alert(`Recording error: ${e.error?.name || 'Unknown'}`); stopRecording(true); }; mediaRecorder.start(); isRecording = true; recordingStartTime = Date.now(); recordAudioButton.classList.add('recording'); recordAudioButton.textContent = '🛑'; recordAudioButton.title = 'Stop recording'; recordingStatus.classList.add('visible'); recordingTimerSpan.textContent = '0s'; setLoadingState(true, "Recording..."); recordingTimerInterval = setInterval(() => { const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000); recordingTimerSpan.textContent = `${elapsed}s`; if (elapsed >= RECORDING_TIME_LIMIT_SECONDS) { stopRecording(); alert(`Stopped after ${RECORDING_TIME_LIMIT_SECONDS}s.`); } }, 1000); recordAudioButton.disabled = false; } catch (error) { console.error("Error starting rec:", error); if (error.name === 'NotAllowedError') { alert("Mic access denied."); } else if (error.name === 'NotFoundError') { alert("No microphone."); } else { alert(`Cannot start recording: ${error.name}`); } stopRecording(true); } }
        function stopRecording(force = false) { if (mediaRecorder && (isRecording || force)) { try { if (mediaRecorder.state === "recording" || mediaRecorder.state === "paused") { mediaRecorder.stop(); if (force && !isRecording) { resetRecordingUI(); setLoadingState(false); } } else if (force) { resetRecordingUI(); setLoadingState(false); } } catch (error) { console.error("Error stopping recorder:", error); resetRecordingUI(); setLoadingState(false); } } else if (force) { resetRecordingUI(); setLoadingState(false); } else if (!isRecording) { setLoadingState(false); updateButtonStates(); } }
        function resetRecordingUI() { isRecording = false; if (recordAudioButton) { recordAudioButton.classList.remove('recording'); recordAudioButton.textContent = '🎙️'; recordAudioButton.title = 'Record audio'; } if (recordingStatus) recordingStatus.classList.remove('visible'); if (recordingTimerInterval) { clearInterval(recordingTimerInterval); recordingTimerInterval = null; } if (recorderStream) { recorderStream.getTracks().forEach(t => t.stop()); recorderStream = null; } mediaRecorder = null; audioChunks = []; updateButtonStates(); }


        // --- Chat Creation, Deletion, Switching ---
        // createNewChat, handleChatListClick, confirmAndDeleteChat, deleteChatFromFirestore, switchChat
        // remain the same
        async function createNewChat() { if (!currentUser || startChatButton.disabled) { displayError("Log in or wait."); return; } setLoadingState(true, "Creating chat..."); removeAllSelectedMedia(); const newChatRef = db.collection('chats').doc(); const ts = firebase.firestore.FieldValue.serverTimestamp(); try { await newChatRef.set({ userId: currentUser.uid, title: NEW_CHAT_TITLE, createdAt: ts, lastUpdated: ts }); } catch (error) { console.error("Error creating chat:", error); displayError("Failed create chat."); setLoadingState(false); } }
        function handleChatListClick(event) { const target = event.target; const delBtn = target.closest('.delete-chat-button'); if (delBtn) { event.stopPropagation(); const chatId = delBtn.dataset.id; const item = delBtn.closest('.chat-list-item'); const title = item?.textContent?.replace(delBtn.textContent, '').trim() || 'this chat'; if (chatId) { confirmAndDeleteChat(chatId, title); } return; } const item = target.closest('.chat-list-item'); const clickedId = item?.dataset?.id; if (item && clickedId && clickedId !== activeChatId) { switchChat(clickedId); } }
        function confirmAndDeleteChat(chatId, chatTitle) { if (!currentUser || !chatId) return; if (confirm(`Delete chat "${chatTitle}"?`)) { deleteChatFromFirestore(chatId); } }
        async function deleteChatFromFirestore(chatId) { if (!currentUser || !chatId) return; isDeletingChat = true; setLoadingState(true, "Deleting chat..."); const chatDocRef = db.collection('chats').doc(chatId); const messagesRef = chatDocRef.collection('messages'); try { const msgsSnap = await messagesRef.get(); if (!msgsSnap.empty) { const batch = db.batch(); msgsSnap.docs.forEach(doc => { batch.delete(doc.ref); }); await batch.commit(); } await chatDocRef.delete(); const cacheNameToDelete = `cache-${chatId}-media`; try { if (genAI?.caching?.deleteCachedContent) { await genAI.caching.deleteCachedContent({ name: cacheNameToDelete }); console.log(`[Cache Delete Attempt] ${cacheNameToDelete}`); } } catch(cacheError) { if (!cacheError.message?.includes("not found")) console.warn(`[Cache Delete Attempt Error] ${cacheNameToDelete}:`, cacheError); } if (activeChatId === chatId) { activeChatId = null; currentChatHistory = []; if (activeChatListener) { activeChatListener(); activeChatListener = null; } chatArea.innerHTML = ''; renderGreetingOrLoginPrompt(); removeAllSelectedMedia(); } } catch (error) { console.error(`[Delete Error] ${chatId}:`, error); displayError(`Failed to delete chat.`); } finally { isDeletingChat = false; setLoadingState(false); } }
        function switchChat(chatId) { if (!currentUser || !chatId || chatId === activeChatId) { return; } setLoadingState(true, "Loading chat..."); activeChatId = chatId; currentMediaCacheName = null; cachedMediaUris = []; removeAllSelectedMedia(); highlightActiveChatInSidebar(); userInput.value = ''; autoGrowTextarea(); mcqModeCheckbox.checked = false; loadAndListenForActiveChat(chatId); }

        // --- Message Loading (Firestore) ---
        // loadAndListenForActiveChat remains the same
        function loadAndListenForActiveChat(chatId) {
            if (!currentUser || !chatId) { chatArea.innerHTML = ''; if (activeChatListener) { activeChatListener(); activeChatListener = null; } renderGreetingOrLoginPrompt(); updateButtonStates(); setLoadingState(false); return; }
            if (activeChatListener) { activeChatListener(); activeChatListener = null; }
            const messagesRef = db.collection('chats').doc(chatId).collection('messages').orderBy('timestamp', 'asc');
            chatArea.innerHTML = ''; const loadingMsg = displayMessage("Loading...", 'ai', ['thinking']); scrollToBottom(true);
            activeChatListener = messagesRef.onSnapshot(snapshot => {
                removeMessageElement(loadingMsg); chatArea.innerHTML = ''; currentChatHistory = [];
                if (snapshot.empty && activeChatId === chatId) { const item = chatListContainer.querySelector(`[data-id="${chatId}"]`); const title = item?.textContent?.replace(DELETE_ICON, '').trim() || ''; if (title && title !== NEW_CHAT_TITLE) { displayMessage("Chat empty.", 'ai'); } else { renderGreetingOrLoginPrompt(); } }
                else { snapshot.forEach(doc => { const msgData = doc.data(); const role = msgData.role === 'user' ? 'user' : 'model'; const parts = []; if (msgData.text) { parts.push({ text: msgData.text }); } if (parts.length > 0) { currentChatHistory.push({ role: role, parts: parts }); } displayMessage(msgData.text || '', msgData.role, [], null, msgData); }); }
                scrollToBottom(true); updateButtonStates(); setLoadingState(false);
                if (!isTestMode && !isReviewMode && activeChatId) { setTimeout(() => userInput.focus(), 100); }
            }, error => { console.error(`Error loading messages ${chatId}:`, error); displayError("Could not load messages."); removeMessageElement(loadingMsg); chatArea.innerHTML = ''; currentChatHistory = []; updateButtonStates(); setLoadingState(false); });
        }


        // --- File Upload Helper (Gemini File API) ---
        // uploadAndProcessFile remains the same
        async function uploadAndProcessFile(file, index, totalFiles) {
             if (!genAI?.files?.upload || !genAI?.files?.get || !genAI?.files?.delete) { throw new Error("AI SDK File Service not ready."); }
            const progressMsg = `Uploading ${index + 1}/${totalFiles}: ${file.name}...`; setLoadingState(true, progressMsg); let uploadResult = null;
            try {
                uploadResult = await genAI.files.upload({ file: file, mimeType: file.type, displayName: file.name, });
                if (!uploadResult?.file?.name) { throw new Error(`Upload ${file.name} failed (no name).`); } const apiFileName = uploadResult.file.name;
                let fileResponse = await genAI.files.get({ name: apiFileName }); const startTime = Date.now();
                while (fileResponse?.file?.state === 'PROCESSING') {
                    if (Date.now() - startTime > FILE_API_PROCESSING_TIMEOUT_MS) { throw new Error(`Processing timeout ${file.name}.`); }
                    setLoadingState(true, `Processing ${index + 1}/${totalFiles}: ${file.name}... (${fileResponse.file.state})`); await new Promise(r => setTimeout(r, FILE_API_POLLING_INTERVAL_MS));
                    try { fileResponse = await genAI.files.get({ name: apiFileName }); if (!fileResponse?.file) { throw new Error(`Polling failed getFile ${apiFileName}.`); } }
                    catch (pollError) { throw new Error(`Error checking status ${file.name}: ${pollError.message}`); }
                }
                if (fileResponse.file.state !== 'ACTIVE') { console.error(`File fail ${file.name}. State: ${fileResponse.file.state}`); try { await genAI.files.delete({ name: apiFileName }); } catch (delErr) { } throw new Error(`File processing ${file.name} state: ${fileResponse.file.state}.`); }
                return fileResponse.file;
            } catch (uploadError) { console.error(`Upload/process error ${file.name}:`, uploadError); if (uploadResult?.file?.name) { try { await genAI.files.delete({ name: uploadResult.file.name }); } catch (delErr) { } } throw uploadError; }
        }


        // --- Message Sending (Gemini API & Firestore Save) ---
        // ***** TAMIL *****
        // இதுதான் user message-ஐயும், media-வையும் வாங்கி, Gemini API-க்கு அனுப்பி, பதிலை வாங்கி காட்டுகின்ற முக்கிய function.
        // இங்கதான் model selection, history, caching, மற்றும் token limits பயன்படுத்தப்படுகிறது.
        async function handleSendMessage() {
            const userMessageTextRaw = userInput.value.trim();
            const mediaItemsToSend = [...selectedMediaItems];
            const isMCQRequest = mcqModeCheckbox.checked;
            const youtubeMatch = userMessageTextRaw.match(youtubeRegex);
            const youtubeUrl = youtubeMatch ? youtubeMatch[0] : null;

            console.log("handleSendMessage: Text:", userMessageTextRaw ? userMessageTextRaw.substring(0, 50) + '...' : '(empty)', "Media:", mediaItemsToSend.length, "YT:", youtubeUrl, "Model:", selectedModelId);

            // --- Initial Checks ---
            if (!currentUser || !activeChatId || !API_KEY || !genAI || !isAISdkReady || !HarmCategory || !HarmBlockThreshold) { displayError("Login/API Key/SDK Error."); return; }
            const currentModelInfo = AVAILABLE_MODELS.find(m => m.id === selectedModelId);
            if (!currentModelInfo) { displayError("Invalid AI model selected."); return; }
            if (youtubeUrl && mediaItemsToSend.length > 0) { displayError("Cannot mix YouTube URL and uploaded media."); setLoadingState(false); return; }
            const hasPdfs = mediaItemsToSend.some(item => item.type === 'pdf');
            if (hasPdfs && (!genAI.files || !genAI.files.upload)) { displayError("File API unavailable for PDF."); return; }
            if (!userMessageTextRaw && mediaItemsToSend.length === 0) { return; }
            if (sendButton.disabled || isRecording) { return; }

            setLoadingState(true, "Preparing message...");
            userInput.value = ''; autoGrowTextarea();
            if (isMCQRequest) mcqModeCheckbox.checked = false;

            const timestamp = firebase.firestore.FieldValue.serverTimestamp();
            const messagesColRef = db.collection('chats').doc(activeChatId).collection('messages');
            const chatDocRef = db.collection('chats').doc(activeChatId);

            const userMsgData = { role: "user", text: userMessageTextRaw, timestamp: timestamp };
            const singleAudioItem = mediaItemsToSend.find(i => i.type === 'audio');
            const imageItems = mediaItemsToSend.filter(i => i.type === 'image');
            const pdfItems = mediaItemsToSend.filter(i => i.type === 'pdf');
            let potentialTestTitle = null;

            if (singleAudioItem) { userMsgData.mediaType = 'audio'; userMsgData.mediaData = singleAudioItem.base64; userMsgData.mediaMimeType = singleAudioItem.mimeType; userMsgData.mediaName = singleAudioItem.name; }
            else if (imageItems.length === 1) { userMsgData.mediaType = 'image'; userMsgData.mediaName = imageItems[0].name; userMsgData.mediaMimeType = imageItems[0].mimeType; if (!imageItems[0].base64) { try { imageItems[0].base64 = await readFileAsBase64(imageItems[0].file); } catch (e) { imageItems[0].base64 = '#error'; } } userMsgData.mediaData = imageItems[0].base64; }
            else if (imageItems.length > 1) { userMsgData.mediaType = 'multi-image'; userMsgData.mediaCount = imageItems.length; userMsgData.mediaNames = imageItems.map(i => i.name || 'image'); }
            else if (pdfItems.length > 0) { userMsgData.mediaType = 'multi-pdf'; userMsgData.mediaCount = pdfItems.length; userMsgData.mediaNames = pdfItems.map(i => i.name || 'pdf'); }
            if (youtubeUrl) userMsgData.youtubeVideoId = youtubeMatch[1];

            // --- Save User Message ---
            try {
                const chatSnap = await chatDocRef.get(); let isFirstMsg = false; if (chatSnap.exists && chatSnap.data().title === NEW_CHAT_TITLE) { const msgsSnap = await messagesColRef.limit(1).get(); if (msgsSnap.empty) isFirstMsg = true; }
                const userMsgRef = await messagesColRef.add(userMsgData);
                await chatDocRef.update({ lastUpdated: timestamp });
                const userPartsHist = []; if (userMsgData.text) userPartsHist.push({ text: userMsgData.text });
                if (userPartsHist.length > 0) { currentChatHistory.push({ role: 'user', parts: userPartsHist }); }
                if (isFirstMsg) { let titleSrc = userMessageTextRaw || (mediaItemsToSend[0]?.name) || NEW_CHAT_TITLE; const genTitle = generateChatTitle(titleSrc); if (genTitle && genTitle !== NEW_CHAT_TITLE) await updateActiveChatTitle(genTitle); }
            } catch(error) { console.error("Error saving user msg:", error); displayError("Failed save message."); setLoadingState(false); return; }

            const thinking = displayMessage("Thinking...", 'ai', ['thinking']);
            scrollToBottom();

            // --- Prepare API Parts ---
            const partsForApi = [];
            let fileDataPartsForApi = [];
            let useCache = false; let cacheToUse = null; let isYouTubeRequest = false;
            let generatedResponse = null; let aiResponseSaved = false; let uploadedFileUris = [];
            let textPromptForApi = userMessageTextRaw; // Initialize

            try {
                if (youtubeUrl && mediaItemsToSend.length === 0) { // YouTube Only
                    isYouTubeRequest = true;
                    partsForApi.push({ fileData: { mimeType: "video/mp4", fileUri: youtubeUrl } });
                    textPromptForApi = userMessageTextRaw.replace(youtubeUrl, '').trim();
                    if (isMCQRequest) { potentialTestTitle = generateChatTitle(textPromptForApi || "YouTube Test") + ` (...)`; textPromptForApi += `\n\nPlease generate MCQs... [JSON format instructions]`; }
                    else if (!textPromptForApi) { textPromptForApi = "Summarize this video."; }
                    if (textPromptForApi) { partsForApi.push({ text: textPromptForApi }); }
                }
                else if (mediaItemsToSend.length > 0) { // Uploaded Media
                    if (singleAudioItem) { const data = singleAudioItem.base64?.substring(singleAudioItem.base64.indexOf(',') + 1); if (!data || !singleAudioItem.mimeType) throw new Error("Audio data invalid."); partsForApi.push({ inlineData: { mimeType: singleAudioItem.mimeType, data: data } }); }
                    else if (imageItems.length > 0) { const b64s = await Promise.all(imageItems.map(i => i.base64 || readFileAsBase64(i.file))); let added = 0; b64s.forEach((b64, idx) => { if (!b64 || b64 === '#error') return; const mime = imageItems[idx].mimeType; const data = b64.substring(b64.indexOf(',') + 1); if(data && mime) { partsForApi.push({ inlineData: { mimeType: mime, data: data } }); added++; } }); if (added === 0 && imageItems.length > 0) throw new Error("Failed process images."); }
                    else if (pdfItems.length > 0) { const uploads = await Promise.all(pdfItems.map((item, idx) => uploadAndProcessFile(item.file, idx, pdfItems.length))); uploadedFileUris = uploads.map(f => f.uri).filter(Boolean); if (uploadedFileUris.length === 0) throw new Error("Failed upload/process PDFs."); fileDataPartsForApi = uploadedFileUris.map(uri => ({ fileData: { mimeType: uploads.find(f=>f.uri===uri).mimeType, fileUri: uri } })); const canCache = currentModelInfo.supportsCaching && !!genAI?.caching?.createCachedContent; if (canCache) { const sortedUris = [...uploadedFileUris].sort(); if (currentMediaCacheName && cachedMediaUris.length === sortedUris.length && cachedMediaUris.every((u, i) => u === sortedUris[i])) { useCache = true; cacheToUse = currentMediaCacheName; } else { currentMediaCacheName = null; cachedMediaUris = []; } } }
                    // Add text for uploaded media
                    textPromptForApi = userMessageTextRaw;
                    if (isMCQRequest) { potentialTestTitle = generateChatTitle(textPromptForApi || mediaItemsToSend[0]?.name || "Gen Test") + ` (...)`; textPromptForApi += `\n\nPlease generate MCQs... [JSON format instructions]`; }
                    if (textPromptForApi) { partsForApi.push({ text: textPromptForApi }); }
                }
                else { // Text Only
                    textPromptForApi = userMessageTextRaw;
                    if (isMCQRequest) { potentialTestTitle = generateChatTitle(textPromptForApi || "Text Test") + ` (...)`; textPromptForApi += `\n\nPlease generate MCQs... [JSON format instructions]`; }
                    if (textPromptForApi) { partsForApi.push({ text: textPromptForApi }); }
                }

                // Combine parts
                let finalPartsForApi = [];
                if (isYouTubeRequest) { finalPartsForApi = partsForApi; }
                else if (fileDataPartsForApi.length > 0) { finalPartsForApi = useCache ? partsForApi : [...partsForApi, ...fileDataPartsForApi]; }
                else { finalPartsForApi = partsForApi; }
                if (finalPartsForApi.length === 0 && !useCache) { throw new Error("No content to send."); }

                // --- Call Gemini API ---
                setLoadingState(true, "Generating response...");

                // ***** TAMIL *****
                // இங்கதான் `maxOutputTokens`-ஐ model ID-ஐ பொறுத்து அமைக்கிறோம்.
                const maxTokens = MODEL_OUTPUT_TOKENS[selectedModelId] || MODEL_OUTPUT_TOKENS.default;
                console.log(`Using maxOutputTokens: ${maxTokens} for model ${selectedModelId}`);

                const model = genAI.getGenerativeModel({
                    model: selectedModelId,
                    safetySettings: [ { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, /* ... other categories ... */ { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, ],
                    generationConfig: { // <<<--- TAMIL: இங்க generationConfig சேர்த்துள்ளோம்
                        maxOutputTokens: maxTokens,
                    }
                });

                // Add history
                const historyForSDK = currentChatHistory.map(m => ({ role: m.role, parts: m.parts.filter(p => typeof p.text === 'string') })).filter(m => m.parts.length > 0);
                const contentsRequest = [ ...historyForSDK, { role: "user", parts: finalPartsForApi } ];
                const generateContentRequest = { contents: contentsRequest, ...(useCache && cacheToUse && { cache: { name: cacheToUse } }) };

                console.log("SDK Request:", JSON.stringify(generateContentRequest, (k, v) => (k === 'data' && typeof v === 'string' && v.length > 100) ? v.substring(0, 50) + '...' : v, 2));
                const result = await model.generateContent(generateContentRequest);
                generatedResponse = result.response;

                // --- Process Response ---
                removeMessageElement(thinking);
                let aiMsgData = { role: "model", text: "Error: No response.", timestamp: firebase.firestore.FieldValue.serverTimestamp(), mcqData: null, mcqTitle: null };
                let displayAsError = true; let rawAiText = ""; let blocked = false;

                if (generatedResponse.promptFeedback?.blockReason) { aiMsgData.text = `Blocked (Prompt): ${generatedResponse.promptFeedback.blockReason}`; blocked = true; }
                else if (generatedResponse.candidates?.length > 0) {
                    const cand = generatedResponse.candidates[0];
                    if (cand.finishReason === 'SAFETY') { aiMsgData.text = `Blocked (Safety): ${cand.safetyRatings?.map(r => r.category.replace('HARM_CATEGORY_','')).join(', ') || '?'}`; blocked = true; }
                    else if (cand.finishReason === 'RECITATION') { aiMsgData.text = `Blocked (Recitation)`; blocked = true; }
                    else if (cand.content?.parts?.length > 0) {
                        try {
                            rawAiText = generatedResponse.text(); aiMsgData.text = rawAiText; displayAsError = false;
                            if (isMCQRequest && !blocked) { // Parse MCQs
                               try { const match = rawAiText.match(/```json\s*([\s\S]*?)\s*```/); const jsonStr = match ? match[1].trim() : rawAiText.trim(); if (jsonStr.startsWith('[') && jsonStr.endsWith(']')) { const mcqs = JSON.parse(jsonStr); const isValid = Array.isArray(mcqs) && mcqs.length > 0 && mcqs.every(q => q.question?.en && q.options?.length === 4 && q.options.every(o=>o.en) && q.answer && q.explanation?.en); if (isValid) { mcqs.forEach(q => { q.question.ta = q.question.ta || q.question.en; q.explanation.ta = q.explanation.ta || q.explanation.en; q.options.forEach(o => { o.ta = o.ta || o.en; }); }); aiMsgData.text = `Generated ${mcqs.length} MCQs.`; aiMsgData.mcqData = mcqs; aiMsgData.mcqTitle = potentialTestTitle; displayAsError = false; } else throw new Error("Invalid MCQ structure."); } else throw new Error("Not JSON array."); }
                                catch (parseError) { console.warn("MCQ parse error:", parseError); aiMsgData.text = "MCQ format error.\n\n" + rawAiText; displayAsError = true; aiMsgData.mcqData = null; aiMsgData.mcqTitle = null; }
                            }
                        } catch (textError) { aiMsgData.text = "Error extracting text."; displayAsError = true; }
                    } else if (cand.finishReason === 'MAX_TOKENS') { aiMsgData.text = (generatedResponse.text ? generatedResponse.text() : "") + "\n\n(Truncated: Max tokens)"; displayAsError = false; }
                    else if (cand.finishReason === 'STOP' && (!cand.content || cand.content?.parts?.length === 0)){ aiMsgData.text = "(No content)"; displayAsError = false;}
                    else { aiMsgData.text = `Finished: ${cand.finishReason || '?'}. ` + (generatedResponse.text ? generatedResponse.text() : ""); displayAsError = false; }
                } else { aiMsgData.text = "Error: No API response data."; }

                // --- Save AI Response ---
                 try { await messagesColRef.add(aiMsgData); await chatDocRef.update({ lastUpdated: firebase.firestore.FieldValue.serverTimestamp() }); aiResponseSaved = true; if (!displayAsError && !blocked && aiMsgData.text) { currentChatHistory.push({ role: 'model', parts: [{ text: aiMsgData.text }] }); } }
                 catch (saveError) { console.error("Error saving AI response:", saveError); displayError(`Failed save AI response.`); }

                 // --- Attempt Cache Creation ---
                 if (!isYouTubeRequest && !useCache && currentModelInfo.supportsCaching && fileDataPartsForApi.length > 0 && !!genAI?.caching?.createCachedContent) {
                      const newCacheName = `cache-${activeChatId}-media-${Date.now()}`; console.log(`Attempting cache create: ${newCacheName} for ${fileDataPartsForApi.length} file(s).`);
                      try { const req = { model: `models/${selectedModelId}`, contents: [{ role: 'user', parts: fileDataPartsForApi }], ttlSeconds: CACHE_TTL_SECONDS, name: newCacheName };
                            genAI.caching.createCachedContent(req).then(cache => { if (cache?.name) { currentMediaCacheName = cache.name; cachedMediaUris = [...uploadedFileUris].sort(); console.log(`Cache ${currentMediaCacheName} creation initiated.`); } }).catch(e => console.error(`Cache create error ${newCacheName}:`, e));
                      } catch (e) { console.error("Cache setup error:", e); }
                 }

            } catch (error) {
                 console.error("Error during send:", error); removeMessageElement(thinking); const errorText = `Error: ${error.message || "Unexpected error."}`; displayError(errorText);
                 if (!aiResponseSaved) { try { await messagesColRef.add({ role: "model", text: errorText, timestamp: timestamp }); await chatDocRef.update({ lastUpdated: timestamp }); } catch (e) {} }
            } finally {
                 removeAllSelectedMedia(); setLoadingState(false);
                 if (!isTestMode && !isReviewMode && activeChatId) { setTimeout(() => userInput.focus(), 100); }
            }
        } // End of handleSendMessage



        // --- Chat Title Generation/Update ---
        // generateChatTitle, updateActiveChatTitle remain the same
        function generateChatTitle(sourceText) { if (!sourceText) return NEW_CHAT_TITLE; const text = sourceText.trim(); if (!text) return NEW_CHAT_TITLE; const title = text.split(/\s+/).slice(0, 5).join(' ').replace(/[.,!?;:]+$/, ''); return title.length > 35 ? title.substring(0, 32) + '...' : title; }
        async function updateActiveChatTitle(newTitle) { if (!currentUser || !activeChatId || !newTitle?.trim() || newTitle.trim() === NEW_CHAT_TITLE) return; const finalTitle = newTitle.trim(); const ref = db.collection('chats').doc(activeChatId); try { await ref.update({ title: finalTitle }); } catch (error) { console.error("Error update title:", error); } }

        // --- File Reader Helper ---
        // readFileAsBase64 remains the same
        function readFileAsBase64(file) { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = () => resolve(reader.result); reader.onerror = reject; reader.readAsDataURL(file); }); }

        // --- UI & Message Display Helpers ---
        // autoGrowTextarea, handleInputKeydown, handleSuggestionClick, displayError, scrollToBottom, removeMessageElement
        // remain the same
        function autoGrowTextarea() { userInput.style.height='auto'; userInput.style.height=(userInput.scrollHeight)+'px'; }
        function handleInputKeydown(event) { if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();if(!sendButton.disabled) handleSendMessage();} }
        function handleSuggestionClick(event) { if(event.target.classList.contains('suggestion-chip')){ const prompt = event.target.dataset.prompt || ''; userInput.value = prompt; if (prompt.toLowerCase().includes("video")) { userInput.value += " "; userInput.placeholder = "Paste YouTube URL..."; } autoGrowTextarea();userInput.focus();} }
        function displayError(text) { console.error("Displaying Error:", text); displayMessage(`${text}`, 'ai', ['error-message']); scrollToBottom(); }
        function scrollToBottom(immediate = false) { chatArea.scrollTo({top:chatArea.scrollHeight,behavior:immediate?'auto':'smooth'}); }
        function removeMessageElement(element) { if(element?.parentNode === chatArea) { try { chatArea.removeChild(element); } catch(e) {} } }

        // updateButtonStates: Includes tests button
        // ***** TAMIL *****
        // இந்த function UIல் உள்ள buttons (send, upload, tests, pin etc.) enable/disable செய்ய உதவுகிறது.
         function updateButtonStates(isLoading = false) {
            const isLoggedIn = !!currentUser;
            const isSdkFullyReady = isLoggedIn && !!API_KEY && !!genAI && isAISdkReady && !!HarmCategory && !!HarmBlockThreshold;
            const canUseFileAPI = isSdkFullyReady && !!genAI.files?.upload;
            const hasYouTubeUrlInInput = youtubeRegex.test(userInput.value.trim());
            const isChatSelected = !!activeChatId;
            const canSendMessage = isSdkFullyReady && isChatSelected && !isLoading && !isRecording;

            userInput.disabled = !isSdkFullyReady || !isChatSelected || isLoading || isRecording;
            sendButton.disabled = !canSendMessage;
            mcqModeCheckbox.disabled = !canSendMessage;
            imageUploadButton.disabled = !canSendMessage || hasYouTubeUrlInInput;
            pdfUploadButton.disabled = !canSendMessage || !canUseFileAPI || hasYouTubeUrlInInput;
            audioUploadButton.disabled = !canSendMessage || hasYouTubeUrlInInput;
            recordAudioButton.disabled = !canSendMessage || hasYouTubeUrlInInput;
            if (isRecording) { recordAudioButton.disabled = false; recordAudioButton.title = "Stop recording"; }
            else { recordAudioButton.title = hasYouTubeUrlInInput ? "Recording disabled (YouTube URL)" : "Record audio"; }

            pdfUploadButton.title = (!canUseFileAPI) ? "PDF Upload disabled (File API unavailable)" : (hasYouTubeUrlInInput ? "PDF Upload disabled (YouTube URL)" : "Upload PDF(s)");
            imageUploadButton.title = hasYouTubeUrlInInput ? "Image Upload disabled (YouTube URL)" : "Upload image(s)";
            audioUploadButton.title = hasYouTubeUrlInInput ? "Audio Upload disabled (YouTube URL)" : "Upload audio";

            startChatButton.disabled = !isLoggedIn || isLoading || isRecording;
            showTestsButton.disabled = !isLoggedIn || isLoading; // Disable if not logged in or loading

            decreaseTextBtn.disabled = isLoading || isRecording || currentTextSizeMultiplier <= MIN_TEXT_SIZE_MULTIPLIER;
            increaseTextBtn.disabled = isLoading || isRecording || currentTextSizeMultiplier >= MAX_TEXT_SIZE_MULTIPLIER;
            themeToggleButton.disabled = isLoading || isRecording;
            pinSidebarButton.disabled = isLoading || isRecording; // Disable pin button when loading/recording
            modelSelector.disabled = isLoading || isRecording || !isLoggedIn;
            loginBtn.disabled = isLoading;
            logoutBtn.disabled = isLoading;
         }

        // setLoadingState remains the same
        function setLoadingState(isLoading, message = "Generating...") {
            updateButtonStates(isLoading);
            let placeholder = ""; const isLoggedIn = !!currentUser; const isSdkReady = isLoggedIn && !!API_KEY && !!genAI && isAISdkReady;
            if (isRecording) { placeholder = "Recording..."; }
            else if (isLoading) { placeholder = message; }
            else if (!isLoggedIn) { placeholder = "Please log in"; }
            else if (!isSdkReady) { placeholder = "API Key/SDK Error."; }
            else if (!activeChatId) { placeholder = "Select or create chat"; }
            else { placeholder = "Enter prompt, attach media, or paste URL"; }
            if (userInput.placeholder !== placeholder) { userInput.placeholder = placeholder; }
        }

        // switchView remains the same
        function switchView(viewName, fromTestsPopup = false) {
             console.log("Switching view to:", viewName, "From tests popup:", fromTestsPopup);
             chatView.classList.remove('active'); reviewView.classList.remove('active'); testView.classList.remove('active'); appContainer.classList.remove('hidden');
             isTestMode = false; isReviewMode = false; cameFromAllTestsList = fromTestsPopup; // Set flag
             saveReviewBtn.style.display = 'none'; exitReviewBtn.style.display = 'none';
             if(viewName === 'test'){ appContainer.classList.add('hidden'); testView.classList.add('active'); isTestMode = true; }
             else if(viewName === 'review'){ reviewView.classList.add('active'); isReviewMode = true; exitReviewBtn.style.display = 'inline-block'; exitReviewBtn.textContent = fromTestsPopup ? "Back to Tests" : "Back to Chat"; /* Adjust button text */ }
             else { chatView.classList.add('active'); if (currentUser && activeChatId && API_KEY && genAI && !isRecording) { setTimeout(() => userInput.focus(), 100); } }
             if (viewName !== 'test' && testTimerInterval) { clearInterval(testTimerInterval); testTimerInterval = null; }
        }

        // displayMessage: Includes code block handling and YouTube Embed
        // ***** TAMIL *****
        // இந்த function message-களை chat area-வில் காட்டுகிறது. Code block-களையும், YouTube video-வையும் format செய்கிறது.
        function displayMessage(text, sender, cssClasses = [], appendHtml = null, messageData = null) {
            const messageElement = document.createElement('div');
            messageElement.classList.add('message', `${sender}-message`);
            if (cssClasses?.length > 0) messageElement.classList.add(...cssClasses);
            let hasContent = false; let containsCode = false;

            // --- Media Rendering (Uploaded Files) ---
            if (messageData?.mediaType === 'image' && messageData.mediaData && messageData.mediaData !== '#error') { try { const img = document.createElement('img'); img.src = messageData.mediaData; img.alt = messageData.mediaName || "Uploaded"; img.classList.add('uploaded-image'); img.loading="lazy"; img.onerror=()=>{img.alt="Load error";img.src="";}; messageElement.appendChild(img); hasContent = true; } catch (e) {} }
            else if (messageData?.mediaType === 'multi-image') { try { const ind = document.createElement('div'); ind.classList.add('multi-media-indicator'); ind.textContent = `(${messageData.mediaCount} image${messageData.mediaCount > 1 ? 's' : ''} sent: ${messageData.mediaNames?.join(', ') || ''})`; messageElement.appendChild(ind); hasContent = true; } catch (e) {} }
            else if (messageData?.mediaType === 'multi-pdf') { try { const ind = document.createElement('div'); ind.classList.add('multi-media-indicator'); ind.textContent = `(${messageData.mediaCount} PDF${messageData.mediaCount > 1 ? 's' : ''} sent: ${messageData.mediaNames?.join(', ') || ''})`; messageElement.appendChild(ind); hasContent = true; } catch (e) {} }
            else if (messageData?.mediaType === 'audio' && messageData.mediaData) { try { const audCont = document.createElement('div'); audCont.classList.add('chat-audio-player'); const player = document.createElement('audio'); player.src = messageData.mediaData; player.controls = true; player.preload="metadata"; if(messageData.mediaName) player.title=messageData.mediaName; player.onerror=()=>{audCont.innerHTML=`<span style='font-size:0.8em;color:var(--error-text);'>(Audio load error)</span>`;}; audCont.appendChild(player); messageElement.appendChild(audCont); hasContent = true; } catch (e) {} }

            // --- Text Content Rendering (with Code Block Handling) ---
            if (text) {
                const msgCont = document.createElement('div');
                try {
                     const tempDiv = document.createElement('div'); tempDiv.innerText = text; let fmtText = tempDiv.innerHTML;
                    // Images in text
                    if (messageData?.mediaType !== 'image') { fmtText = fmtText.replace(imageUrlRegex, (m, url) => `<img src="${url}" class="chat-image" alt="Chat Image" loading="lazy" onerror="this.alt='URL error'; this.src='';">`); }
                    // Code Blocks
                    fmtText = fmtText.replace(/```(\w*)\n?([\s\S]*?)```/g, (m, lang, code) => { containsCode = true; const langCls = lang ? `language-${lang.trim().toLowerCase()}` : 'language-plain'; const escCode = code.replace(/</g, "&lt;").replace(/>/g, "&gt;"); return `<pre class="${langCls}"><code class="${langCls}">${escCode}</code></pre>`; });
                    // Inline Code
                    fmtText = fmtText.replace(/`([^`]+)`/g, (m, code) => `<code>${code.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</code>`);
                    // Bold/Italics/Newlines
                    fmtText = fmtText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/(?<!\*)\*(?!\*)(.*?)(?<!\*)\*(?!\*)/g, '<em>$1</em>').replace(/\n/g, '<br>');
                    msgCont.innerHTML = fmtText; messageElement.appendChild(msgCont); hasContent = true;
                    // MathJax
                    if (text.includes('$') || text.includes('\\')) { if (typeof MathJax !== "undefined" && MathJax.typesetPromise) { setTimeout(() => { MathJax.typesetPromise([msgCont]).catch(err => console.error('MathJax Error:', err)); }, 50); } }
                } catch (e) { console.error("Error formatting text:", e); }
            }

            // --- YouTube Embed (Render based on Firestore data) ---
            if (messageData?.youtubeVideoId) {
                try { const ytDiv = document.createElement('div'); ytDiv.classList.add('youtube-embed-container'); const ifr = document.createElement('iframe'); ifr.classList.add('chat-video'); ifr.src = `https://www.youtube.com/embed/${messageData.youtubeVideoId}`; ifr.title = "YouTube video"; ifr.allow = "accel; autoplay; clipboard-write; encrypted-media; gyro; picture-in-picture; web-share"; ifr.allowFullscreen = true; ifr.loading = "lazy"; ifr.onerror = () => { ytDiv.innerHTML = `<span style='font-size:0.8em;color:var(--error-text);'>(YT embed error)</span>`; }; ytDiv.appendChild(ifr); messageElement.appendChild(ytDiv); hasContent = true; } catch (e) { console.error("Error creating YT embed:", e); }
            }

             // --- MCQ Offer ---
            if (messageData?.role === 'model' && messageData?.mcqData?.length > 0) { try { displayMCQOffer(messageData.mcqData, messageData.mcqTitle, messageElement); hasContent = true; } catch (e) {} }
            // --- Append Raw HTML ---
            else if (appendHtml) { try { const div = document.createElement('div'); div.innerHTML = appendHtml; while (div.firstChild) { messageElement.appendChild(div.firstChild); } hasContent = true; } catch (e) {} }

            // --- Append Message to Chat Area ---
            if (hasContent || cssClasses.includes('thinking') || cssClasses.includes('error-message')) {
                if (!chatArea.contains(messageElement)) { chatArea.appendChild(messageElement);
                    if (containsCode && typeof Prism !== 'undefined') { setTimeout(() => { try { Prism.highlightAllUnder(messageElement); } catch (e) { console.error("Prism error:", e); } }, 50); }
                }
            } else { console.warn(`Skipping empty message: ${sender}`); }
            return messageElement;
        }


        // --- MCQ/Test/Review Functions ---
        // ***** TAMIL *****
        // இந்த functions எல்லாம் mock test, review தொடர்பானவை. Tests popup-ல் இருந்து trigger செய்ய handleTestActionFromPopup சேர்க்கப்பட்டது.
        // handleChatAreaClick, displayMCQOffer, startMockTest, displayTestQuestion, handleOptionSelect,
        // handleTestNavigation, startTestTimer, submitTest, calculateResults, displayReview,
        // handleReviewFilterClick, filterReviewItems, exitReview, saveTestReviewToCloud
        // (These functions remain largely the same, minor adjustments if needed for popup interaction)
         function handleChatAreaClick(event) { const startBtn = event.target.closest('.start-test-button'); if (startBtn) { const mcqStr = startBtn.dataset.mcq; const title = startBtn.dataset.mcqTitle; let mcqs = null; try { mcqs = JSON.parse(mcqStr); } catch (e) { displayError("Could not start. Invalid data."); return; } if (mcqs?.length > 0) { startMockTest(mcqs, title || null); } else { displayError("MCQ data missing."); } return; } const img = event.target.closest('img.chat-image, img.uploaded-image'); if (img?.src && !img.src.startsWith('#') && img.src.trim() !== '') { try { if (!img.src.startsWith('data:') || img.src.length < 2*1024*1024) window.open(img.src, '_blank'); } catch (e) {} } }
         function displayMCQOffer(mcqData, mcqTitle, aiMsgEl) { if (aiMsgEl.querySelector('.start-test-button')) return; const count = mcqData.length; const btn = document.createElement('button'); btn.classList.add('start-test-button'); btn.textContent = `Start Mock Test (${count} Qs)`; btn.title = mcqTitle || `Start test`; try { btn.dataset.mcq = JSON.stringify(mcqData); if (mcqTitle) btn.dataset.mcqTitle = mcqTitle; } catch (e) { return; } const cont = document.createElement('div'); cont.style.marginTop = '10px'; cont.appendChild(btn); aiMsgEl.appendChild(cont); }
         function startMockTest(mcqs, title = null) { if (!currentUser) { displayError("Log in first."); return; } if (!mcqs?.length) { displayError("No questions."); if (cameFromAllTestsList) switchView('chat'); return; } currentTestMCQs = mcqs; currentQuestionIndex = 0; userAnswers = new Array(mcqs.length).fill(null); reviewResultsCache = null; switchView('test'); displayTestQuestion(0); startTestTimer(); const finalTitle = (title && title.trim()) ? title.trim() : `Mock Test (${mcqs.length} Qs)`; testTitle.textContent = finalTitle; }
         function displayTestQuestion(index) { if (index < 0 || index >= currentTestMCQs.length) return; currentQuestionIndex = index; const qData = currentTestMCQs[index]; const qText = qData.question?.en || "?"; testQuestionNumber.textContent = `Q ${index + 1}`; testQuestion.innerHTML = qText; testOptionsContainer.innerHTML = ''; const opts = qData.options || []; const letters = ['A', 'B', 'C', 'D']; opts.forEach((optObj, optIdx) => { if (optIdx >= letters.length) return; const optText = optObj?.en || '?'; const label = document.createElement('label'); const input = document.createElement('input'); input.type = 'radio'; input.name = `q_${index}`; input.value = optIdx; input.checked = (userAnswers[index] === optIdx); input.onchange = () => handleOptionSelect(optIdx); label.appendChild(input); label.appendChild(document.createTextNode(` ${letters[optIdx]}. ${optText}`)); testOptionsContainer.appendChild(label); }); try { if (typeof MathJax !== "undefined") MathJax.typesetPromise([testQuestion, testOptionsContainer]).catch(e=>console.error('MathJax Test Err:', e)); } catch(e){} prevQuestionBtn.disabled = (index === 0); nextQuestionBtn.disabled = (index === currentTestMCQs.length - 1); questionCounter.textContent = `Q: ${index + 1} / ${currentTestMCQs.length}`; }
         function handleOptionSelect(optIdx) { if (currentQuestionIndex >= 0 && currentQuestionIndex < userAnswers.length) userAnswers[currentQuestionIndex] = optIdx; }
         function handleTestNavigation(dir) { let newIdx = currentQuestionIndex; if (dir === 'prev' && currentQuestionIndex > 0) newIdx--; else if (dir === 'next' && currentQuestionIndex < currentTestMCQs.length - 1) newIdx++; if (newIdx !== currentQuestionIndex) displayTestQuestion(newIdx); }
         function startTestTimer() { if (testTimerInterval) clearInterval(testTimerInterval); testStartTime = Date.now(); testTimer.textContent = `Time: 00:00`; testTimerInterval = setInterval(() => { const elapsed = Math.floor((Date.now() - testStartTime) / 1000); const mins = Math.floor(elapsed / 60).toString().padStart(2, '0'); const secs = (elapsed % 60).toString().padStart(2, '0'); testTimer.textContent = `Time: ${mins}:${secs}`; }, 1000); }
         function submitTest() { if (!confirm("Submit?")) return; if (testTimerInterval) clearInterval(testTimerInterval); const endTime = Date.now(); const timeMs = testStartTime ? endTime - testStartTime : 0; const results = calculateResults(currentTestMCQs, userAnswers, timeMs); reviewResultsCache = results; switchView('review', cameFromAllTestsList); displayReview(results); } // Pass flag
         function calculateResults(mcqs, answers, timeMs) { let correct = 0, incorrect = 0, skipped = 0; const revQs = []; mcqs.forEach((q, idx) => { const uAIdx = answers[idx]; const opts = q.options || []; const cALtr = q.answer?.trim().toUpperCase(); const cAIdx = cALtr ? cALtr.charCodeAt(0) - 'A'.charCodeAt(0) : -1; const cATxtE = (cAIdx >=0 && cAIdx < opts.length) ? (opts[cAIdx]?.en || '?') : "N/A"; let uATxtE = "Skipped"; let st = "skipped"; if (uAIdx !== null && uAIdx >= 0 && uAIdx < opts.length) { uATxtE = opts[uAIdx]?.en || '?'; if (uAIdx === cAIdx) { st = "correct"; correct++; } else { st = "incorrect"; incorrect++; } } else if (uAIdx !== null) { uATxtE = "Invalid"; st = "incorrect"; incorrect++; } else { skipped++; } revQs.push({ question: q.question?.en || '?', correctAnswer: cATxtE, userAnswer: uATxtE, status: st, explanation: q.explanation?.en || "N/A" }); }); const total = mcqs.length; const score = `${correct}/${total}`; const timeS = Math.round(timeMs / 1000); const timeStr = `${Math.floor(timeS / 60)}m ${timeS % 60}s`; return { questions: revQs, summary: { score, correct, incorrect, skipped, timeString: timeStr }, testDate: new Date().toISOString(), timeTakenMs: timeMs, sourceChatId: activeChatId, testTitle: testTitle.textContent, originalMCQs: mcqs }; }
         function displayReview(reviewData) { reviewContent.innerHTML = ''; reviewSummary.innerHTML = ''; reviewFilters.style.display = 'none'; if (!reviewData?.questions?.length || !reviewData.summary || !reviewData.originalMCQs) { reviewSummary.innerHTML = "<span>No review data.</span>"; saveReviewBtn.style.display = 'none'; return; } const { score, correct, incorrect, skipped, timeString } = reviewData.summary; reviewSummary.innerHTML = `<span>Score: ${score}</span> <span class="score-correct">C: ${correct}</span> <span class="score-incorrect">I: ${incorrect}</span> <span class="score-skipped">S: ${skipped}</span> <span>Time: ${timeString}</span>`; reviewTitle.textContent = reviewData.testTitle || "Review"; reviewData.questions.forEach((qSum, idx) => { const origQ = reviewData.originalMCQs[idx]; if (!origQ) return; const qTxt = origQ.question?.en || '?'; const opts = origQ.options || []; const cALtr = origQ.answer?.trim().toUpperCase(); const cAIdx = cALtr ? cALtr.charCodeAt(0) - 'A'.charCodeAt(0) : -1; const cATxt = (cAIdx >= 0 && cAIdx < opts.length) ? (opts[cAIdx]?.en) : "N/A"; let uATxt = qSum.userAnswer; const st = qSum.status; if (st === 'skipped') uATxt = "Skipped"; else if (st === 'invalid') uATxt = "Invalid"; const explTxt = origQ.explanation?.en || "N/A."; let iStCls = `status-${st}`; let aDtCls = `user-answer-${st}`; const rItem = document.createElement('div'); rItem.classList.add('review-item', iStCls); rItem.dataset.status = st; let dHtml = `<span class="${aDtCls}">You: ${uATxt}</span>`; if (st !== 'correct') { dHtml += `<br><span class="correct-answer">Correct: ${cATxt}</span>`; } dHtml += `<div class="review-item-explanation">Expl: ${explTxt}</div>`; rItem.innerHTML = `<div class="review-item-qnum">Q ${idx + 1}</div> <div class="review-item-question">${qTxt}</div> <div class="review-item-details">${dHtml}</div>`; reviewContent.appendChild(rItem); }); if (incorrect > 0 || skipped > 0) reviewFilters.style.display = 'block'; else reviewFilters.style.display = 'none'; if (reviewData.savedAt) { saveReviewBtn.textContent = "Saved"; saveReviewBtn.disabled = true; saveReviewBtn.style.display = 'inline-block'; } else if (reviewResultsCache && !cameFromAllTestsList) { /* Allow saving only if NOT from popup */ saveReviewBtn.textContent = "Save Review"; saveReviewBtn.disabled = !currentUser; saveReviewBtn.style.display = 'inline-block'; } else { saveReviewBtn.style.display = 'none'; } filterReviewItems('all'); reviewFilters.querySelectorAll('button').forEach(btn => { btn.classList.toggle('active-filter', btn.dataset.filter === 'all'); }); try { if (typeof MathJax !== "undefined") MathJax.typesetPromise([reviewContent]).catch(e=>console.error('MathJax Review Err:', e)); } catch (e) {} }
         function handleReviewFilterClick(event) { const btn = event.target.closest('button[data-filter]'); if (btn) filterReviewItems(btn.dataset.filter); }
         function filterReviewItems(filter) { reviewFilters.querySelectorAll('button').forEach(btn => btn.classList.toggle('active-filter', btn.dataset.filter === filter)); reviewContent.querySelectorAll('.review-item').forEach(item => { item.classList.toggle('hidden-by-filter', !(filter === 'all' || item.dataset.status === filter)); }); }
         function exitReview() { reviewResultsCache = null; if (cameFromAllTestsList) { showTestsWindow(); /* Reopen tests popup */ } else { switchView('chat'); /* Go back to chat */ } reviewSummary.innerHTML = ''; reviewContent.innerHTML = ''; reviewTitle.textContent = 'Review'; }
         async function saveTestReviewToCloud() { if (!currentUser || !reviewResultsCache || reviewResultsCache.savedAt) return; saveReviewBtn.disabled = true; saveReviewBtn.textContent = "Saving..."; const data = { ...reviewResultsCache, userId: currentUser.uid, savedAt: firebase.firestore.FieldValue.serverTimestamp(), }; try { const ref = await db.collection('testReviews').add(data); alert("Review saved!"); saveReviewBtn.textContent = "Saved"; if (reviewResultsCache) reviewResultsCache.savedAt = new Date(); // Mark as saved locally if (testsPopupWindow && !testsPopupWindow.closed) { testsPopupWindow.postMessage({ action: 'refresh' }, '*'); // Notify popup to refresh } } catch (error) { alert("Failed to save."); saveReviewBtn.disabled = false; saveReviewBtn.textContent = "Save Review"; } }

         // --- Saved Tests Functions (Mainly for data loading and popup interaction) ---
         // ***** TAMIL *****
         // இந்த function saved tests data-வை Firestore-லிருந்து load செய்கிறது. Popup window இந்த data-வை பயன்படுத்தும்.
         function loadAndListenForTests(userId) {
             if (testListListener) { testListListener(); testListListener = null; }
             const testsRef = db.collection('testReviews').where('userId', '==', userId).orderBy('savedAt', 'desc');
             console.log(`Listening for saved tests data for user ${userId} (for popup use)`);
             testListListener = testsRef.onSnapshot(snapshot => {
                 allSavedTestsData = []; // Clear and reload
                 snapshot.forEach(doc => { allSavedTestsData.push({ id: doc.id, ...doc.data() }); });
                 console.log("Updated local cache of saved tests data:", allSavedTestsData.length, "tests");
                 // Notify the popup window if it's open
                 if (testsPopupWindow && !testsPopupWindow.closed) {
                     testsPopupWindow.postMessage({ action: 'update', tests: allSavedTestsData }, '*');
                 }
             }, error => {
                 console.error("Error listening for saved tests data:", error);
                 allSavedTestsData = []; // Clear on error
             });
         }

         // ***** TAMIL *****
         // இந்த function tests popup window-வை திறக்கிறது.
         function showTestsWindow() {
             if (!currentUser) {
                 displayError("Please log in to view saved tests.");
                 return;
             }
             const url = `${TESTS_POPUP_URL}?userId=${currentUser.uid}`;
             const windowFeatures = "width=600,height=700,scrollbars=yes,resizable=yes";

             // If window exists and isn't closed, focus it. Otherwise, open new.
             if (testsPopupWindow && !testsPopupWindow.closed) {
                 testsPopupWindow.focus();
             } else {
                 testsPopupWindow = window.open(url, "savedTestsWindow", windowFeatures);
             }
             // Optional: Send initial data immediately after opening
             // setTimeout(() => {
             //     if (testsPopupWindow && !testsPopupWindow.closed) {
             //         testsPopupWindow.postMessage({ action: 'update', tests: allSavedTestsData }, '*');
             //     }
             // }, 1000); // Delay to allow popup to load
         }

         // ***** TAMIL *****
         // இந்த function tests popup window-லிருந்து வரும் commands-ஐ கையாளுகிறது.
         function handleTestActionFromPopup(action, reviewId, mode = null) {
             console.log(`Action from popup: ${action}, ID: ${reviewId}, Mode: ${mode}`);
             const reviewData = allSavedTestsData.find(t => t.id === reviewId);

             if (!reviewData) {
                 alert("Error: Could not find the specified test data in the main window.");
                 return;
             }

             switch (action) {
                 case 'view':
                     reviewResultsCache = reviewData;
                     switchView('review', true); // Indicate came from tests popup
                     displayReview(reviewData);
                     break;
                 case 'reattempt':
                     if (!mode) {
                         alert("Error: Reattempt mode not specified.");
                         return;
                     }
                     startReattempt(reviewId, mode); // Use existing function
                     break;
                 // Delete and Edit Title are handled directly within the popup in this design
             }
         }

        // ***** TAMIL *****
        // இந்த function reattempt செய்ய உதவுகிறது (popup-லிருந்து call செய்யப்படும்).
        async function startReattempt(reviewId, mode) {
             console.log(`Start reattempt: ID=${reviewId}, Mode=${mode}`);
             const reviewData = allSavedTestsData.find(t => t.id === reviewId);
             if (!reviewData) { alert("Error: Could not find data for reattempt."); return; }
             const originalMCQs = reviewData.originalMCQs;
             const hasValidData = originalMCQs?.length > 0 && originalMCQs.every(q => q?.question && q.options && q.answer && q.explanation);
             if (!hasValidData) { alert("Error: Original test data missing/invalid."); return; }
             const summaryQs = reviewData.questions || []; let questions = [];
             switch (mode) {
                 case 'mistaked': questions = originalMCQs.filter((mcq, i) => summaryQs[i]?.status === 'incorrect'); break;
                 case 'skipped': questions = originalMCQs.filter((mcq, i) => summaryQs[i]?.status === 'skipped'); break;
                 case 'both': questions = originalMCQs.filter((mcq, i) => summaryQs[i]?.status === 'incorrect' || summaryQs[i]?.status === 'skipped'); break;
                 default: questions = [...originalMCQs]; break;
             }
             if (questions.length === 0) { alert(`No questions found for mode '${mode}'.`); return; }
             const title = `${reviewData.testTitle || 'Test'} (Re: ${mode})`;
             // Close the popup before starting the test in the main window
             if (testsPopupWindow && !testsPopupWindow.closed) { testsPopupWindow.close(); }
             startMockTest(questions, title);
        }

    </script>

</body>
</html>
```

**`tests.html` (New File for Popup Window)**

Save this code as a new file named `tests.html` in the *same directory* as your main `index.html` file.

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Saved Tests</title>
    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>

    <style>
        /* Simple Styles for Popup - Inherit from main window or define basic ones */
        :root {
            /* Basic variables */
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --border-color: #e0e0e0;
            --text-primary: #2c2c2c;
            --text-secondary: #5f5f5f;
            --button-bg: #f0f0f0;
            --button-hover-bg: #e0e0e0;
            --input-bg: #ffffff;
            --input-border-color: var(--border-color);
            --input-focus-border-color: #d97a7a; /* Accent color */
            --error-text: #c62828;
            --delete-button-color: #aaa;
            --delete-button-hover-color: #dc3545;
        }
        body {
            font-family: var(--font-family);
            padding: 15px;
            margin: 0;
            background-color: #f9f9f9;
            color: var(--text-primary);
            font-size: 14px;
        }
        h2 {
            margin-top: 0;
            font-size: 1.2em;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 8px;
            margin-bottom: 15px;
        }
        #test-search-input {
            width: calc(100% - 22px); /* Account for padding */
            padding: 8px 10px;
            margin-bottom: 15px;
            border: 1px solid var(--input-border-color);
            background-color: var(--input-bg);
            color: var(--text-primary);
            border-radius: 6px;
            font-size: 0.95em;
            box-sizing: border-box;
        }
        #test-search-input:focus {
            outline: none;
            border-color: var(--input-focus-border-color);
        }
        #all-tests-list {
            max-height: calc(100vh - 150px); /* Adjust as needed */
            overflow-y: auto;
            padding-right: 5px; /* Space for scrollbar */
        }
        .test-list-item {
             padding: 8px 10px; margin-bottom: 8px; border-radius: 6px; background-color: #fff; cursor: default; transition: background-color 0.2s ease; display: flex; flex-direction: column; gap: 5px; border: 1px solid var(--border-color);
        }
         .test-list-item.hidden-by-search { display: none; }
         .test-list-item .no-search-results { padding:10px;color:var(--text-secondary);font-size:0.9em; text-align: center; }
         .test-item-info { font-size: 0.9em; color: var(--text-primary); position: relative; padding-right: 50px; }
         .test-item-title { font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: block; }
         .test-item-details { font-size: 0.8em; color: var(--text-secondary); }
         .test-item-actions { display: flex; justify-content: flex-start; gap: 8px; margin-top: 5px; }
         .test-item-actions button, .test-item-actions select { background-color: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 4px; padding: 4px 8px; font-size: 0.8em; cursor: pointer; transition: background-color 0.2s ease, color 0.2s ease; }
         .test-item-actions button:hover, .test-item-actions select:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
         .test-item-actions select:disabled { opacity: 0.6; cursor: not-allowed; }
        .test-item-controls { position: absolute; right: 5px; top: 0; display: flex; gap: 5px; }
        .test-item-controls button { background: none; border: none; color: var(--delete-button-color); cursor: pointer; font-size: 1.1em; padding: 0 3px; line-height: 1; opacity: 0.7; transition: color 0.2s ease, opacity 0.2s ease; }
        .test-item-controls button:hover { opacity: 1; color: var(--delete-button-hover-color); }
        .test-item-edit-mode { display: flex; align-items: center; }
        .test-item-edit-mode input[type="text"] { flex-grow: 1; padding: 2px 4px; margin-right: 5px; border: 1px solid var(--input-focus-border-color); background-color: var(--input-bg); color: var(--text-primary); border-radius: 3px; font-size: 0.95em; }
        .test-item-edit-mode button { font-size: 0.9em; padding: 2px 5px; background-color: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 3px; cursor: pointer; margin-left: 3px; }
        .test-item-edit-mode button:hover { background-color: var(--button-hover-bg); }
        #loading-indicator { text-align: center; padding: 20px; color: var(--text-secondary); }
        #error-display { color: var(--error-text); padding: 10px; border: 1px solid var(--error-text); background-color: #ffebee; border-radius: 4px; margin-bottom: 10px; display: none; }
    </style>
</head>
<body>
    <h2>Saved Tests</h2>
    <div id="error-display"></div>
    <input type="search" id="test-search-input" placeholder="Search tests..." disabled>
    <div id="all-tests-list">
        <div id="loading-indicator">Loading tests...</div>
    </div>

    <script>
        // --- Firebase Config --- (Same as main window)
        const firebaseConfig = {
            apiKey: "AIzaSyDgw604fe5jnNu4kTOv1cQ-3n7PL8gcN58",
            authDomain: "krish-c5db8.firebaseapp.com",
            projectId: "krish-c5db8",
            storageBucket: "krish-c5db8.appspot.com",
            messagingSenderId: "217175257890",
            appId: "1:217175257890:web:209f0f290eabab6b1fab7b",
            measurementId: "G-97SHYGL2J4"
        };

        // --- Initialize Firebase ---
        let app;
        let db;
        try {
            app = firebase.initializeApp(firebaseConfig);
            db = firebase.firestore();
        } catch (e) {
            console.error("Firebase init error in popup:", e);
            displayPopupError("Failed to initialize database connection.");
        }

        // --- DOM Elements ---
        const testSearchInput = document.getElementById('test-search-input');
        const allTestsListContainer = document.getElementById('all-tests-list');
        const loadingIndicator = document.getElementById('loading-indicator');
        const errorDisplay = document.getElementById('error-display');

        // --- State ---
        let currentUserId = null;
        let allTestsData = [];
        let testsListener = null;

        // --- Icons ---
        const EDIT_TEST_ICON = '✏️';
        const DELETE_TEST_ICON = '🗑️';

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            const urlParams = new URLSearchParams(window.location.search);
            currentUserId = urlParams.get('userId');

            if (currentUserId && db) {
                console.log("Popup loaded for user:", currentUserId);
                testSearchInput.disabled = false;
                loadAndListenForTestsPopup(currentUserId);
            } else if (!currentUserId) {
                displayPopupError("User ID not provided to popup window.");
                testSearchInput.disabled = true;
            } else {
                 displayPopupError("Database not initialized.");
                 testSearchInput.disabled = true;
            }

            testSearchInput.addEventListener('input', filterTestsInPopup);
            allTestsListContainer.addEventListener('click', handleAllTestsListClickPopup);

            // Listen for messages from the main window (e.g., for updates)
            window.addEventListener('message', (event) => {
                // Optional: Add origin check for security
                // if (event.origin !== 'expected_origin') return;
                if (event.data?.action === 'update' && Array.isArray(event.data.tests)) {
                     console.log("Received test data update from main window.");
                     allTestsData = event.data.tests;
                     renderAllTestsListPopup(allTestsData);
                     filterTestsInPopup(); // Apply current filter
                } else if (event.data?.action === 'refresh') {
                     console.log("Received refresh request from main window.");
                     if (currentUserId) loadAndListenForTestsPopup(currentUserId); // Reload data
                }
            });
        });

        function displayPopupError(message) {
            console.error("Popup Error:", message);
            loadingIndicator.style.display = 'none';
            errorDisplay.textContent = message;
            errorDisplay.style.display = 'block';
        }

        // --- Data Loading & Rendering ---
        function loadAndListenForTestsPopup(userId) {
            if (testsListener) { testsListener(); testsListener = null; } // Unsubscribe previous listener
            if (!db) { displayPopupError("Database connection lost."); return; }

            const testsRef = db.collection('testReviews').where('userId', '==', userId).orderBy('savedAt', 'desc');
            loadingIndicator.style.display = 'block';
            errorDisplay.style.display = 'none';
            console.log(`Popup: Listening for tests for user ${userId}`);

            testsListener = testsRef.onSnapshot(snapshot => {
                allTestsData = [];
                snapshot.forEach(doc => { allTestsData.push({ id: doc.id, ...doc.data() }); });
                console.log("Popup: Received saved tests snapshot:", allTestsData.length, "tests");
                renderAllTestsListPopup(allTestsData);
                filterTestsInPopup(); // Apply search filter after rendering
                loadingIndicator.style.display = 'none';
            }, error => {
                console.error("Popup: Error listening for saved tests:", error);
                displayPopupError("Error loading saved tests.");
                allTestsData = [];
                renderAllTestsListPopup([]); // Clear list on error
            });
        }

        function renderAllTestsListPopup(tests) {
            allTestsListContainer.innerHTML = ''; // Clear previous items
            if (tests.length === 0) {
                allTestsListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);text-align:center;">No saved tests found.</div>';
                return;
            }

            tests.forEach(testData => {
                const item = document.createElement('div');
                item.classList.add('test-list-item');
                item.dataset.reviewId = testData.id;

                const title = testData.testTitle || '(Untitled Test)';
                const date = testData.savedAt?.toDate ? testData.savedAt.toDate().toLocaleString() : 'Unknown date';
                const score = testData.summary?.score || 'N/A';
                const hasReattemptData = testData.originalMCQs?.length > 0 && testData.originalMCQs.every(q => q?.question && q.options && q.answer && q.explanation);

                const infoDiv = document.createElement('div');
                infoDiv.classList.add('test-item-info');

                const titleSpan = document.createElement('span');
                titleSpan.classList.add('test-item-title');
                titleSpan.textContent = title;
                titleSpan.title = title; // Tooltip for long titles

                const detailSpan = document.createElement('span');
                detailSpan.classList.add('test-item-details');
                detailSpan.textContent = `Saved: ${date} | Score: ${score}`;

                const controlsDiv = document.createElement('div');
                controlsDiv.classList.add('test-item-controls');

                const editButton = document.createElement('button');
                editButton.innerHTML = EDIT_TEST_ICON;
                editButton.title = "Edit title";
                editButton.dataset.action = "edit-title";
                controlsDiv.appendChild(editButton);

                const deleteButton = document.createElement('button');
                deleteButton.innerHTML = DELETE_TEST_ICON;
                deleteButton.title = "Delete test";
                deleteButton.dataset.action = "delete-test";
                controlsDiv.appendChild(deleteButton);

                infoDiv.appendChild(titleSpan);
                infoDiv.appendChild(detailSpan);
                infoDiv.appendChild(controlsDiv); // Add controls to info div

                const actionsDiv = document.createElement('div');
                actionsDiv.classList.add('test-item-actions');

                const viewButton = document.createElement('button');
                viewButton.textContent = "Details";
                viewButton.dataset.action = "view";
                actionsDiv.appendChild(viewButton);

                const reattemptSelect = document.createElement('select');
                reattemptSelect.dataset.action = "reattempt";
                reattemptSelect.disabled = !hasReattemptData;
                reattemptSelect.title = hasReattemptData ? "Reattempt test" : "Reattempt data not available";
                reattemptSelect.innerHTML = `
                    <option value="" selected>${hasReattemptData ? 'Reattempt...' : 'N/A'}</option>
                    <option value="mistaked" ${!hasReattemptData?'disabled':''}>Mistaked Only</option>
                    <option value="skipped" ${!hasReattemptData?'disabled':''}>Skipped Only</option>
                    <option value="both" ${!hasReattemptData?'disabled':''}>Mistaked/Skipped</option>
                    <option value="full" ${!hasReattemptData?'disabled':''}>Full Test</option>`;
                // Add event listener directly here for simplicity in popup
                reattemptSelect.addEventListener('change', (e) => {
                    const selectedMode = e.target.value;
                    if (selectedMode) {
                        const reviewId = e.target.closest('.test-list-item')?.dataset.reviewId;
                        if (reviewId && window.opener && !window.opener.closed) {
                            // Call function in main window
                            window.opener.handleTestActionFromPopup('reattempt', reviewId, selectedMode);
                        } else if (!window.opener || window.opener.closed) {
                             alert("Cannot communicate with the main application window.");
                        }
                        e.target.value = ""; // Reset select
                    }
                });
                actionsDiv.appendChild(reattemptSelect);

                item.appendChild(infoDiv);
                item.appendChild(actionsDiv);
                allTestsListContainer.appendChild(item);
            });
             // Check if search term yields no results after rendering
            filterTestsInPopup();
        }

        function filterTestsInPopup() {
            const searchTerm = testSearchInput.value.toLowerCase().trim();
            const items = allTestsListContainer.querySelectorAll('.test-list-item');
            let visibleCount = 0;

            // Remove previous no results message
            const noResultsMsg = allTestsListContainer.querySelector('.no-search-results');
            if (noResultsMsg) noResultsMsg.remove();

            items.forEach(item => {
                const title = item.querySelector('.test-item-title')?.textContent.toLowerCase() || '';
                const details = item.querySelector('.test-item-details')?.textContent.toLowerCase() || '';
                const isMatch = title.includes(searchTerm) || details.includes(searchTerm);
                item.classList.toggle('hidden-by-search', !isMatch);
                if (isMatch) visibleCount++;
            });

            // Add no results message if needed
            if (visibleCount === 0 && searchTerm !== '' && items.length > 0) {
                const msgDiv = document.createElement('div');
                msgDiv.textContent = "No saved tests match your search.";
                msgDiv.classList.add('no-search-results');
                allTestsListContainer.appendChild(msgDiv);
            }
        }

        // --- Actions Handler ---
        async function handleAllTestsListClickPopup(event) {
            const button = event.target.closest('button[data-action]');
            if (!button) return;

            const action = button.dataset.action;
            const listItem = button.closest('.test-list-item');
            const reviewId = listItem?.dataset.reviewId;

            if (!reviewId) {
                console.error("Popup: Could not find review ID for action:", action);
                return;
            }

            switch (action) {
                case "view":
                    // Tell the main window to handle viewing
                    if (window.opener && !window.opener.closed) {
                        window.opener.handleTestActionFromPopup('view', reviewId);
                    } else {
                        alert("Cannot communicate with the main application window.");
                    }
                    break;
                case "edit-title":
                    enterTestTitleEditModePopup(listItem, reviewId);
                    break;
                case "delete-test":
                    const testTitle = listItem.querySelector('.test-item-title')?.textContent || 'this test';
                    if (confirm(`Are you sure you want to delete the test "${testTitle}"? This cannot be undone.`)) {
                        deleteSavedTestPopup(reviewId, listItem);
                    }
                    break;
            }
        }

        // --- Edit/Delete/Save Title (Popup Specific) ---
         function enterTestTitleEditModePopup(listItem, reviewId) {
             // Similar to main window, but operates within the popup
             const infoDiv = listItem.querySelector('.test-item-info');
             const titleSpan = infoDiv.querySelector('.test-item-title');
             const detailSpan = infoDiv.querySelector('.test-item-details');
             const controlsDiv = infoDiv.querySelector('.test-item-controls');
             const currentTitle = titleSpan.textContent;

             // Hide original elements
             titleSpan.style.display = 'none';
             detailSpan.style.display = 'none';
             if(controlsDiv) controlsDiv.style.display = 'none';

             // Prevent adding multiple edit modes
             if (infoDiv.querySelector('.test-item-edit-mode')) return;

             const editContainer = document.createElement('div');
             editContainer.classList.add('test-item-edit-mode');

             const input = document.createElement('input');
             input.type = 'text';
             input.value = currentTitle;
             input.maxLength = 100;
             input.addEventListener('keydown', (e) => {
                 if (e.key === 'Enter') {
                     saveTestTitlePopup(listItem, reviewId, input.value);
                 } else if (e.key === 'Escape') {
                     exitTestTitleEditModePopup(listItem, currentTitle);
                 }
             });

             const saveButton = document.createElement('button');
             saveButton.textContent = 'Save';
             saveButton.onclick = () => saveTestTitlePopup(listItem, reviewId, input.value);

             const cancelButton = document.createElement('button');
             cancelButton.textContent = 'Cancel';
             cancelButton.onclick = () => exitTestTitleEditModePopup(listItem, currentTitle);

             editContainer.appendChild(input);
             editContainer.appendChild(saveButton);
             editContainer.appendChild(cancelButton);
             infoDiv.appendChild(editContainer);

             input.focus();
             input.select();
        }

        function exitTestTitleEditModePopup(listItem, originalTitle = null) {
            const infoDiv = listItem.querySelector('.test-item-info');
            const titleSpan = infoDiv.querySelector('.test-item-title');
            const detailSpan = infoDiv.querySelector('.test-item-details');
            const controlsDiv = infoDiv.querySelector('.test-item-controls');
            const editContainer = infoDiv.querySelector('.test-item-edit-mode');

            if (editContainer) editContainer.remove(); // Remove edit UI

            // Restore original elements
            if (originalTitle !== null && titleSpan) {
                titleSpan.textContent = originalTitle;
                titleSpan.title = originalTitle; // Update tooltip too
            }
            if(titleSpan) titleSpan.style.display = '';
            if(detailSpan) detailSpan.style.display = '';
            if(controlsDiv) controlsDiv.style.display = '';
        }

        async function saveTestTitlePopup(listItem, reviewId, newTitle) {
            const trimmedTitle = newTitle.trim();
            if (!trimmedTitle) { alert("Test title cannot be empty."); return; }
            if (trimmedTitle.length > 100) { alert("Test title too long (max 100)."); return; }
            if (!db) { alert("Database connection error."); return; }

            const docRef = db.collection('testReviews').doc(reviewId);
            try {
                await docRef.update({ testTitle: trimmedTitle });
                console.log("Popup: Test title updated:", reviewId);
                // Update local data and UI immediately
                const testIndex = allTestsData.findIndex(t => t.id === reviewId);
                if (testIndex > -1) allTestsData[testIndex].testTitle = trimmedTitle;
                // Update the title span in the list item
                 const titleSpan = listItem.querySelector('.test-item-title');
                 if (titleSpan) {
                     titleSpan.textContent = trimmedTitle;
                     titleSpan.title = trimmedTitle;
                 }
                 exitTestTitleEditModePopup(listItem); // Exit edit mode

            } catch (error) {
                console.error("Popup: Error updating test title:", error);
                alert("Failed to update test title.");
            }
        }

        async function deleteSavedTestPopup(reviewId, listItem) {
            if (!currentUserId || !reviewId || !db) return;

            listItem.style.opacity = '0.5'; // Visually indicate deletion processing
            listItem.style.pointerEvents = 'none';

            const docRef = db.collection('testReviews').doc(reviewId);
            try {
                await docRef.delete();
                console.log("Popup: Saved test deleted:", reviewId);
                // Remove item from UI and local data - listener will eventually confirm
                listItem.remove();
                allTestsData = allTestsData.filter(t => t.id !== reviewId);
                 if(allTestsData.length === 0) {
                      renderAllTestsListPopup([]); // Show 'no tests' message if list becomes empty
                 }
                alert("Saved test deleted.");

            } catch (error) {
                console.error("Popup: Error deleting saved test:", error);
                alert("Failed to delete saved test.");
                listItem.style.opacity = '1'; // Restore on error
                listItem.style.pointerEvents = 'auto';
            }
        }

    </script>
</body>
</html>
