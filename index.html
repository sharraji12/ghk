<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Version Updated -->
    <title>Gemini Chat + Mock Test (v10.2 - Unrestricted, Bilingual MCQ, YT Fix Attempt)</title>
    <script>
        // MathJax Configuration
        window.MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']], displayMath: [['$$', '$$'], ['\\[', '\\]']] },
            svg: { fontCache: 'global' },
            options: { skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
    <!-- <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-storage-compat.js"></script> -->

    <!-- Google Generative AI SDK (Loaded as Module) -->
    <script type="module">
        // ***** TAMIL *****
        // இங்க Google Generative AI SDK-ஐ import செய்கிறோம். இது Gemini API உடன் பேச உதவும்.
        try {
            const { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold } = await import("https://esm.run/@google/generative-ai");
            window.GoogleGenerativeAI = GoogleGenerativeAI;
            window.HarmCategory = HarmCategory; // பாதுகாப்பு அமைப்புகளையும் import செய்கிறோம்
            window.HarmBlockThreshold = HarmBlockThreshold;
            console.log("GoogleGenerativeAI SDK loaded successfully via module.");
            window.dispatchEvent(new Event('google-ai-sdk-loaded')); // SDK load ஆனதும் ஒரு event-ஐ trigger செய்கிறோம்.
        } catch (error) {
            console.error("Failed to load GoogleGenerativeAI SDK:", error);
            window.googleAiSdkLoadError = error; // பிழை ஏற்பட்டால் console-ல் காட்டுவதோடு, ஒரு global variable-ல் store செய்கிறோம்.
        }
    </script>

    <!-- Prism JS for Code Syntax Highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <!-- Use a theme that works well with both light and dark modes, or load dynamically -->
    <!-- Example: prism-okaidia.min.css often works okay -->
    <!-- <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" /> -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>


    <style>
        /* --- Styles (v10.2 - Added Language Toggle Style) --- */
        :root { /* ... Theme Variables ... */
             --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; --sidebar-width: 260px; --message-font-size-base: 1rem;
            /* LIGHT */ --sidebar-bg: #f7f7f7; --main-bg: #ffffff; --input-bg: #ffffff; --border-color: #e0e0e0; --text-primary: #2c2c2c; --text-secondary: #5f5f5f; --text-placeholder: #999999; --accent-color: #d97a7a; --user-message-bg: #cce0ff; --user-message-text: #1c1c1c; --ai-message-bg: #f0f0f0; --ai-message-text: #2c2c2c; --button-bg: #f0f0f0; --button-hover-bg: #e0e0e0; --active-item-bg: #e0e0e0; --code-bg: #f5f2f0; --code-text: #333; --code-border: #ddd; --scrollbar-thumb: #ccc; --scrollbar-thumb-hover: #bbb; --app-outer-bg: #e8e8e8; --send-button-bg: var(--accent-color); --send-button-hover-bg: #c76b6b; --send-button-text: #ffffff; --error-bg: #ffebee; --error-text: #c62828; --error-border: #ef9a9a; --message-font-size: var(--message-font-size-base); --delete-button-color: #aaa; --delete-button-hover-color: #dc3545; --input-border-color: var(--border-color); --input-focus-border-color: var(--accent-color); --preview-bg: var(--button-bg); --preview-border: var(--border-color); --remove-btn-color: var(--text-secondary); --remove-btn-hover-color: var(--error-text);
            /* Audio Specific */
            --record-button-bg: #ff6b6b; --record-button-text: #ffffff; --stop-button-bg: #4a4a4a; --stop-button-text: #ffffff;
            /* Model Selector Specific */
             --selector-bg: var(--input-bg); --selector-border: var(--border-color); --selector-text: var(--text-secondary);
            /* Language Toggle Specific */
             --lang-toggle-bg: var(--button-bg); --lang-toggle-border: var(--border-color); --lang-toggle-text: var(--text-secondary); --lang-toggle-hover-bg: var(--button-hover-bg); --lang-toggle-hover-text: var(--text-primary);
        }
        body.dark-theme { /* DARK */ --sidebar-bg: #2a2a2e; --main-bg: #1e1e1e; --input-bg: #2a2a2e; --border-color: #404040; --text-primary: #e0e0e0; --text-secondary: #a0a0a0; --text-placeholder: #777777; --accent-color: #e58b8b; --user-message-bg: #3a4a6b; --user-message-text: #e8e8e8; --ai-message-bg: #333333; --ai-message-text: #e0e0e0; --button-bg: #404040; --button-hover-bg: #505050; --active-item-bg: #454545; --code-bg: #2d2d2d; --code-text: #ccc; --code-border: #555; --scrollbar-thumb: #555; --scrollbar-thumb-hover: #666; --app-outer-bg: #121212; --send-button-bg: var(--accent-color); --send-button-hover-bg: #f09f9f; --send-button-text: #1e1e1e; --error-bg: #5c2b2b; --error-text: #ffcdd2; --error-border: #8c4343; --delete-button-color: #666; --delete-button-hover-color: #f09f9f; --input-border-color: var(--border-color); --input-focus-border-color: var(--accent-color); --preview-bg: var(--button-bg); --preview-border: var(--border-color); --remove-btn-color: var(--text-secondary); --remove-btn-hover-color: var(--error-text);
            /* Audio Specific */
             --record-button-bg: #ff8787; --record-button-text: #1e1e1e; --stop-button-bg: #777777; --stop-button-text: #e0e0e0;
            /* Model Selector Specific */
             --selector-bg: var(--input-bg); --selector-border: var(--border-color); --selector-text: var(--text-secondary);
            /* Language Toggle Specific */
             --lang-toggle-bg: var(--button-bg); --lang-toggle-border: var(--border-color); --lang-toggle-text: var(--text-secondary); --lang-toggle-hover-bg: var(--button-hover-bg); --lang-toggle-hover-text: var(--text-primary);
        }
        body { font-family: var(--font-family); margin: 0; padding: 0; background-color: var(--app-outer-bg); color: var(--text-primary); font-size: 15px; transition: background-color 0.3s ease, color 0.3s ease; }

        /* Layout & Structure */
        .app-container { display: flex; height: 100vh; width: 100vw; overflow: hidden; } .app-container.hidden { display: none; }
        .sidebar { width: var(--sidebar-width); background-color: var(--sidebar-bg); border-right: 1px solid var(--border-color); display: flex; flex-direction: column; padding: 15px 0; box-sizing: border-box; flex-shrink: 0; transition: background-color 0.3s ease, border-color 0.3s ease, width 0.3s ease; }
        .main-container { flex-grow: 1; display: flex; flex-direction: column; height: 100vh; overflow: hidden; position: relative; }
        .main-content, .review-view { display: none; flex-direction: column; background-color: var(--main-bg); height: 100%; width: 100%; overflow: hidden; transition: background-color 0.3s ease; }
        .main-content.active, .review-view.active { display: flex; }
        .chat-area { flex-grow: 1; overflow-y: auto; padding: 30px 10% 20px; display: flex; flex-direction: column; max-width: 800px; margin: 0 auto; width: 80%; }
        .input-container { padding: 15px 10% 20px; border-top: 1px solid var(--border-color); background-color: var(--input-bg); max-width: 800px; margin: 0 auto; width: 80%; transition: background-color 0.3s ease, border-color 0.3s ease; display: none; }

        /* Sidebar Elements */
         .sidebar-header { padding: 10px 20px; font-size: 1.1em; font-weight: 600; color: var(--text-primary); }
         .sidebar-section { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; margin-top: 10px; }
         .sidebar-section-title { padding: 5px 20px; font-size: 0.85em; font-weight: 600; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px; flex-shrink: 0; }
         #all-tests-section { border-bottom: 1px solid var(--border-color); margin-bottom: 10px; padding-bottom: 10px; flex-shrink: 0; display: flex; flex-direction: column; max-height: 40%; display: none; }
         #all-tests-section.visible { display: flex; }
         #test-search-input { width: calc(100% - 40px); padding: 8px 10px; margin: 5px 15px 10px 15px; border: 1px solid var(--input-border-color); background-color: var(--input-bg); color: var(--text-primary); border-radius: 6px; font-size: 0.9em; box-sizing: border-box; }
         #test-search-input:focus { outline: none; border-color: var(--input-focus-border-color); }
         #all-tests-list { overflow-y: auto; padding: 0 15px; flex-grow: 1; }
         #all-tests-list::-webkit-scrollbar { width: 6px; } #all-tests-list::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 3px;} #all-tests-list::-webkit-scrollbar-thumb:hover { background: var(--scrollbar-thumb-hover); }
         .test-list-item { padding: 8px 10px; margin-bottom: 5px; border-radius: 6px; background-color: var(--button-bg); cursor: default; transition: background-color 0.2s ease; display: flex; flex-direction: column; gap: 5px; border: 1px solid var(--border-color); }
         .test-list-item.hidden-by-search { display: none; }
         .test-list-item .no-search-results { padding:10px;color:var(--text-secondary);font-size:0.9em; }
         .test-item-info { font-size: 0.9em; color: var(--text-primary); position: relative; padding-right: 50px; }
         .test-item-title { font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: block; }
         .test-item-details { font-size: 0.8em; color: var(--text-secondary); }
         .test-item-actions { display: flex; justify-content: flex-start; gap: 8px; margin-top: 5px; }
         .test-item-actions button, .test-item-actions select { background-color: var(--main-bg); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 4px; padding: 4px 8px; font-size: 0.8em; cursor: pointer; transition: background-color 0.2s ease, color 0.2s ease; }
         .test-item-actions button:hover, .test-item-actions select:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
         .test-item-actions select:disabled { opacity: 0.6; cursor: not-allowed; }
        .test-item-controls { position: absolute; right: 5px; top: 0; display: flex; gap: 5px; }
        .test-item-controls button { background: none; border: none; color: var(--delete-button-color); cursor: pointer; font-size: 1.1em; padding: 0 3px; line-height: 1; opacity: 0.7; transition: color 0.2s ease, opacity 0.2s ease; }
        .test-item-controls button:hover { opacity: 1; color: var(--delete-button-hover-color); }
        .test-item-edit-mode { display: flex; align-items: center; }
        .test-item-edit-mode input[type="text"] { flex-grow: 1; padding: 2px 4px; margin-right: 5px; border: 1px solid var(--input-focus-border-color); background-color: var(--input-bg); color: var(--text-primary); border-radius: 3px; font-size: 0.95em; }
        .test-item-edit-mode button { font-size: 0.9em; padding: 2px 5px; background-color: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 3px; cursor: pointer; margin-left: 3px; }
        .test-item-edit-mode button:hover { background-color: var(--button-hover-bg); }
         .start-chat-button { display: flex; align-items: center; gap: 8px; background-color: var(--main-bg); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 8px; padding: 10px 15px; margin: 0 15px 10px 15px; font-size: 0.95em; font-weight: 500; cursor: pointer; text-align: left; transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease; flex-shrink: 0; }
         .start-chat-button:hover { background-color: var(--button-hover-bg); } .start-chat-button svg { fill: currentColor; width: 16px; height: 16px; }
         .start-chat-button:disabled { opacity: 0.6; cursor: not-allowed; }
         .chat-list { overflow-y: auto; padding: 0 15px; margin-bottom: 10px; flex-grow: 1; }
         .chat-list::-webkit-scrollbar { width: 6px; } .chat-list::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 3px;} .chat-list::-webkit-scrollbar-thumb:hover { background: var(--scrollbar-thumb-hover); }
         .chat-list-item { padding: 8px 30px 8px 10px; margin-bottom: 4px; border-radius: 6px; font-size: 0.9em; cursor: pointer; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-secondary); transition: background-color 0.2s ease, color 0.2s ease; position: relative; }
         .chat-list-item:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
         .chat-list-item.active { background-color: var(--active-item-bg); color: var(--text-primary); font-weight: 500; }
         .delete-chat-button { position: absolute; right: 6px; top: 50%; transform: translateY(-50%); width: 18px; height: 18px; background: none; border: none; color: var(--delete-button-color); cursor: pointer; font-size: 1.3em; line-height: 1; padding: 0; display: none; opacity: 0.7; transition: color 0.2s ease, opacity 0.2s ease; }
         .chat-list-item:hover .delete-chat-button { display: block; }
         .delete-chat-button:hover { color: var(--delete-button-hover-color); opacity: 1; }
         .sidebar-footer { border-top: 1px solid var(--border-color); padding: 10px 15px; transition: border-color 0.3s ease; flex-shrink: 0; }
         .sidebar-controls { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; flex-wrap: wrap; gap: 10px;}
         .text-size-controls, .theme-toggle { display: flex; align-items: center; gap: 5px; }
         .text-size-controls span, .theme-toggle span { font-size: 0.85em; color: var(--text-secondary); }
         .text-size-buttons button, .theme-toggle button { background: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 4px; padding: 2px 8px; cursor: pointer; font-size: 1.1em; line-height: 1; transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease; }
         .text-size-buttons button:hover, .theme-toggle button:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
         .text-size-buttons button:disabled, .theme-toggle button:disabled { opacity: 0.6; cursor: not-allowed; }

         /* Model Selector Styling */
         .model-selector-container { margin-top: 10px; width: 100%; }
         .model-selector-container label { font-size: 0.85em; color: var(--text-secondary); display: block; margin-bottom: 4px; }
         #model-selector { width: 100%; padding: 6px 8px; border: 1px solid var(--selector-border); background-color: var(--selector-bg); color: var(--selector-text); border-radius: 6px; font-size: 0.85em; -webkit-appearance: none; appearance: none; background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23a0a0a0%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.4-12.8z%22%2F%3E%3C%2Fsvg%3E'); background-repeat: no-repeat; background-position: right 8px top 50%; background-size: .65em auto; }
         body.dark-theme #model-selector { background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23cccccc%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.4-12.8z%22%2F%3E%3C%2Fsvg%3E'); }
         #model-selector:disabled { opacity: 0.6; cursor: not-allowed; background-color: var(--button-bg); }
         #model-selector:focus { outline: none; border-color: var(--input-focus-border-color); }

         .account-info { display: flex; align-items: center; gap: 10px; font-size: 0.9em; margin-top: 10px; }
         .account-avatar { width: 30px; height: 30px; border-radius: 50%; background-color: #6c757d; color: white; display: flex; align-items: center; justify-content: center; font-weight: 600; }
         .account-details { overflow: hidden; }
         .account-email { font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-primary); }
         .account-plan { font-size: 0.85em; color: var(--text-secondary); }
         #auth-controls { margin-top: 15px; text-align: center; }
         #auth-controls button { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 8px 15px; cursor: pointer; font-size: 0.9em; transition: background-color 0.2s ease; }
         #auth-controls button:hover { background-color: var(--button-hover-bg); }
         #logout-btn { display: none; }

        /* Chat Area Elements */
        .greeting { font-size: 1.8em; font-weight: 600; margin-bottom: 40px; color: var(--text-primary); } .greeting .asterisk { color: var(--accent-color); font-size: 1.2em; margin-right: 5px; display: inline-block; vertical-align: middle; }
        .message { padding: 12px 18px; border-radius: 18px; max-width: 80%; word-wrap: break-word; line-height: 1.6; margin-bottom: 15px; font-size: var(--message-font-size); transition: background-color 0.3s ease, color 0.3s ease; }
        .user-message { background-color: var(--user-message-bg); color: var(--user-message-text); align-self: flex-end; border-bottom-right-radius: 5px; }
        .ai-message { background-color: var(--ai-message-bg); color: var(--ai-message-text); align-self: flex-start; border-bottom-left-radius: 5px; }
        .ai-message strong { font-weight: 600; } .ai-message em { font-style: italic; }
        /* Code Block Styling */
        .ai-message pre { background-color: var(--code-bg); color: var(--code-text); border: 1px solid var(--code-border); padding: 1em; border-radius: 4px; overflow-x: auto; font-size: 0.9em; margin: 8px 0; line-height: 1.4; }
        .ai-message code { font-family: 'Consolas', 'Monaco', 'Andale Mono', 'Ubuntu Mono', monospace; }
        .ai-message pre > code[class*="language-"] { display: block; padding: 0; background: none; text-shadow: none; color: inherit; white-space: pre-wrap; word-wrap: break-word; }
        .ai-message:not(pre) > code { background-color: var(--code-bg); color: var(--code-text); padding: 2px 4px; border-radius: 3px; font-size: 0.9em; }
        .token.operator, .token.entity, .token.url, .language-css .token.string, .style .token.string { background: none; }
        body.dark-theme .token.comment, body.dark-theme .token.prolog, body.dark-theme .token.doctype, body.dark-theme .token.cdata { color: #6c757d; } body.dark-theme .token.punctuation { color: #adb5bd; } body.dark-theme .token.property, body.dark-theme .token.tag, body.dark-theme .token.boolean, body.dark-theme .token.number, body.dark-theme .token.constant, body.dark-theme .token.symbol, body.dark-theme .token.deleted { color: #e58b8b; } body.dark-theme .token.selector, body.dark-theme .token.attr-name, body.dark-theme .token.string, body.dark-theme .token.char, body.dark-theme .token.builtin, body.dark-theme .token.inserted { color: #a9dc76; } body.dark-theme .token.operator, body.dark-theme .token.entity, body.dark-theme .token.url, body.dark-theme .language-css .token.string, body.dark-theme .style .token.string { color: #ffcc66; background: none; } body.dark-theme .token.atrule, body.dark-theme .token.attr-value, body.dark-theme .token.keyword { color: #78dce8; } body.dark-theme .token.function, body.dark-theme .token.class-name { color: #fc9867; } body.dark-theme .token.regex, body.dark-theme .token.important, body.dark-theme .token.variable { color: #ff9d9d; }

        .ai-message.thinking { background-color: transparent; color: var(--text-secondary); font-style: italic; }
        .error-message { background-color: var(--error-bg); color: var(--error-text); border: 1px solid var(--error-border); align-self: flex-start; transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;}
        .info-message { text-align: center; color: var(--text-secondary); padding: 50px 20px; font-style: italic; }
        .message .multi-media-indicator { font-size: 0.9em; color: var(--text-secondary); margin-top: 8px; display: block; font-style: italic;}
        .message mjx-container { color: inherit !important; font-size: inherit !important; }
        .message img.chat-image, .message img.uploaded-image { max-width: 100%; height: auto; border-radius: 8px; margin-top: 8px; cursor: pointer; display: block; }
        .message img.uploaded-image { border: 1px solid var(--border-color); margin-bottom: 5px; }
        .message .youtube-embed-container { margin-top: 10px; }
        .message iframe.chat-video { max-width: 100%; aspect-ratio: 16 / 9; border: none; border-radius: 8px; }
        .message .chat-audio-player { margin-top: 10px; width: 100%; max-width: 350px; }
        .message .chat-audio-player audio { width: 100%; height: 40px; border-radius: 20px; }

        /* Input Area Elements */
        .suggestions { display: none; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; }
        .suggestion-chip { background-color: var(--button-bg); border: 1px solid var(--border-color); color: var(--text-secondary); border-radius: 16px; padding: 8px 15px; font-size: 0.9em; cursor: pointer; transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease; }
        .suggestion-chip:hover { background-color: var(--button-hover-bg); color: var(--text-primary); }
        .input-box { display: flex; align-items: flex-end; background-color: var(--main-bg); border: 1px solid var(--input-border-color); border-radius: 12px; padding: 5px 5px 5px 15px; position: relative; transition: background-color 0.3s ease, border-color 0.3s ease; }
        .input-box:focus-within { border-color: var(--input-focus-border-color); }
        .input-buttons { display: flex; align-self: center; margin-right: 5px; gap: 3px; }
        #image-upload-button, #pdf-upload-button, #audio-upload-button, #record-audio-button { background: none; border: none; color: var(--text-secondary); cursor: pointer; font-size: 1.4em; padding: 0 4px; line-height: 1; transition: color 0.2s ease, opacity 0.2s ease; }
        #image-upload-button:hover, #pdf-upload-button:hover:not(:disabled), #audio-upload-button:hover, #record-audio-button:hover:not(.recording) { color: var(--text-primary); }
        #image-upload-button:disabled, #pdf-upload-button:disabled, #audio-upload-button:disabled, #record-audio-button:disabled:not(.recording) { opacity: 0.5; cursor: not-allowed; color: var(--text-secondary); }
        #record-audio-button.recording { color: var(--record-button-bg); animation: pulse 1.5s infinite; }
        #record-audio-button.recording:disabled { color: var(--stop-button-bg); opacity: 0.7; animation: none; cursor: default; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }

        #user-input { flex-grow: 1; border: none; outline: none; padding: 10px 5px; font-size: 1rem; background-color: transparent; resize: none; min-height: 48px; max-height: 250px; line-height: 1.5; color: var(--text-primary); font-family: var(--font-family); }
        #user-input::placeholder { color: var(--text-placeholder); }
        #user-input:disabled { background-color: var(--button-bg); cursor: not-allowed; opacity: 0.7; }
        .mcq-mode-control { display: flex; align-items: center; margin-left: 10px; padding-bottom: 8px; flex-shrink: 0; }
        .mcq-mode-control input[type="checkbox"] { margin-right: 5px; accent-color: var(--accent-color); cursor: pointer;}
        .mcq-mode-control label { font-size: 0.85em; color: var(--text-secondary); cursor: pointer; user-select: none;}
        #send-button { background-color: var(--send-button-bg); color: var(--send-button-text); border: none; border-radius: 8px; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; cursor: pointer; margin-left: 10px; transition: background-color 0.2s ease; padding: 0; flex-shrink: 0; }
        #send-button:hover:not(:disabled) { background-color: var(--send-button-hover-bg); }
        #send-button:disabled { background-color: #cccccc; cursor: not-allowed; opacity: 0.6; }
        #send-button svg { width: 20px; height: 20px; fill: currentColor; }

        /* Media Previews */
        #media-preview-container { margin-bottom: 10px; padding: 8px; background-color: var(--preview-bg); border: 1px solid var(--preview-border); border-radius: 8px; display: none; flex-direction: column; gap: 8px; }
        #image-previews-list { display: flex; gap: 8px; flex-wrap: wrap; max-height: 120px; overflow-y: auto; }
        .pdf-preview-item { background-color: var(--main-bg); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; padding: 4px 8px; font-size: 0.85em; display: flex; align-items: center; gap: 6px; max-width: 100%; box-sizing: border-box; }
        .pdf-preview-item span { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex-grow: 1; }
        .pdf-preview-item button { background: none; border: none; color: var(--remove-btn-color); cursor: pointer; font-size: 1.1em; line-height: 1; padding: 0 2px; margin-left: 4px; flex-shrink: 0; }
        .pdf-preview-item button:hover { color: var(--remove-btn-hover-color); }
        .image-preview-item { position: relative; }
        .image-preview-item img { max-height: 50px; max-width: 80px; height: auto; width: auto; border-radius: 4px; object-fit: cover; display: block; border: 1px solid var(--border-color); }
        .remove-image-item-button { position: absolute; top: -5px; right: -5px; background-color: rgba(0, 0, 0, 0.6); color: white; border: none; border-radius: 50%; width: 16px; height: 16px; font-size: 10px; line-height: 16px; text-align: center; cursor: pointer; opacity: 0.8; transition: opacity 0.2s ease; }
        .remove-image-item-button:hover { opacity: 1; }
        #preview-audio-container { display: flex; align-items: center; gap: 8px; display: none; }
        #preview-audio-container audio { height: 30px; max-width: 250px; }
        .media-preview-footer { display: flex; align-items: center; width: 100%; }
        #media-preview-info { font-size: 0.85em; color: var(--text-secondary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex-grow: 1; }
        #remove-media-button { background: none; border: none; color: var(--remove-btn-color); cursor: pointer; font-size: 1.4em; line-height: 1; padding: 0 5px; transition: color 0.2s ease; margin-left: auto; flex-shrink: 0; }
        #remove-media-button:hover { color: var(--remove-btn-hover-color); }

         #recording-status { font-size: 0.85em; color: var(--text-secondary); margin-bottom: 5px; display: none; text-align: center; padding: 3px 0; }
         #recording-status.visible { display: block; }

        .thinking::after { content: ' .'; animation: dots 1s steps(3, end) infinite; display: inline-block; }
        @keyframes dots { 0%, 20% { content: ' .'; } 40% { content: ' ..'; } 60%, 100% { content: ' ...'; } }
         .start-test-button { background-color: var(--accent-color); color: var(--send-button-text); border: none; border-radius: 6px; padding: 8px 15px; margin-top: 10px; cursor: pointer; font-weight: 500; display: inline-block; transition: background-color 0.2s ease; }
         .start-test-button:hover { background-color: var(--send-button-hover-bg); }

        /* Mock Test & Review View Styles */
        .mock-test-view { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--main-bg); z-index: 100; flex-direction: column; padding: 20px; box-sizing: border-box; transition: background-color 0.3s ease; }
        .mock-test-view.active { display: flex; }
        .test-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); flex-shrink: 0; flex-wrap: wrap; gap: 10px; /* Allow wrapping */}
        .test-header h2 { margin: 0; font-size: 1.3em; color: var(--text-primary); flex-grow: 1; /* Allow title to take space */}
        .test-info { display: flex; align-items: center; flex-shrink: 0; /* Prevent shrinking */}
        .test-info span { margin-left: 15px; font-size: 0.95em; color: var(--text-secondary); }
        /* Language Toggle Button */
        #test-language-toggle, #review-language-toggle {
            margin-left: 15px; padding: 3px 8px; font-size: 0.8em; cursor: pointer;
            background-color: var(--lang-toggle-bg); border: 1px solid var(--lang-toggle-border);
            color: var(--lang-toggle-text); border-radius: 4px;
            transition: background-color 0.2s ease, color 0.2s ease;
        }
        #test-language-toggle:hover, #review-language-toggle:hover {
            background-color: var(--lang-toggle-hover-bg); color: var(--lang-toggle-hover-text);
        }
        .test-content { flex-grow: 1; overflow-y: auto; padding: 10px 20px; }
        .test-question-container { margin-bottom: 25px; }
        .test-question-number { font-weight: bold; margin-bottom: 8px; color: var(--text-secondary); }
        .test-question { font-size: 1.1em; line-height: 1.5; margin-bottom: 15px; color: var(--text-primary); }
        .test-options label { display: block; margin-bottom: 12px; background-color: var(--button-bg); padding: 12px 15px; border-radius: 6px; border: 1px solid var(--border-color); cursor: pointer; transition: background-color 0.2s ease, border-color 0.2s ease; color: var(--text-primary); }
        .test-options label:hover { background-color: var(--button-hover-bg); }
        .test-options input[type="radio"] { margin-right: 10px; accent-color: var(--accent-color); cursor: pointer;}
        .test-navigation { display: flex; justify-content: space-between; padding-top: 15px; border-top: 1px solid var(--border-color); margin-top: auto; flex-shrink: 0; }
        .test-navigation button { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 10px 20px; cursor: pointer; font-size: 0.95em; transition: background-color 0.2s ease; }
        .test-navigation button:hover:not(:disabled) { background-color: var(--button-hover-bg); }
        .test-navigation button#submit-test-btn { background-color: var(--accent-color); color: var(--send-button-text); border-color: var(--accent-color); }
        .test-navigation button#submit-test-btn:hover:not(:disabled) { background-color: var(--send-button-hover-bg); }
        .test-navigation button:disabled { opacity: 0.5; cursor: not-allowed; }
        .review-view { padding: 20px; box-sizing: border-box; background-color: var(--main-bg); }
        .review-header { margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid var(--border-color); display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; gap: 10px; }
        .review-header h2 { margin: 0; font-size: 1.3em; color: var(--text-primary); flex-basis: 100%; /* Title takes full width first */ }
        .review-summary { display: flex; flex-wrap: wrap; gap: 15px; /* Adjusted gap */ }
        .review-summary span { font-size: 1em; color: var(--text-primary); margin-right: 0; /* Removed margin */ }
        .review-header .controls { display: flex; align-items: center; gap: 10px; margin-left: auto; /* Push controls right */ }
        .review-summary .score-correct { color: #28a745; font-weight: bold;} .review-summary .score-incorrect { color: #dc3545; font-weight: bold;} .review-summary .score-skipped { color: #fd7e14; font-weight: bold;}
        .review-filters { margin-top: 10px; margin-bottom: 15px; }
        .review-filters button { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 6px; padding: 5px 12px; margin-right: 8px; cursor: pointer; font-size: 0.9em; transition: background-color 0.2s ease, border-color 0.2s ease; }
        .review-filters button:hover { background-color: var(--button-hover-bg); }
        .review-filters button.active-filter { background-color: var(--accent-color); color: var(--send-button-text); border-color: var(--accent-color);}
        .review-content { flex-grow: 1; overflow-y: auto; padding-right: 10px; }
        .review-item { margin-bottom: 15px; padding: 15px; border: 1px solid var(--border-color); border-radius: 6px; background-color: var(--button-bg); transition: background-color 0.3s ease, border-color 0.3s ease; }
        .review-item.hidden-by-filter { display: none; }
        .review-item-qnum { font-weight: bold; margin-bottom: 8px; color: var(--text-secondary); }
        .review-item-question { margin-bottom: 10px; line-height: 1.5; color: var(--text-primary); }
        .review-item-details span { display: block; margin-bottom: 5px; font-size: 0.95em; color: var(--text-primary); }
        .review-item-details .correct-answer { color: #28a745; font-weight: bold; }
        .review-item-details .user-answer-correct { color: #28a745; } .review-item-details .user-answer-incorrect { color: #dc3545; text-decoration: line-through; } .review-item-details .user-answer-skipped { color: #fd7e14; font-style: italic; }
        .review-item-explanation { margin-top: 8px; font-size: 0.9em; color: var(--text-secondary); border-left: 3px solid var(--border-color); padding-left: 8px; line-height: 1.4; }
        .review-footer { text-align: center; padding-top: 20px; border-top: 1px solid var(--border-color); margin-top: auto; flex-shrink: 0; display: flex; justify-content: center; gap: 15px; }
        #exit-review-btn, #save-review-btn { background-color: var(--accent-color); color: var(--send-button-text); border: none; border-radius: 6px; padding: 10px 25px; cursor: pointer; font-size: 1em; transition: background-color 0.2s ease; display: none; }
        #exit-review-btn:hover, #save-review-btn:hover:not(:disabled) { background-color: var(--send-button-hover-bg); }
        #save-review-btn { background-color: var(--button-bg); color: var(--text-primary); border: 1px solid var(--border-color); }
        #save-review-btn:hover:not(:disabled) { background-color: var(--button-hover-bg); }
        #save-review-btn:disabled { opacity: 0.6; cursor: not-allowed; background-color: #cccccc; border-color: #aaaaaa; }

        /* Responsive Design */
        @media (max-width: 768px) {
            :root { --sidebar-width: 200px; }
            .sidebar { padding: 10px 0; }
            .chat-area, .input-container { width: 95%; padding-left: 2.5%; padding-right: 2.5%; max-width: none; }
            .chat-area { padding-top: 15px; padding-bottom: 10px; }
            .input-container { padding-top: 10px; padding-bottom: 10px; }
            .message { max-width: 90%; font-size: calc(var(--message-font-size) * 0.95); }
            #image-upload-button, #pdf-upload-button, #audio-upload-button, #record-audio-button { font-size: 1.3em; padding: 0 3px; }
            #media-preview-container { padding: 6px; gap: 6px; }
            #image-previews-list { gap: 5px; max-height: 100px; }
            .pdf-preview-item { padding: 3px 6px; font-size: 0.8em; }
            .image-preview-item img { max-height: 40px; }
            .remove-image-item-button, .pdf-preview-item button { width: 14px; height: 14px; font-size: 9px; line-height: 14px; }
            #preview-audio-container audio { max-width: 180px; height: 28px; }
            #media-preview-info { font-size: 0.8em; }
            #remove-media-button { font-size: 1.3em; }
            .input-box { padding: 5px 5px 5px 10px; }
             #user-input { min-height: 40px; font-size: 0.95rem; }
             #send-button { width: 32px; height: 32px; }
             .mcq-mode-control label { font-size: 0.8em; }
            /* Responsive Sidebar Footer */
            .sidebar-footer { padding: 10px; }
            .sidebar-controls { flex-direction: column; align-items: flex-start; gap: 12px; }
            .model-selector-container { margin-top: 5px; }
            .account-info { margin-top: 15px; }
            #auth-controls { margin-top: 12px; }

            .mock-test-view, .review-view { padding: 10px; }
            .test-header, .review-header { margin-bottom: 15px; padding-bottom: 8px; }
             .test-header h2 { flex-basis: 100%; } /* Ensure title takes full width on small screens */
            .test-info span, .review-summary span { margin-left: 0; margin-right: 10px; font-size: 0.9em; display: inline-block; margin-bottom: 3px;}
            #test-language-toggle, #review-language-toggle { margin-left: 0; margin-top: 5px; font-size: 0.75em;}
             .review-header { flex-direction: column; align-items: flex-start; } /* Stack review header items */
             .review-header .controls { margin-left: 0; margin-top: 5px; }

            .test-content, .review-content { padding: 5px; }
            .test-question, .review-item-question { font-size: 1em; }
            .test-options label, .review-item { padding: 10px; font-size: 0.95em;}
            .review-filters { margin-top: 5px; }
            .review-filters button { padding: 4px 8px; font-size: 0.85em; margin-right: 5px;}
            .test-navigation, .review-footer { padding-top: 10px; }
            .test-navigation button, #exit-review-btn, #save-review-btn { padding: 8px 15px; font-size: 0.9em; }
        }
    </style>
</head>
<body>

    <div class="app-container" id="app-container">
        <!-- Sidebar -->
        <div class="sidebar">
             <!-- Sidebar content -->
             <div class="sidebar-header">Gemini Chat</div>
             <div id="all-tests-section">
                 <div class="sidebar-section-title">All Tests</div>
                 <input type="search" id="test-search-input" placeholder="Search tests..." disabled>
                 <div class="all-tests-list" id="all-tests-list">
                      <div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">Login to see saved tests.</div>
                 </div>
             </div>
             <div class="sidebar-section">
                 <button class="start-chat-button" id="start-chat" disabled> <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"></path></svg>
                      Start new chat
                 </button>
                 <div class="sidebar-section-title">Chats</div>
                 <div class="chat-list" id="chat-list">
                      <div style="padding:10px;color:var(--text-secondary);font-size:0.9em;">Please log in to see chats.</div>
                 </div>
             </div>
             <div class="sidebar-footer">
                  <div class="sidebar-controls">
                      <div class="text-size-controls">
                          <span>Text Size</span>
                          <div class="text-size-buttons"> <button id="decrease-text-size" title="Decrease text size" disabled>-</button> <button id="increase-text-size" title="Increase text size" disabled>+</button> </div>
                      </div>
                      <div class="theme-toggle"> <button id="theme-toggle-button" title="Toggle Theme" disabled>☀️</button> </div>
                  </div>
                   <!-- Model Selector -->
                   <div class="model-selector-container">
                       <label for="model-selector">AI Model</label>
                       <select id="model-selector" disabled>
                            <!-- Options populated by JavaScript -->
                       </select>
                   </div>
                   <div id="auth-controls"> <button id="login-google-btn">Login with Google</button> <button id="logout-btn" style="display: none;">Logout</button> </div>
                   <div class="account-info">
                       <div class="account-avatar" id="account-avatar">?</div>
                       <div class="account-details"> <div class="account-email" id="account-email">Not logged in</div> <div class="account-plan" id="account-plan"></div> </div>
                   </div>
             </div>
        </div>

        <!-- Main container -->
        <div class="main-container">
            <div class="main-content active" id="main-content-chat">
                 <div class="chat-area" id="chat-area">
                     <!-- Greeting or Login Prompt -->
                 </div>
                 <div class="input-container" id="input-container">
                     <div class="suggestions" id="suggestions">
                          <button class="suggestion-chip" data-prompt="Summarize this document">Summarize this document</button>
                          <button class="suggestion-chip" data-prompt="Extract key points from this PDF">Extract key points from this PDF</button>
                          <button class="suggestion-chip" data-prompt="Describe this image">Describe this image</button>
                          <button class="suggestion-chip" data-prompt="Transcribe this audio">Transcribe this audio</button>
                     </div>
                    <div id="media-preview-container">
                        <div id="image-previews-list">
                            <!-- Image/PDF Previews -->
                        </div>
                        <div id="preview-audio-container">
                           <audio id="preview-audio" controls></audio>
                        </div>
                        <div class="media-preview-footer">
                            <span id="media-preview-info"></span>
                            <button id="remove-media-button" title="Remove all media">&times;</button>
                        </div>
                    </div>
                    <div id="recording-status">Recording... <span>0s</span></div>
                    <div class="input-box">
                         <input type="file" id="image-upload-input" accept="image/*" style="display: none;" multiple>
                         <input type="file" id="pdf-upload-input" accept="application/pdf" style="display: none;" multiple>
                         <input type="file" id="audio-upload-input" accept="audio/wav, audio/mp3, audio/mpeg, audio/aac, audio/ogg, audio/flac, audio/aiff" style="display: none;">
                         <div class="input-buttons">
                             <button id="image-upload-button" title="Upload image(s)" disabled>📎</button>
                             <button id="pdf-upload-button" title="Upload PDF file(s)" disabled>📄</button>
                             <button id="audio-upload-button" title="Upload audio file" disabled>🎵</button>
                             <button id="record-audio-button" title="Record audio" disabled>🎙️</button>
                         </div>
                         <textarea id="user-input" placeholder="Enter prompt, attach media, or paste URL" rows="1" disabled></textarea>
                         <div class="mcq-mode-control"> <input type="checkbox" id="mcq-mode-checkbox" title="Generate MCQs based on prompt/media" disabled> <label for="mcq-mode-checkbox">MCQs?</label> </div>
                         <button id="send-button" title="Send message" disabled> <svg viewBox="0 0 24 24"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"></path></svg>
                        </button>
                    </div>
                 </div>
            </div>
            <!-- Review View -->
            <div class="review-view" id="review-view">
                 <div class="review-header">
                     <h2 id="review-title">Test Review</h2>
                     <div class="review-summary" id="review-summary"></div>
                     <!-- ***** TAMIL ***** -->
                     <!-- Review view-க்கான மொழி மாற்று பொத்தான் -->
                     <div class="controls">
                        <div class="review-filters" id="review-filters" style="display: none;"> <button data-filter="all" class="active-filter">All</button> <button data-filter="incorrect">Incorrect</button> <button data-filter="skipped">Skipped</button> </div>
                        <button id="review-language-toggle" title="Switch Language">தமிழ்</button>
                     </div>
                 </div>
                 <div class="review-content" id="review-content"></div>
                 <div class="review-footer"> <button id="save-review-btn">Save Review</button> <button id="exit-review-btn">Back</button> </div>
              </div>
        </div>
    </div>
    <!-- Mock Test View -->
    <div class="mock-test-view" id="mock-test-view">
         <div class="test-header">
            <h2 id="test-title">Mock Test</h2>
            <div class="test-info">
                <span id="question-counter">Q: 1 / N</span>
                <span id="test-timer">Time: 00:00</span>
                <!-- ***** TAMIL ***** -->
                <!-- Test view-க்கான மொழி மாற்று பொத்தான் -->
                <button id="test-language-toggle" title="Switch Language">தமிழ்</button>
             </div>
         </div>
         <div class="test-content">
            <div class="test-question-container"> <div class="test-question-number" id="test-question-number"></div> <div class="test-question" id="test-question"></div> <div class="test-options" id="test-options"></div> </div>
         </div>
         <div class="test-navigation"> <button id="prev-question-btn" disabled>Previous</button> <button id="next-question-btn">Next</button> <button id="submit-test-btn">Submit Test</button> </div>
    </div>


    <script>
        // --- Firebase Config ---
        // ***** TAMIL *****
        // Firebase configuration. மாற்ற வேண்டாம்.
        const firebaseConfig = { /* ... Firebase config details ... */
          apiKey: "AIzaSyDgw604fe5jnNu4kTOv1cQ-3n7PL8gcN58",
          authDomain: "krish-c5db8.firebaseapp.com",
          projectId: "krish-c5db8",
          storageBucket: "krish-c5db8.appspot.com",
          messagingSenderId: "217175257890",
          appId: "1:217175257890:web:209f0f290eabab6b1fab7b",
          measurementId: "G-97SHYGL2J4"
         };

        // --- Initialize Firebase ---
        firebase.initializeApp(firebaseConfig);
        const fbAuth = firebase.auth();
        const db = firebase.firestore();

        // --- DOM Elements ---
        // ***** TAMIL *****
        // HTML elements-ஐ JavaScript variables-ல் store செய்கிறோம்.
        const appContainer = document.getElementById('app-container');
        const chatArea = document.getElementById('chat-area');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const suggestionsContainer = document.getElementById('suggestions');
        const startChatButton = document.getElementById('start-chat');
        const chatListContainer = document.getElementById('chat-list');
        const allTestsSection = document.getElementById('all-tests-section');
        const testSearchInput = document.getElementById('test-search-input');
        const allTestsListContainer = document.getElementById('all-tests-list');
        const accountEmail = document.getElementById('account-email');
        const accountAvatar = document.getElementById('account-avatar');
        const accountPlan = document.getElementById('account-plan');
        const decreaseTextBtn = document.getElementById('decrease-text-size');
        const increaseTextBtn = document.getElementById('increase-text-size');
        const themeToggleButton = document.getElementById('theme-toggle-button');
        const modelSelector = document.getElementById('model-selector');
        const mainContainer = document.querySelector('.main-container');
        const chatView = document.getElementById('main-content-chat');
        const testView = document.getElementById('mock-test-view');
        const reviewView = document.getElementById('review-view');
        const inputContainer = document.getElementById('input-container');
        const mcqModeCheckbox = document.getElementById('mcq-mode-checkbox');
        const loginBtn = document.getElementById('login-google-btn');
        const logoutBtn = document.getElementById('logout-btn');
        // Test & Review Elements
        const testTitle = document.getElementById('test-title');
        const questionCounter = document.getElementById('question-counter');
        const testTimer = document.getElementById('test-timer');
        const testLanguageToggle = document.getElementById('test-language-toggle'); // New
        const testQuestionNumber = document.getElementById('test-question-number');
        const testQuestion = document.getElementById('test-question');
        const testOptionsContainer = document.getElementById('test-options');
        const prevQuestionBtn = document.getElementById('prev-question-btn');
        const nextQuestionBtn = document.getElementById('next-question-btn');
        const submitTestBtn = document.getElementById('submit-test-btn');
        const reviewTitle = document.getElementById('review-title');
        const reviewSummary = document.getElementById('review-summary');
        const reviewLanguageToggle = document.getElementById('review-language-toggle'); // New
        const reviewContent = document.getElementById('review-content');
        const exitReviewBtn = document.getElementById('exit-review-btn');
        const reviewFilters = document.getElementById('review-filters');
        const saveReviewBtn = document.getElementById('save-review-btn');
        // Media Elements
        const imageUploadButton = document.getElementById('image-upload-button');
        const imageUploadInput = document.getElementById('image-upload-input');
        const pdfUploadButton = document.getElementById('pdf-upload-button');
        const pdfUploadInput = document.getElementById('pdf-upload-input');
        const audioUploadButton = document.getElementById('audio-upload-button');
        const audioUploadInput = document.getElementById('audio-upload-input');
        const recordAudioButton = document.getElementById('record-audio-button');
        // Media Preview Elements
        const mediaPreviewContainer = document.getElementById('media-preview-container');
        const imagePreviewsList = document.getElementById('image-previews-list');
        const previewAudioContainer = document.getElementById('preview-audio-container');
        const previewAudio = document.getElementById('preview-audio');
        const mediaPreviewInfo = document.getElementById('media-preview-info');
        const removeMediaButton = document.getElementById('remove-media-button');
        // Recording Status
        const recordingStatus = document.getElementById('recording-status');
        const recordingTimerSpan = recordingStatus.querySelector('span');

        // --- Config & Constants ---
        // ***** TAMIL *****
        // Application மாறிலிகள். புதிய models சேர்க்கப்பட்டுள்ளன.
        const AVAILABLE_MODELS = [
             { id: "gemini-2.0-flash", name: "Gemini 2.0 Flash", supportsCaching: false },
             { id: "gemini-2.5-pro-exp-03-25", name: "Gemini 2.5 Pro Exp", supportsCaching: false },
             { id: "gemini-1.5-flash-latest", name: "Gemini 1.5 Flash Latest", supportsCaching: false },
             { id: "gemini-1.5-pro-latest", name: "Gemini 1.5 Pro Latest", supportsCaching: false },
             { id: "gemini-1.5-flash-001", name: "Gemini 1.5 Flash 001 (Cache OK)", supportsCaching: true },
             { id: "gemini-1.5-pro-001", name: "Gemini 1.5 Pro 001 (Cache OK)", supportsCaching: true },
        ];
        const DEFAULT_MODEL_ID = AVAILABLE_MODELS[0].id; // Default to 2.0 Flash
        const STORAGE_KEY_API_KEY = 'geminiApiKey_insecureDemo';
        const STORAGE_KEY_MODEL_ID = 'geminiSelectedModelId';
        const NEW_CHAT_TITLE = "(New Chat)";
        const TEXT_SIZE_STEP = 0.1; const MIN_TEXT_SIZE_MULTIPLIER = 0.7; const MAX_TEXT_SIZE_MULTIPLIER = 1.5;
        const LIGHT_THEME_ICON = '☀️'; const DARK_THEME_ICON = '🌙';
        const DELETE_ICON = '×'; const EDIT_TEST_ICON = '✏️'; const DELETE_TEST_ICON = '🗑️';
        const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:watch\?v=|embed\/|v\/)|youtu\.be\/)([a-zA-Z0-9_-]{11})(?:\S+)?/i;
        const imageUrlRegex = /(?<!src=["'])(?<!href=["'])(https?:\/\/[^\s()<>]+?\.(?:jpg|jpeg|png|gif|webp|bmp))/gi;
        const MAX_IMAGE_SIZE_MB = 4; const MAX_TOTAL_IMAGE_SIZE_MB = 16; const MAX_IMAGE_COUNT = 5;
        const MAX_PDF_SIZE_MB = 50; const MAX_PDF_COUNT = 5;
        const MAX_AUDIO_SIZE_MB = 10; const SUPPORTED_AUDIO_MIMES = ['audio/wav', 'audio/mp3', 'audio/mpeg', 'audio/aiff', 'audio/aac', 'audio/ogg', 'audio/flac'];
        const RECORDING_TIME_LIMIT_SECONDS = 300; const FILE_API_POLLING_INTERVAL_MS = 5000; const FILE_API_PROCESSING_TIMEOUT_MS = 180000;
        const CACHE_TTL_SECONDS = 3600; // 1 hour

        // --- State Variables ---
        // ***** TAMIL *****
        // Application நிலை மாறிகள். Bilingual MCQ-க்கு புதிய மாறிகள்.
        let API_KEY = '';
        let genAI = null; let HarmCategory = null; let HarmBlockThreshold = null;
        let currentUser = null; let activeChatId = null; let currentChatHistory = [];
        let selectedModelId = DEFAULT_MODEL_ID;
        let currentTextSizeMultiplier = 1.0; let currentTheme = 'light';
        let isTestMode = false; let isReviewMode = false;
        let currentTestMCQs = []; let currentQuestionIndex = 0; let userAnswers = [];
        let testStartTime = null; let testTimerInterval = null; let reviewResultsCache = null;
        let cameFromAllTestsList = false;
        let activeChatListener = null; let chatListListener = null; let testListListener = null;
        let isDeletingChat = false; let allSavedTestsData = [];
        let selectedMediaItems = []; let nextMediaId = 0;
        // Audio Recording State
        let mediaRecorder = null; let audioChunks = []; let isRecording = false;
        let recordingStartTime = null; let recordingTimerInterval = null; let recorderStream = null;
        // SDK State
        let isAISdkReady = false;
        // Caching State
        let currentMediaCacheName = null; let cachedMediaUris = [];
        // Bilingual State
        let currentTestLanguage = 'en'; // 'en' or 'ta'
        let currentReviewLanguage = 'en'; // 'en' or 'ta'

        // --- Initialization ---
        initializeApp();

        // --- Event Listeners ---
        // ***** TAMIL *****
        // User actions-க்கான listeners. மொழி மாற்று பொத்தான்களுக்கும் listener சேர்க்கப்பட்டுள்ளது.
        sendButton.addEventListener('click', handleSendMessage);
        userInput.addEventListener('input', autoGrowTextarea);
        userInput.addEventListener('keydown', handleInputKeydown);
        suggestionsContainer.addEventListener('click', handleSuggestionClick);
        startChatButton.addEventListener('click', createNewChat);
        chatListContainer.addEventListener('click', handleChatListClick);
        allTestsListContainer.addEventListener('click', handleAllTestsListClick);
        testSearchInput.addEventListener('input', filterTestsInSidebar);
        decreaseTextBtn.addEventListener('click', () => adjustTextSize(-TEXT_SIZE_STEP));
        increaseTextBtn.addEventListener('click', () => adjustTextSize(TEXT_SIZE_STEP));
        themeToggleButton.addEventListener('click', toggleTheme);
        modelSelector.addEventListener('change', handleModelSelectionChange);
        prevQuestionBtn.addEventListener('click', () => handleTestNavigation('prev'));
        nextQuestionBtn.addEventListener('click', () => handleTestNavigation('next'));
        submitTestBtn.addEventListener('click', submitTest);
        exitReviewBtn.addEventListener('click', exitReview);
        chatArea.addEventListener('click', handleChatAreaClick);
        reviewFilters.addEventListener('click', handleReviewFilterClick);
        saveReviewBtn.addEventListener('click', saveTestReviewToCloud);
        loginBtn.addEventListener('click', signInWithGoogle);
        logoutBtn.addEventListener('click', signOut);
        // Media Listeners
        imageUploadButton.addEventListener('click', () => { if (!imageUploadButton.disabled) imageUploadInput.click(); });
        imageUploadInput.addEventListener('change', handleImageFileSelect);
        pdfUploadButton.addEventListener('click', () => { if (!pdfUploadButton.disabled) pdfUploadInput.click(); });
        pdfUploadInput.addEventListener('change', handlePdfFileSelect);
        audioUploadButton.addEventListener('click', () => { if (!audioUploadButton.disabled) audioUploadInput.click(); });
        audioUploadInput.addEventListener('change', handleAudioFileSelect);
        recordAudioButton.addEventListener('click', () => { if (!recordAudioButton.disabled || isRecording) { toggleRecording(); } });
        removeMediaButton.addEventListener('click', removeAllSelectedMedia);
        // Language Toggles
        testLanguageToggle.addEventListener('click', toggleTestLanguage);
        reviewLanguageToggle.addEventListener('click', toggleReviewLanguage);

        // Listen for SDK loaded event
        window.addEventListener('google-ai-sdk-loaded', () => { /* ... same as v10.1 ... */
             console.log("Caught 'google-ai-sdk-loaded' event."); isAISdkReady = true; HarmCategory = window.HarmCategory; HarmBlockThreshold = window.HarmBlockThreshold; if (API_KEY && !genAI) { initializeGenAIInstance(); if(currentUser) { updateButtonStates(); } }
        });

        // --- Initialization Functions ---
        async function initializeApp() { /* ... same as v10.1 ... */
             console.log("App Initializing (v10.2)..."); setLoadingState(true, "Initializing..."); chatArea.innerHTML = ''; populateModelSelector(); loadUserSettingsFromLocalStorage(); await loadGeminiApiKey(); fbAuth.onAuthStateChanged(handleAuthStateChange); switchView('chat'); userInput.focus(); console.log("App Initialization Complete.");
        }
        function populateModelSelector() { /* ... same as v10.1 ... */
             modelSelector.innerHTML = ''; AVAILABLE_MODELS.forEach(model => { const option = document.createElement('option'); option.value = model.id; option.textContent = model.name; if (model.id === selectedModelId) { option.selected = true; } modelSelector.appendChild(option); });
        }
        async function loadGeminiApiKey() { /* ... same as v10.1 ... */
             console.log("Attempting to load Gemini API Key..."); API_KEY = localStorage.getItem(STORAGE_KEY_API_KEY); if(!API_KEY){ console.warn("!!! SECURITY WARNING !!! Using insecure API key storage."); /* API_KEY = "YOUR_API_KEY"; */ if(API_KEY){ localStorage.setItem(STORAGE_KEY_API_KEY, API_KEY); console.log("Using potentially hardcoded insecure API Key."); } else { console.error("Gemini API Key is required."); displayMessage("Error: Gemini API Key not configured.", 'ai', ['error-message']); API_KEY = ''; genAI = null; isAISdkReady = false; updateButtonStates(); return false; } } else { console.log("Loaded insecure API Key."); } if (API_KEY && isAISdkReady && !genAI) { return initializeGenAIInstance(); } else if (API_KEY && !isAISdkReady) { console.log("API Key loaded, waiting for SDK."); return true; } else { return !!API_KEY; }
        }
        function initializeGenAIInstance() { /* ... same as v10.1 ... */
            if (!API_KEY || !isAISdkReady) { console.warn("Skipping genAI initialization.", { API_KEY: !!API_KEY, isAISdkReady }); return false; } if (!HarmCategory || !HarmBlockThreshold) { console.error("Harm enums not loaded."); displayError("Error: Failed to load safety components."); genAI = null; isAISdkReady = false; updateButtonStates(); return false; } if (genAI) { genAI = null; console.log("Re-initializing genAI instance."); } console.log("Initializing GoogleGenerativeAI SDK instance..."); try { if (window.GoogleGenerativeAI) { genAI = new window.GoogleGenerativeAI(API_KEY); console.log("genAI object created:", genAI != null); if (genAI && genAI.files) { console.log("SUCCESS: File API support found."); return true; } else { console.warn("WARNING: `genAI.files` MISSING. File uploads/caching might fail."); return true; } } else { console.error("ERROR: GoogleGenerativeAI SDK constructor not found."); displayError("Error: AI SDK failed to initialize."); genAI = null; isAISdkReady = false; return false; } } catch (e) { console.error("CRITICAL ERROR initializing GoogleGenerativeAI:", e); displayError(`Critical Error initializing AI SDK: ${e.message}.`); API_KEY = ''; localStorage.removeItem(STORAGE_KEY_API_KEY); genAI = null; isAISdkReady = false; return false; } finally { updateButtonStates(); }
        }

        // --- Authentication Functions ---
        async function signInWithGoogle() { /* ... same as v10.1 ... */ const provider = new firebase.auth.GoogleAuthProvider(); try { setLoadingState(true, "Logging in..."); await fbAuth.signInWithPopup(provider); } catch (error) { console.error("Google Sign-In Error:", error); displayError(`Login failed: ${error.message || 'Unknown error'}`); setLoadingState(false); } }
        async function signOut() { /* ... same as v10.1 ... */ try { setLoadingState(true, "Logging out..."); await fbAuth.signOut(); } catch (error) { console.error("Sign Out Error:", error); displayError(`Logout failed: ${error.message || 'Unknown error'}`); setLoadingState(false); } }
        function handleAuthStateChange(user) { /* ... same as v10.1 ... */
            console.log("Auth state changed. User:", user ? user.uid : 'None'); setLoadingState(true, user ? "Loading user data..." : "Logging out..."); if (activeChatListener) { activeChatListener(); activeChatListener = null; } if (chatListListener) { chatListListener(); chatListListener = null; } if (testListListener) { testListListener(); testListListener = null; } stopRecording(true); chatArea.innerHTML = ''; chatListContainer.innerHTML = `<div style="padding:10px;color:var(--text-secondary);">${user ? 'Loading...' : 'Log in...'}</div>`; allTestsListContainer.innerHTML = `<div style="padding:10px;color:var(--text-secondary);">${user ? 'Loading...' : 'Log in...'}</div>`; allTestsSection.classList.remove('visible'); testSearchInput.value = ''; activeChatId = null; currentChatHistory = []; isDeletingChat = false; allSavedTestsData = []; currentMediaCacheName = null; cachedMediaUris = []; removeAllSelectedMedia(); if (user) { currentUser = user; loginBtn.style.display = 'none'; logoutBtn.style.display = 'inline-block'; accountEmail.textContent = currentUser.email || currentUser.displayName || `User`; accountAvatar.textContent = (currentUser.displayName || currentUser.email || 'U')[0].toUpperCase(); accountPlan.textContent = "Firebase User"; inputContainer.style.display = 'block'; suggestionsContainer.style.display = 'flex'; allTestsSection.classList.add('visible'); loadUserSettings(currentUser.uid); loadAndListenForChats(currentUser.uid); loadAndListenForTests(currentUser.uid); renderGreetingOrLoginPrompt(); } else { currentUser = null; loginBtn.style.display = 'inline-block'; logoutBtn.style.display = 'none'; accountEmail.textContent = "Not logged in"; accountAvatar.textContent = '?'; accountPlan.textContent = ""; inputContainer.style.display = 'none'; suggestionsContainer.style.display = 'none'; allTestsSection.classList.remove('visible'); renderGreetingOrLoginPrompt(); currentTheme = 'light'; applyTheme(); currentTextSizeMultiplier = 1.0; applyTextSize(); selectedModelId = DEFAULT_MODEL_ID; applyModelSelection(); } updateButtonStates(); setLoadingState(false);
        }
        function renderGreetingOrLoginPrompt() { /* ... same as v10.1 ... */
             chatArea.innerHTML = ''; const greetingElement = document.createElement('div'); greetingElement.classList.add('greeting'); if (currentUser) { greetingElement.innerHTML = `<span class="asterisk">*</span>Nice to meet you, ${currentUser.displayName || 'User'}! How can I help today?`; chatArea.appendChild(greetingElement); if (!activeChatId) { displayMessage("Select a chat or start a new one.", 'ai'); } else if (!API_KEY || !genAI) { displayMessage("API Key/SDK Error.", 'ai', ['error-message']); } else if (genAI && !genAI.files) { displayMessage("File API unavailable. PDF uploads disabled.", 'ai', ['error-message']); } } else { greetingElement.innerHTML = `<span class="asterisk">*</span>Welcome!`; chatArea.appendChild(greetingElement); displayMessage("Log in with Google to chat and save history.", 'ai'); } scrollToBottom(true);
        }

        // --- Settings (Theme/Text Size/Model) ---
        // ***** TAMIL *****
        // Settings load/save functions. மாற்றங்கள் இல்லை.
        function loadUserSettingsFromLocalStorage() { /* ... same as v10.1 ... */ const savedTheme = localStorage.getItem('chatTheme'); const savedTextSize = localStorage.getItem('chatTextSizeMultiplier'); const savedModelId = localStorage.getItem(STORAGE_KEY_MODEL_ID); currentTheme = savedTheme || 'light'; currentTextSizeMultiplier = savedTextSize ? parseFloat(savedTextSize) : 1.0; selectedModelId = AVAILABLE_MODELS.some(m => m.id === savedModelId) ? savedModelId : DEFAULT_MODEL_ID; applyTheme(); applyTextSize(); applyModelSelection(); }
        async function loadUserSettings(userId) { /* ... same as v10.1 ... */ const userDocRef = db.collection('users').doc(userId); try { const docSnap = await userDocRef.get(); if (docSnap.exists) { const settings = docSnap.data(); currentTheme = settings.theme || currentTheme; currentTextSizeMultiplier = settings.textSizeMultiplier || currentTextSizeMultiplier; const firestoreModelId = settings.selectedModelId; selectedModelId = AVAILABLE_MODELS.some(m => m.id === firestoreModelId) ? firestoreModelId : selectedModelId; console.log("Loaded settings from Firestore:", settings); } else { console.log("No settings found in Firestore."); } } catch (error) { console.error("Error loading settings:", error); } finally { applyTheme(); applyTextSize(); applyModelSelection(); } }
        async function saveUserSettings() { /* ... same as v10.1 ... */ localStorage.setItem('chatTheme', currentTheme); localStorage.setItem('chatTextSizeMultiplier', currentTextSizeMultiplier.toString()); localStorage.setItem(STORAGE_KEY_MODEL_ID, selectedModelId); if (!currentUser) return; const userDocRef = db.collection('users').doc(currentUser.uid); const settings = { theme: currentTheme, textSizeMultiplier: currentTextSizeMultiplier, selectedModelId: selectedModelId }; try { await userDocRef.set(settings, { merge: true }); console.log("Settings saved to Firestore:", settings); } catch (error) { console.error("Error saving settings:", error); } }
        function applyTheme() { /* ... same as v10.1 ... */ if(currentTheme==='dark'){ document.body.classList.add('dark-theme'); themeToggleButton.textContent=LIGHT_THEME_ICON; themeToggleButton.title="Switch to Light Theme"; } else { document.body.classList.remove('dark-theme'); themeToggleButton.textContent=DARK_THEME_ICON; themeToggleButton.title="Switch to Dark Theme"; } }
        function toggleTheme() { /* ... same as v10.1 ... */ currentTheme = (currentTheme === 'light') ? 'dark' : 'light'; applyTheme(); saveUserSettings(); }
        function applyTextSize() { /* ... same as v10.1 ... */ const newSize = `calc(var(--message-font-size-base) * ${currentTextSizeMultiplier})`; document.documentElement.style.setProperty('--message-font-size', newSize); updateButtonStates(); }
        function adjustTextSize(change) { /* ... same as v10.1 ... */ let newMultiplier = Math.max(MIN_TEXT_SIZE_MULTIPLIER, Math.min(MAX_TEXT_SIZE_MULTIPLIER, currentTextSizeMultiplier + change)); newMultiplier = Math.round(newMultiplier * 10) / 10; if (newMultiplier !== currentTextSizeMultiplier) { currentTextSizeMultiplier = newMultiplier; applyTextSize(); saveUserSettings(); } }
        function applyModelSelection() { /* ... same as v10.1 ... */ if (modelSelector) { modelSelector.value = selectedModelId; console.log(`Applied model: ${selectedModelId}`); } const modelInfo = AVAILABLE_MODELS.find(m => m.id === selectedModelId); if (currentMediaCacheName && (!modelInfo || !modelInfo.supportsCaching)) { console.warn(`Model ${selectedModelId} might not support caching. Clearing cache state.`); currentMediaCacheName = null; cachedMediaUris = []; } }
        function handleModelSelectionChange(event) { /* ... same as v10.1 ... */ const newModelId = event.target.value; if (newModelId !== selectedModelId) { console.log(`Model changed to: ${newModelId}`); selectedModelId = newModelId; applyModelSelection(); saveUserSettings(); const modelInfo = AVAILABLE_MODELS.find(m => m.id === selectedModelId); if (modelInfo && !modelInfo.supportsCaching) { console.warn(`Selected model might not support caching.`); } else if (modelInfo && modelInfo.supportsCaching) { console.log(`Selected model should support caching.`); } } }

        // --- Chat Storage & Loading (Firestore) ---
        // ***** TAMIL *****
        // Chat history load/save functions. மாற்றங்கள் இல்லை.
        function loadAndListenForChats(userId) { /* ... same as v10.1 ... */ if (chatListListener) { chatListListener(); chatListListener = null; } const chatsRef = db.collection('chats').where('userId', '==', userId).orderBy('lastUpdated', 'desc'); console.log(`Listening for chats for ${userId}`); chatListListener = chatsRef.onSnapshot(snapshot => { if (isDeletingChat) return; const chats = []; snapshot.forEach(doc => { chats.push({ id: doc.id, ...doc.data() }); }); console.log("Got chat list:", chats.length); renderSidebarChatList(chats); let chatToLoad = activeChatId; if (!chatToLoad || !chats.some(c => c.id === chatToLoad)) { chatToLoad = chats.length > 0 ? chats[0].id : null; if (!chatToLoad) console.log("No active/existing chats."); } if (chatToLoad && chatToLoad !== activeChatId) { switchChat(chatToLoad); } else if (chatToLoad && chatToLoad === activeChatId) { highlightActiveChatInSidebar(); updateButtonStates(); setLoadingState(false); } else { activeChatId = null; currentChatHistory = []; if (activeChatListener) { activeChatListener(); activeChatListener = null; } renderGreetingOrLoginPrompt(); updateButtonStates(); setLoadingState(false); currentMediaCacheName = null; cachedMediaUris = []; } }, error => { console.error("Error listening chats:", error); displayError("Could not load chats."); chatListContainer.innerHTML = '<div style="padding:10px;color:var(--error-text);">Error loading.</div>'; setLoadingState(false); }); }
        function renderSidebarChatList(chats) { /* ... same as v10.1 ... */ chatListContainer.innerHTML = ''; if (!currentUser) { chatListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);">Log in.</div>'; return; } if (chats.length === 0) { chatListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);">No chats yet.</div>'; } else { chats.forEach(chatData => { const itemElement = document.createElement('div'); itemElement.classList.add('chat-list-item'); let title = chatData.title; if (typeof title !== 'string' || !title.trim()) { title = '(Untitled Chat)'; } title = title.trim(); itemElement.textContent = title; itemElement.dataset.id = chatData.id; itemElement.title = title; const deleteBtn = document.createElement('button'); deleteBtn.classList.add('delete-chat-button'); deleteBtn.innerHTML = DELETE_ICON; deleteBtn.title = "Delete chat"; deleteBtn.dataset.id = chatData.id; itemElement.appendChild(deleteBtn); chatListContainer.appendChild(itemElement); }); } highlightActiveChatInSidebar(); }
        function highlightActiveChatInSidebar() { /* ... same as v10.1 ... */ const items = chatListContainer.querySelectorAll('.chat-list-item'); items.forEach(item => { item.classList.toggle('active', item.dataset.id === activeChatId); }); }

        // --- Media Handling Functions ---
        // ***** TAMIL *****
        // Media upload functions. மாற்றங்கள் இல்லை.
        function handleImageFileSelect(event) { /* ... same as v10.1 ... */ console.log("handleImageFileSelect"); if (selectedMediaItems.some(item => item.type === 'pdf' || item.type === 'audio')) { alert("Cannot select images with PDF(s) or audio."); imageUploadInput.value = ''; return; } const files = event.target.files; if (!files || files.length === 0) { imageUploadInput.value = ''; return; } let currentImageCount = selectedMediaItems.filter(item => item.type === 'image').length; let addedCount = 0; let totalSizeMB = selectedMediaItems.reduce((sum, item) => sum + (item.file?.size || 0), 0) / 1024 / 1024; const allowedTypes = ['image/jpeg', 'image/png', 'image/webp', 'image/gif', 'image/bmp']; for (const file of files) { if (currentImageCount >= MAX_IMAGE_COUNT) { alert(`Max ${MAX_IMAGE_COUNT} images.`); break; } if (!allowedTypes.includes(file.type)) { console.warn(`Skipping invalid type: ${file.name}`); continue; } const fileSizeMB = file.size / 1024 / 1024; if (fileSizeMB > MAX_IMAGE_SIZE_MB) { alert(`Image "${file.name}" exceeds ${MAX_IMAGE_SIZE_MB}MB.`); continue; } if (totalSizeMB + fileSizeMB > MAX_TOTAL_IMAGE_SIZE_MB) { alert(`Adding "${file.name}" exceeds total limit.`); break; } const mediaId = nextMediaId++; selectedMediaItems.push({ id: mediaId, type: 'image', file: file, base64: null, mimeType: file.type, name: file.name }); currentImageCount++; totalSizeMB += fileSizeMB; addedCount++; } if (addedCount > 0) { console.log(`Added ${addedCount} images.`); displayMediaPreview(); } imageUploadInput.value = ''; }
        function handlePdfFileSelect(event) { /* ... same as v10.1 ... */ console.log("handlePdfFileSelect"); if (selectedMediaItems.some(item => item.type === 'image' || item.type === 'audio')) { alert("Cannot select PDF(s) with image(s) or audio."); pdfUploadInput.value = ''; return; } if (!genAI || !genAI.files) { alert("PDF upload disabled (File API unavailable)."); pdfUploadInput.value = ''; return; } const files = event.target.files; if (!files || files.length === 0) { pdfUploadInput.value = ''; return; } let currentPdfCount = selectedMediaItems.filter(item => item.type === 'pdf').length; let addedCount = 0; for (const file of files) { if (currentPdfCount >= MAX_PDF_COUNT) { alert(`Max ${MAX_PDF_COUNT} PDFs.`); break; } if (file.type !== 'application/pdf') { console.warn(`Skipping non-PDF: ${file.name}`); continue; } const fileSizeMB = file.size / 1024 / 1024; if (fileSizeMB > MAX_PDF_SIZE_MB) { alert(`PDF "${file.name}" exceeds ${MAX_PDF_SIZE_MB}MB (preview limit).`); console.warn(`Large PDF: ${fileSizeMB.toFixed(1)}MB`); } const mediaId = nextMediaId++; selectedMediaItems.push({ id: mediaId, type: 'pdf', file: file, name: file.name, mimeType: file.type }); currentPdfCount++; addedCount++; } if (addedCount > 0) { console.log(`Added ${addedCount} PDFs.`); displayMediaPreview(); } pdfUploadInput.value = ''; }
        function handleAudioFileSelect(event) { /* ... same as v10.1 ... */ console.log("handleAudioFileSelect"); if (selectedMediaItems.some(item => item.type === 'image' || item.type === 'pdf')) { alert("Cannot select audio with image(s) or PDF(s)."); audioUploadInput.value = ''; return; } removeAllSelectedMedia(); const file = event.target.files[0]; if (!file) { audioUploadInput.value = ''; return; } if (!SUPPORTED_AUDIO_MIMES.includes(file.type)) { alert(`Unsupported audio type: ${file.type}.`); audioUploadInput.value = ''; return; } const fileSizeMB = file.size / 1024 / 1024; if (fileSizeMB > MAX_AUDIO_SIZE_MB) { alert(`Audio too large (${fileSizeMB.toFixed(1)}MB). Max ${MAX_AUDIO_SIZE_MB}MB.`); audioUploadInput.value = ''; return; } const reader = new FileReader(); reader.onload = (e) => { const mediaId = nextMediaId++; selectedMediaItems = [{ id: mediaId, type: 'audio', file: file, base64: e.target.result, mimeType: file.type, name: file.name }]; console.log("Audio selected:", file.name); displayMediaPreview(); }; reader.onerror = (error) => { console.error("Error reading audio:", error); alert("Error reading audio."); removeAllSelectedMedia(); }; audioUploadInput.value = ''; reader.readAsDataURL(file); }
        function displayMediaPreview() { /* ... same as v10.1 ... */ console.log("displayMediaPreview.", { count: selectedMediaItems.length }); imagePreviewsList.innerHTML = ''; previewAudioContainer.style.display = 'none'; previewAudio.removeAttribute('src'); mediaPreviewInfo.textContent = ''; imagePreviewsList.style.display = 'none'; imagePreviewsList.style.flexDirection = ''; imagePreviewsList.style.alignItems = ''; if (selectedMediaItems.length === 0) { mediaPreviewContainer.style.display = 'none'; return; } const audioItem = selectedMediaItems.find(item => item.type === 'audio'); const imageItems = selectedMediaItems.filter(item => item.type === 'image'); const pdfItems = selectedMediaItems.filter(item => item.type === 'pdf'); let infoText = ""; if (audioItem) { imagePreviewsList.style.display = 'none'; try { previewAudio.src = audioItem.base64; previewAudio.load(); previewAudioContainer.style.display = 'flex'; infoText = `1 audio: ${audioItem.name || 'Audio'}`; } catch (e) { console.error("Error setting audio src:", e); infoText = 'Error loading audio'; } } else if (imageItems.length > 0) { previewAudioContainer.style.display = 'none'; imagePreviewsList.style.display = 'flex'; imagePreviewsList.style.flexDirection = 'row'; imagePreviewsList.style.alignItems = 'flex-start'; imageItems.forEach(item => { if (!item.base64) { const reader = new FileReader(); reader.onload = (e) => { item.base64 = e.target.result; renderImagePreviewItem(item); }; reader.onerror = () => { item.base64 = '#error'; renderImagePreviewItem(item); }; reader.readAsDataURL(item.file); } else { renderImagePreviewItem(item); } }); infoText = `${imageItems.length} image(s)`; } else if (pdfItems.length > 0) { previewAudioContainer.style.display = 'none'; imagePreviewsList.style.display = 'flex'; imagePreviewsList.style.flexDirection = 'column'; imagePreviewsList.style.alignItems = 'stretch'; pdfItems.forEach(item => renderPdfPreviewItem(item)); infoText = `${pdfItems.length} PDF(s)`; } mediaPreviewInfo.textContent = infoText; mediaPreviewContainer.style.display = 'flex'; }
        function renderImagePreviewItem(item) { /* ... same as v10.1 ... */ try { const existingItem = imagePreviewsList.querySelector(`.image-preview-item[data-media-id="${item.id}"]`); if (existingItem) return; const itemContainer = document.createElement('div'); itemContainer.classList.add('image-preview-item'); itemContainer.dataset.mediaId = item.id; const img = document.createElement('img'); img.src = item.base64 === '#error' ? '' : (item.base64 || ''); img.alt = item.base64 === '#error' ? 'Err' : (item.name || 'Img'); img.title = item.name || 'Image'; img.onerror = () => { img.alt = "Err"; }; const removeBtn = document.createElement('button'); removeBtn.classList.add('remove-image-item-button'); removeBtn.innerHTML = '&times;'; removeBtn.title = `Remove ${item.name || 'image'}`; removeBtn.onclick = (e) => { e.stopPropagation(); removeSelectedMediaItem(item.id); }; itemContainer.appendChild(img); itemContainer.appendChild(removeBtn); imagePreviewsList.appendChild(itemContainer); } catch (e) { console.error("Error creating image preview:", e); } }
        function renderPdfPreviewItem(item) { /* ... same as v10.1 ... */ try { const existingItem = imagePreviewsList.querySelector(`.pdf-preview-item[data-media-id="${item.id}"]`); if (existingItem) return; const itemContainer = document.createElement('div'); itemContainer.classList.add('pdf-preview-item'); itemContainer.dataset.mediaId = item.id; const icon = document.createElement('span'); icon.textContent = '📄'; icon.style.marginRight = '4px'; const nameSpan = document.createElement('span'); nameSpan.textContent = item.name || 'PDF File'; nameSpan.title = item.name || 'PDF File'; const removeBtn = document.createElement('button'); removeBtn.innerHTML = '&times;'; removeBtn.title = `Remove ${item.name || 'PDF'}`; removeBtn.onclick = (e) => { e.stopPropagation(); removeSelectedMediaItem(item.id); }; itemContainer.appendChild(icon); itemContainer.appendChild(nameSpan); itemContainer.appendChild(removeBtn); imagePreviewsList.appendChild(itemContainer); } catch (e) { console.error("Error creating PDF preview:", e); } }
        function removeSelectedMediaItem(mediaId) { /* ... same as v10.1 ... */ console.log(`Removing media: ${mediaId}`); selectedMediaItems = selectedMediaItems.filter(item => item.id !== mediaId); displayMediaPreview(); if (currentMediaCacheName && !selectedMediaItems.some(item => item.type === 'pdf')) { console.log("Removed cached media type. Clearing cache state."); currentMediaCacheName = null; cachedMediaUris = []; } }
        function removeAllSelectedMedia() { /* ... same as v10.1 ... */ console.log("removeAllSelectedMedia"); stopRecording(true); selectedMediaItems = []; nextMediaId = 0; imagePreviewsList.innerHTML = ''; previewAudio.removeAttribute('src'); previewAudioContainer.style.display = 'none'; mediaPreviewContainer.style.display = 'none'; mediaPreviewInfo.textContent = ''; imagePreviewsList.style.flexDirection = ''; imagePreviewsList.style.alignItems = ''; imageUploadInput.value = ''; pdfUploadInput.value = ''; audioUploadInput.value = ''; if (currentMediaCacheName) { console.log("Clearing cache state."); currentMediaCacheName = null; cachedMediaUris = []; } console.log("Media removed, inputs reset, cache cleared."); }

        // --- Audio Recording Functions ---
        // ***** TAMIL *****
        // Audio recording functions. மாற்றங்கள் இல்லை.
        async function toggleRecording() { /* ... same as v10.1 ... */ if (isRecording) { stopRecording(); } else { if (selectedMediaItems.some(item => item.type === 'image' || item.type === 'pdf')) { alert("Cannot record with other media selected."); return; } if (sendButton.disabled && !isRecording) { const appReady = currentUser && API_KEY && genAI && activeChatId; if (!appReady || userInput.placeholder.includes("Generating") || userInput.placeholder.includes("Sending") || userInput.placeholder.includes("Uploading") || userInput.placeholder.includes("Recording")) { alert("Wait for current action."); return; } } await startRecording(); } }
        async function startRecording() { /* ... same as v10.1 ... */ console.log("Attempting start recording..."); if (selectedMediaItems.length > 0) { alert("Remove other media first."); return; } if (!navigator.mediaDevices?.getUserMedia) { alert("Recording not supported."); return; } try { console.log("Requesting mic access..."); if (recorderStream) { recorderStream.getTracks().forEach(t => t.stop()); recorderStream = null; } const stream = await navigator.mediaDevices.getUserMedia({ audio: true }); recorderStream = stream; console.log("Mic access granted."); recordAudioButton.disabled = true; let options = {}; const preferredMimeTypes = ['audio/ogg;codecs=opus', 'audio/webm;codecs=opus', 'audio/aac', 'audio/mp4']; for (const mimeType of preferredMimeTypes) { if (MediaRecorder.isTypeSupported(mimeType)) { options.mimeType = mimeType; break; } } mediaRecorder = new MediaRecorder(stream, options); const actualMimeType = mediaRecorder.mimeType; console.log("MediaRecorder init.", { options, actualMimeType }); audioChunks = []; mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) audioChunks.push(e.data); }; mediaRecorder.onstop = () => { console.log("Recorder stopped.", { chunks: audioChunks.length }); if (recorderStream) { recorderStream.getTracks().forEach(t => t.stop()); recorderStream = null; } isRecording = false; recordingStatus.classList.remove('visible'); recordAudioButton.classList.remove('recording'); recordAudioButton.textContent = '🎙️'; recordAudioButton.title = 'Record'; if (recordingTimerInterval) { clearInterval(recordingTimerInterval); recordingTimerInterval = null; } if (audioChunks.length === 0) { console.warn("No audio data."); setLoadingState(false); updateButtonStates(); return; } const audioBlob = new Blob(audioChunks, { type: actualMimeType }); audioChunks = []; const fileSizeMB = audioBlob.size / 1024 / 1024; console.log(`Recording complete.`, { sizeMB: fileSizeMB.toFixed(3), type: actualMimeType }); if (audioBlob.size === 0) { alert("Recording failed: No data."); setLoadingState(false); updateButtonStates(); return; } if (fileSizeMB > MAX_AUDIO_SIZE_MB) { alert(`Audio too large (${fileSizeMB.toFixed(1)}MB).`); setLoadingState(false); updateButtonStates(); return; } const reader = new FileReader(); setLoadingState(true, "Processing audio..."); reader.onloadend = () => { if (reader.result && typeof reader.result === 'string' && reader.result.startsWith('data:')) { let finalMimeType = actualMimeType.split(';')[0]; const mediaId = nextMediaId++; selectedMediaItems = [{ id: mediaId, type: 'audio', file: new File([audioBlob], `rec.audio`, { type: finalMimeType }), base64: reader.result, mimeType: finalMimeType, name: `rec-${new Date().toISOString().substring(0, 19).replace(/[:T]/g, '-')}.${finalMimeType.split('/')[1] || 'audio'}` }]; displayMediaPreview(); } else { console.error("FileReader invalid result."); alert("Error processing audio."); } setLoadingState(false); updateButtonStates(); }; reader.onerror = (error) => { console.error("Error converting blob:", error); alert("Error processing audio."); setLoadingState(false); updateButtonStates(); }; reader.readAsDataURL(audioBlob); }; mediaRecorder.onerror = (e) => { console.error("MediaRecorder error:", e.error || e); alert(`Recording error: ${e.error?.name || 'Unknown'}`); stopRecording(true); }; mediaRecorder.start(); isRecording = true; recordingStartTime = Date.now(); recordAudioButton.classList.add('recording'); recordAudioButton.textContent = '🛑'; recordAudioButton.title = 'Stop'; recordingStatus.classList.add('visible'); recordingTimerSpan.textContent = '0s'; setLoadingState(true, "Recording..."); recordingTimerInterval = setInterval(() => { const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000); recordingTimerSpan.textContent = `${elapsed}s`; if (elapsed >= RECORDING_TIME_LIMIT_SECONDS) { console.log("Time limit."); stopRecording(); alert(`Stopped after ${RECORDING_TIME_LIMIT_SECONDS}s.`); } }, 1000); console.log("Recording started."); recordAudioButton.disabled = false; } catch (error) { console.error("Error starting recording:", error); if (error.name === 'NotAllowedError') alert("Mic access denied."); else if (error.name === 'NotFoundError') alert("No mic found."); else alert(`Could not start recording: ${error.name}`); stopRecording(true); } }
        function stopRecording(force = false) { /* ... same as v10.1 ... */ console.log("stopRecording.", { isRecording, force }); if (mediaRecorder && (isRecording || force)) { try { if (mediaRecorder.state === "recording" || mediaRecorder.state === "paused") { mediaRecorder.stop(); console.log("MediaRecorder.stop() called."); if (force && !isRecording) { resetRecordingUI(); setLoadingState(false); } } else if (force) { console.log("Forcing cleanup."); resetRecordingUI(); setLoadingState(false); } } catch (error) { console.error("Error stopping recorder:", error); resetRecordingUI(); setLoadingState(false); } } else if (force) { console.log("Forced stop, no recorder."); resetRecordingUI(); setLoadingState(false); } else { console.log("Not recording/no recorder."); if (!isRecording) { setLoadingState(false); updateButtonStates(); } } }
        function resetRecordingUI() { /* ... same as v10.1 ... */ console.log("Resetting recording UI."); isRecording = false; if (recordAudioButton) { recordAudioButton.classList.remove('recording'); recordAudioButton.textContent = '🎙️'; recordAudioButton.title = 'Record'; } if (recordingStatus) recordingStatus.classList.remove('visible'); if (recordingTimerInterval) { clearInterval(recordingTimerInterval); recordingTimerInterval = null; } if (recorderStream) { recorderStream.getTracks().forEach(t => t.stop()); recorderStream = null; } mediaRecorder = null; audioChunks = []; updateButtonStates(); }

        // --- Chat Creation, Deletion, Switching ---
        // ***** TAMIL *****
        // Chat management functions. மாற்றங்கள் இல்லை.
        async function createNewChat() { /* ... same as v10.1 ... */ if (!currentUser || startChatButton.disabled) { displayError("Log in or wait."); return; } setLoadingState(true, "Creating chat..."); removeAllSelectedMedia(); const newChatRef = db.collection('chats').doc(); const timestamp = firebase.firestore.FieldValue.serverTimestamp(); try { await newChatRef.set({ userId: currentUser.uid, title: NEW_CHAT_TITLE, createdAt: timestamp, lastUpdated: timestamp }); console.log("New chat created:", newChatRef.id); } catch (error) { console.error("Error creating chat:", error); displayError("Failed to create chat."); setLoadingState(false); } }
        function handleChatListClick(event) { /* ... same as v10.1 ... */ const target = event.target; const deleteButton = target.closest('.delete-chat-button'); if (deleteButton) { event.stopPropagation(); const chatId = deleteButton.dataset.id; const chatListItem = deleteButton.closest('.chat-list-item'); const chatTitle = chatListItem?.textContent?.replace(deleteButton.textContent, '').trim() || 'this chat'; if (chatId) { confirmAndDeleteChat(chatId, chatTitle); } return; } const item = target.closest('.chat-list-item'); const clickedId = item?.dataset?.id; if (item && clickedId && clickedId !== activeChatId) { switchChat(clickedId); } }
        function confirmAndDeleteChat(chatId, chatTitle) { /* ... same as v10.1 ... */ if (!currentUser || !chatId) return; if (confirm(`Delete chat "${chatTitle}"?`)) { deleteChatFromFirestore(chatId); } }
        async function deleteChatFromFirestore(chatId) { /* ... same as v10.1 ... */ if (!currentUser || !chatId) return; isDeletingChat = true; console.log(`Deleting chat: ${chatId}`); setLoadingState(true, "Deleting chat..."); const chatDocRef = db.collection('chats').doc(chatId); const messagesRef = chatDocRef.collection('messages'); try { const messagesSnapshot = await messagesRef.get(); if (!messagesSnapshot.empty) { const batch = db.batch(); messagesSnapshot.docs.forEach(doc => { batch.delete(doc.ref); }); await batch.commit(); console.log(`Deleted ${messagesSnapshot.size} messages.`); } await chatDocRef.delete(); console.log(`Deleted chat doc: ${chatId}`); const cacheNameToDelete = `cache-${chatId}-media`; try { if (genAI && genAI.caching?.deleteCachedContent) { await genAI.caching.deleteCachedContent(cacheNameToDelete); console.log(`Tried delete cache: ${cacheNameToDelete}`); } else { console.log("Skipped cache delete attempt."); } } catch(cacheError) { if (cacheError.message?.includes("not found")) { console.log(`Cache ${cacheNameToDelete} not found.`); } else { console.warn(`Error deleting cache ${cacheNameToDelete}:`, cacheError); } } if (activeChatId === chatId) { activeChatId = null; currentChatHistory = []; if (activeChatListener) { activeChatListener(); activeChatListener = null; } chatArea.innerHTML = ''; renderGreetingOrLoginPrompt(); removeAllSelectedMedia(); } } catch (error) { console.error(`Error deleting chat ${chatId}:`, error); displayError(`Failed to delete chat.`); } finally { isDeletingChat = false; setLoadingState(false); console.log(`Finished deleting chat: ${chatId}`); } }
        function switchChat(chatId) { /* ... same as v10.1 ... */ if (!currentUser || !chatId || chatId === activeChatId) { return; } console.log("Switching to chat:", chatId); setLoadingState(true, "Loading chat..."); activeChatId = chatId; currentMediaCacheName = null; cachedMediaUris = []; removeAllSelectedMedia(); highlightActiveChatInSidebar(); userInput.value = ''; autoGrowTextarea(); mcqModeCheckbox.checked = false; loadAndListenForActiveChat(chatId); }

        // --- Message Loading (Firestore) ---
        // ***** TAMIL *****
        // Firestore-லிருந்து history load செய்யும் function. மாற்றங்கள் இல்லை.
        function loadAndListenForActiveChat(chatId) { /* ... same as v10.1 ... */ if (!currentUser || !chatId) { chatArea.innerHTML = ''; if (activeChatListener) { activeChatListener(); activeChatListener = null; } renderGreetingOrLoginPrompt(); updateButtonStates(); setLoadingState(false); return; } if (activeChatListener) { activeChatListener(); activeChatListener = null; } const messagesRef = db.collection('chats').doc(chatId).collection('messages').orderBy('timestamp', 'asc'); chatArea.innerHTML = ''; const loadingMsg = displayMessage("Loading history...", 'ai', ['thinking']); scrollToBottom(true); console.log(`Listening messages for chat ${chatId}`); activeChatListener = messagesRef.onSnapshot(snapshot => { console.log(`Got messages snapshot: ${snapshot.size}`); removeMessageElement(loadingMsg); chatArea.innerHTML = ''; currentChatHistory = []; if (snapshot.empty && activeChatId === chatId) { const chatListItem = chatListContainer.querySelector(`.chat-list-item[data-id="${chatId}"]`); const chatTitle = chatListItem?.textContent?.replace(DELETE_ICON, '').trim() || ''; if (chatTitle && chatTitle !== NEW_CHAT_TITLE) { displayMessage("Chat is empty.", 'ai'); } else { renderGreetingOrLoginPrompt(); } } else { snapshot.forEach(doc => { const msgData = doc.data(); const role = msgData.role === 'user' ? 'user' : 'model'; const parts = []; if (msgData.text) parts.push({ text: msgData.text }); if (parts.length > 0) { currentChatHistory.push({ role: role, parts: parts }); } displayMessage(msgData.text || '', msgData.role, [], null, msgData); }); console.log(`Rebuilt history: ${currentChatHistory.length} msgs.`); } scrollToBottom(true); updateButtonStates(); setLoadingState(false); if (!isTestMode && !isReviewMode && activeChatId) { setTimeout(() => userInput.focus(), 100); } }, error => { console.error(`Error listening messages:`, error); displayError("Could not load messages."); removeMessageElement(loadingMsg); chatArea.innerHTML = ''; currentChatHistory = []; updateButtonStates(); setLoadingState(false); }); }

        // --- File Upload Helper (Gemini File API) ---
        // ***** TAMIL *****
        // PDF upload helper. மாற்றங்கள் இல்லை.
        async function uploadAndProcessFile(file, index, totalFiles) { /* ... same as v10.1 ... */ if (!genAI?.files?.upload || !genAI?.files?.get || !genAI?.files?.delete) { console.error("[File API] Error: Methods unavailable."); throw new Error("AI SDK File Service error."); } const progressMsg = `Uploading ${index + 1}/${totalFiles}: ${file.name}...`; console.log(`[File API] ${progressMsg}`); setLoadingState(true, progressMsg); let uploadResult = null; try { uploadResult = await genAI.files.upload({ file: file, mimeType: file.type, displayName: file.name, }); console.log(`[File API] Upload initiated. API File: ${uploadResult?.file?.name}, State: ${uploadResult?.file?.state}`); if (!uploadResult?.file?.name) throw new Error(`Upload failed for ${file.name}.`); const apiFileName = uploadResult.file.name; let fileResponse = await genAI.files.get({ name: apiFileName }); const startTime = Date.now(); while (fileResponse?.file?.state === 'PROCESSING') { if (Date.now() - startTime > FILE_API_PROCESSING_TIMEOUT_MS) throw new Error(`Processing timed out for ${file.name}.`); const processMsg = `Processing ${index + 1}/${totalFiles}: ${file.name}... (${fileResponse.file.state})`; setLoadingState(true, processMsg); console.log(`[File API] ${file.name} state: ${fileResponse.file.state}. Waiting...`); await new Promise(resolve => setTimeout(resolve, FILE_API_POLLING_INTERVAL_MS)); try { fileResponse = await genAI.files.get({ name: apiFileName }); if (!fileResponse?.file) throw new Error(`Polling failed for ${apiFileName}.`); } catch (pollError) { console.error(`[File API] Error polling ${apiFileName}:`, pollError); throw new Error(`Error checking status: ${pollError.message}`); } } if (fileResponse.file.state !== 'ACTIVE') { console.error(`[File API] Processing failed for ${file.name}. State: ${fileResponse.file.state}`); try { await genAI.files.delete({ name: apiFileName }); console.log(`[File API] Deleted failed file: ${apiFileName}`); } catch (delErr) { console.warn(`[File API] Failed delete failed file ${apiFileName}:`, delErr); } throw new Error(`Processing resulted in state: ${fileResponse.file.state}.`); } console.log(`[File API] ${file.name} processed. URI: ${fileResponse.file.uri}`); return fileResponse.file; } catch (uploadError) { console.error(`[File API] Error upload/processing ${file.name}:`, uploadError); if (uploadResult?.file?.name) { try { await genAI.files.delete({ name: uploadResult.file.name }); console.log(`[File API] Cleaned up file ${uploadResult.file.name}.`); } catch (delErr) { console.warn(`[File API] Failed cleanup ${uploadResult.file.name}:`, delErr); } } throw uploadError; } }

        // --- Message Sending (Gemini API & Firestore Save) ---
        // ***** TAMIL *****
        // இதுதான் முக்கிய function. Safety settings நீக்கப்பட்டுள்ளது. Bilingual MCQ prompt மாற்றப்பட்டுள்ளது. YouTube URL prompt-ல் சேர்க்கப்படுகிறது.
        async function handleSendMessage() {
            const userMessageTextRaw = userInput.value.trim();
            const mediaItemsToSend = [...selectedMediaItems];

            console.log("handleSendMessage:", { text: userMessageTextRaw.substring(0,50), media: mediaItemsToSend.length, model: selectedModelId, history: currentChatHistory.length });

            // Initial Checks
            if (!currentUser || !activeChatId || !API_KEY || !genAI || !isAISdkReady || !HarmCategory || !HarmBlockThreshold) { displayError("Login/SDK not ready."); return; }
            const currentModelInfo = AVAILABLE_MODELS.find(m => m.id === selectedModelId); if (!currentModelInfo) { displayError("Invalid model."); return; }
            const hasPdfs = mediaItemsToSend.some(item => item.type === 'pdf'); if (hasPdfs && (!genAI.files?.upload)) { displayError("File API unavailable for PDF."); return; }
            if (!userMessageTextRaw && mediaItemsToSend.length === 0) { return; } if (sendButton.disabled || isRecording) { return; }

            setLoadingState(true, "Preparing...");
            userInput.value = ''; autoGrowTextarea(); const isMCQRequest = mcqModeCheckbox.checked; if (isMCQRequest) mcqModeCheckbox.checked = false; removeAllSelectedMedia();

            const timestamp = firebase.firestore.FieldValue.serverTimestamp(); const messagesColRef = db.collection('chats').doc(activeChatId).collection('messages'); const chatDocRef = db.collection('chats').doc(activeChatId);

            // Prepare User Message Data for Firestore Display
            const userMsgData = { role: "user", text: userMessageTextRaw, timestamp: timestamp };
            const singleAudioItem = mediaItemsToSend.find(item => item.type === 'audio'); const imageItems = mediaItemsToSend.filter(item => item.type === 'image'); const pdfItems = mediaItemsToSend.filter(item => item.type === 'pdf'); let potentialTestTitle = null;
             // Add media info for display (same logic)
             if (singleAudioItem) { userMsgData.mediaType = 'audio'; userMsgData.mediaData = singleAudioItem.base64; userMsgData.mediaMimeType = singleAudioItem.mimeType; userMsgData.mediaName = singleAudioItem.name; }
             else if (imageItems.length === 1) { userMsgData.mediaType = 'image'; userMsgData.mediaName = imageItems[0].name; userMsgData.mediaMimeType = imageItems[0].mimeType; if (!imageItems[0].base64) { try { imageItems[0].base64 = await readFileAsBase64(imageItems[0].file); } catch (e) { console.error("Error reading image for DB:", e); imageItems[0].base64 = '#error'; } } userMsgData.mediaData = imageItems[0].base64; }
             else if (imageItems.length > 1) { userMsgData.mediaType = 'multi-image'; userMsgData.mediaCount = imageItems.length; userMsgData.mediaNames = imageItems.map(img => img.name || 'image'); }
             else if (pdfItems.length > 0) { userMsgData.mediaType = 'multi-pdf'; userMsgData.mediaCount = pdfItems.length; userMsgData.mediaNames = pdfItems.map(pdf => pdf.name || 'pdf'); }
             // YouTube ID extraction for potential embedding (display only)
             const youtubeMatch = userMessageTextRaw.match(youtubeRegex);
             if (youtubeMatch) userMsgData.youtubeVideoId = youtubeMatch[1];
             // ***** TAMIL *****
             // YouTube URL analysis-க்கு, URL-ஐ text prompt-ல் அனுப்புகிறோம். மாடல் அதை வைத்து analyze செய்ய முயற்சிக்கும்.
             // console.log("YouTube URL included in prompt text if present:", userMessageTextRaw);

            // Save User Message to Firestore (and add text to local history)
             try {
                 const userMessageRef = await messagesColRef.add(userMsgData);
                 await chatDocRef.update({ lastUpdated: timestamp }); console.log("User msg saved:", userMessageRef.id);
                 const userPartsForHistory = []; if (userMsgData.text) userPartsForHistory.push({ text: userMsgData.text });
                 if (userPartsForHistory.length > 0) { currentChatHistory.push({ role: 'user', parts: userPartsForHistory }); }
                 const chatSnap = await chatDocRef.get(); if (chatSnap.exists && chatSnap.data().title === NEW_CHAT_TITLE) { const messagesSnap = await messagesColRef.limit(2).get(); if (messagesSnap.size <= 1) { let titleSource = userMessageTextRaw || (mediaItemsToSend[0]?.name) || NEW_CHAT_TITLE; const generatedTitle = generateChatTitle(titleSource); if (generatedTitle && generatedTitle !== NEW_CHAT_TITLE) { await updateActiveChatTitle(generatedTitle); } } }
             } catch(error) { console.error("Error saving user msg:", error); displayError("Failed to save message."); setLoadingState(false); return; }

            const thinking = displayMessage("Thinking...", 'ai', ['thinking']); scrollToBottom();

            // Prepare Parts for API Call
            const partsForApi = []; let userTextForPrompt = userMessageTextRaw; let fileDataPartsForApi = []; let useCache = false; let cacheToUse = null;
            if (isMCQRequest) {
                 let baseTitle = userMessageTextRaw || (mediaItemsToSend[0]?.name) || "Generated Test";
                 potentialTestTitle = generateChatTitle(baseTitle) + ` (${new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })})`;
                 // ***** TAMIL *****
                 // Bilingual MCQ prompt. Tamil-லும் output கேட்கிறோம்.
                 const mcqInstructions = `\n\nPlease generate multiple choice questions based on the provided text and/or media (image(s)/PDF(s)/audio). Provide the response *only* as a valid JSON array string, enclosed within \`\`\`json ... \`\`\`. Each object in the array must have "question" (object with "en" and "ta" strings for English and Tamil), "options" (array of 4 objects, each with "en" and "ta" strings), "answer" (string 'A', 'B', 'C', or 'D'), and "explanation" (object with "en" and "ta" strings). Provide accurate English and Tamil translations. If Tamil translation is not possible for a part, repeat the English text for the 'ta' field. Do not include any text outside the JSON structure.`;
                 userTextForPrompt = userTextForPrompt ? userTextForPrompt + mcqInstructions : mcqInstructions; console.log("MCQ mode active (Bilingual).");
            }
            if (userTextForPrompt) partsForApi.push({ text: userTextForPrompt });

            // Process and Add Media Parts
            let generatedResponse = null; let aiResponseSaved = false; let uploadedFileUris = [];
            try {
                 // Process Audio/Image (Inline) or PDF (File API) - (Same logic as v10.1)
                 if (singleAudioItem) { if (!singleAudioItem.base64 || !singleAudioItem.mimeType) throw new Error("Audio data invalid."); const base64Data = singleAudioItem.base64.substring(singleAudioItem.base64.indexOf(',') + 1); partsForApi.push({ inlineData: { mimeType: singleAudioItem.mimeType, data: base64Data } }); console.log(`Added audio inlineData.`); }
                 else if (imageItems.length > 0) { const imageBase64Promises = imageItems.map(item => item.base64 || readFileAsBase64(item.file)); const imageBase64Results = await Promise.all(imageBase64Promises); let addedImageCount = 0; imageBase64Results.forEach((b64, index) => { if (!b64 || b64 === '#error') { console.error(`Skipping image ${index}: Invalid base64.`); return; } const mime = imageItems[index].mimeType; const data = b64.substring(b64.indexOf(',') + 1); if(data && mime) { partsForApi.push({ inlineData: { mimeType: mime, data: data } }); addedImageCount++; } else { console.error(`Skipping image ${index}: Missing data/mime.`); } }); console.log(`Added ${addedImageCount}/${imageItems.length} images.`); if (addedImageCount === 0 && imageItems.length > 0) throw new Error("Failed to process images."); }
                 else if (pdfItems.length > 0) { console.log(`Uploading ${pdfItems.length} PDFs...`); const uploadPromises = pdfItems.map((item, index) => uploadAndProcessFile(item.file, index, pdfItems.length)); const uploadedFileResults = await Promise.all(uploadPromises); uploadedFileUris = uploadedFileResults.map(f => f.uri).filter(uri => uri); if (uploadedFileUris.length === 0 && pdfItems.length > 0) throw new Error("Failed to upload/process PDFs."); fileDataPartsForApi = uploadedFileUris.map(uri => { const originalFile = uploadedFileResults.find(f => f.uri === uri); return { fileData: { mimeType: originalFile.mimeType, fileUri: uri } }; }); console.log(`Prepared ${fileDataPartsForApi.length} fileData parts.`); if (currentModelInfo.supportsCaching && fileDataPartsForApi.length > 0) { const sortedUris = [...uploadedFileUris].sort(); if (currentMediaCacheName && cachedMediaUris.length === sortedUris.length && cachedMediaUris.every((uri, i) => uri === sortedUris[i])) { console.log(`Attempting cache: ${currentMediaCacheName}`); useCache = true; cacheToUse = currentMediaCacheName; } else { console.log("No matching cache."); currentMediaCacheName = null; cachedMediaUris = []; } } else if (!currentModelInfo.supportsCaching && fileDataPartsForApi.length > 0) console.log("Caching skipped: Model lacks support."); }

                 const finalPartsForApi = useCache ? partsForApi : [...partsForApi, ...fileDataPartsForApi];
                 if (finalPartsForApi.length === 0 && !useCache) throw new Error("No content to send.");

                // Call Gemini API
                console.log("Calling Gemini API..."); setLoadingState(true, "Generating...");

                // ***** TAMIL *****
                // Safety settings BLOCK_NONE ஆக மாற்றப்பட்டுள்ளது.
                const safetySettingsConfig = [
                    { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_NONE },
                    { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_NONE },
                    { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_NONE },
                    { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_NONE },
                ];

                const model = genAI.getGenerativeModel({ model: selectedModelId, safetySettings: safetySettingsConfig });

                const historyForSDK = currentChatHistory.map(msg => ({ role: msg.role, parts: msg.parts.filter(part => typeof part.text === 'string') })).filter(msg => msg.parts.length > 0);
                const contentsRequest = [ ...historyForSDK, { role: "user", parts: finalPartsForApi } ];
                const generateContentRequest = { contents: contentsRequest, ...(useCache && cacheToUse && { cache: { name: cacheToUse } }) };

                console.log("SDK Request:", JSON.stringify(generateContentRequest, (k, v) => { if (k === 'data' && typeof v === 'string' && v.length > 100) return v.substring(0, 50) + '...'; if (k === 'fileUri' && typeof v === 'string') return v.split('/').pop() + '...'; return v; }, 2));

                const result = await model.generateContent(generateContentRequest);
                generatedResponse = result.response;

                // Process API Response
                removeMessageElement(thinking);
                let aiMsgData = { role: "model", text: "Error: No valid response.", timestamp: firebase.firestore.FieldValue.serverTimestamp(), mcqData: null, mcqTitle: null };
                let displayAsError = true; let rawAiText = ""; let blocked = false; // Blocked check remains for promptFeedback, though response blocks are disabled

                if (generatedResponse.promptFeedback?.blockReason) { // Still check prompt blocks
                    aiMsgData.text = `Blocked (Prompt): ${generatedResponse.promptFeedback.blockReason}`; blocked = true; displayAsError = true; console.warn("Prompt blocked:", generatedResponse.promptFeedback);
                } else if (generatedResponse.candidates?.length > 0) {
                    const candidate = generatedResponse.candidates[0];
                    // Check finishReason even if safety thresholds are NONE (e.g., OTHER, RECITATION, MAX_TOKENS)
                    if (candidate.finishReason && candidate.finishReason !== 'STOP') {
                         console.warn("Response Finish Reason:", candidate.finishReason);
                         // Handle specific non-STOP reasons if needed, otherwise show text if available
                    }

                    if (candidate.content?.parts?.length > 0) {
                        try {
                             rawAiText = generatedResponse.text(); aiMsgData.text = rawAiText; displayAsError = false;
                             if (isMCQRequest && !blocked) { // Parse Bilingual MCQs
                                try {
                                     // ***** TAMIL *****
                                     // Bilingual JSON parse செய்ய முயற்சிக்கிறோம்.
                                     const jsonMatch = rawAiText.match(/```json\s*([\s\S]*?)\s*```/); const jsonString = jsonMatch ? jsonMatch[1].trim() : rawAiText.trim();
                                     if (jsonString.startsWith('[') && jsonString.endsWith(']')) {
                                         const mcqs = JSON.parse(jsonString);
                                         // Validate bilingual structure
                                         const isValid = Array.isArray(mcqs) && mcqs.length > 0 && mcqs.every(q =>
                                             q.question?.en && q.question?.ta &&
                                             q.options?.length === 4 && q.options.every(opt => opt.en && opt.ta) &&
                                             q.answer && q.explanation?.en && q.explanation?.ta);
                                         if (isValid) {
                                              // Ensure fallback: If 'ta' is empty, use 'en' (optional, depends on model reliability)
                                              mcqs.forEach(q => { q.question.ta = q.question.ta || q.question.en; q.explanation.ta = q.explanation.ta || q.explanation.en; q.options.forEach(opt => { opt.ta = opt.ta || opt.en; }); });
                                              aiMsgData.text = `Generated ${mcqs.length} MCQs (Bilingual).`; aiMsgData.mcqData = mcqs; aiMsgData.mcqTitle = potentialTestTitle; console.log("Bilingual MCQs parsed."); displayAsError = false;
                                         } else { throw new Error("Invalid Bilingual MCQ structure."); }
                                     } else { throw new Error("Not JSON array."); }
                                 } catch (parseError) { console.warn("Failed parse Bilingual MCQ JSON:", parseError.message); aiMsgData.text = "MCQ format error.\n\n" + rawAiText; displayAsError = true; aiMsgData.mcqData = null; aiMsgData.mcqTitle = null; }
                             }
                        } catch (textError) { console.error("Error extracting text:", textError); aiMsgData.text = "Error extracting text."; displayAsError = true; }
                    } else if (candidate.finishReason === 'MAX_TOKENS') { console.warn("Response stopped: MAX_TOKENS."); aiMsgData.text = (generatedResponse.text ? generatedResponse.text() : "") + "\n\n(Response truncated)"; displayAsError = false; }
                    else if (candidate.finishReason === 'STOP' && (!candidate.content || candidate.content?.parts?.length === 0)){ aiMsgData.text = "(Model returned no content)"; displayAsError = false;}
                    else if (!candidate.content || candidate.content.parts?.length === 0) { // Handle cases like finishReason OTHER with no content
                        aiMsgData.text = `(Response finished: ${candidate.finishReason || 'Unknown'}, no content)`; displayAsError = false; // Show finish reason but treat as non-error
                    }
                    else { // Should not happen often if STOP/MAX_TOKENS/OTHER handled
                        console.warn("Unhandled API response case:", candidate.finishReason); aiMsgData.text = `Response: ${candidate.finishReason || '?'}. ` + (generatedResponse.text ? generatedResponse.text() : ""); displayAsError = false;
                    }
                } else { console.error("API Error: No candidates."); aiMsgData.text = "Error: No response data."; displayAsError = true; }

                // Save AI Response to Firestore
                try {
                      const aiMessageRef = await messagesColRef.add(aiMsgData); await chatDocRef.update({ lastUpdated: firebase.firestore.FieldValue.serverTimestamp() }); aiResponseSaved = true; console.log("AI response saved:", aiMessageRef.id);
                      if (!displayAsError && aiMsgData.text) { currentChatHistory.push({ role: 'model', parts: [{ text: aiMsgData.text }] }); }
                } catch (saveError) { console.error("Error saving AI response:", saveError); displayError(`Failed save AI response.`); }

                 // Attempt Cache Creation (if applicable)
                 if (!useCache && currentModelInfo.supportsCaching && fileDataPartsForApi.length > 0) { /* ... same cache creation logic ... */
                      const newCacheName = `cache-${activeChatId}-media-${Date.now()}`; console.log(`Attempting create cache: ${newCacheName}`); try { if (genAI.caching?.createCachedContent) { const cacheRequest = { model: selectedModelId, contents: [{ role: 'user', parts: fileDataPartsForApi }], ttlSeconds: CACHE_TTL_SECONDS, name: newCacheName }; genAI.caching.createCachedContent(cacheRequest).then(createdCache => { if (createdCache?.name) { currentMediaCacheName = createdCache.name; cachedMediaUris = [...uploadedFileUris].sort(); console.log(`Cache ${currentMediaCacheName} created for URIs:`, cachedMediaUris); } else { console.warn("Cache creation no valid cache returned."); } }).catch(cacheError => { console.error(`Error creating cache ${newCacheName}:`, cacheError); }); } else { console.warn("Cache creation skipped: SDK API unavailable."); } } catch (e) { console.error("Unexpected error setting up cache creation:", e); }
                 } else if (useCache) { console.log(`Used cache: ${cacheToUse}`); }
                 else if (fileDataPartsForApi.length > 0) console.log("Cache skipped: Model lacks support/no files.");

            } catch (error) { /* ... same error handling ... */ console.error("Error during send:", error); removeMessageElement(thinking); const errorText = `Error: ${error.message || "Unexpected error."}`; displayError(errorText); if (!aiResponseSaved) { try { await messagesColRef.add({ role: "model", text: errorText, timestamp: firebase.firestore.FieldValue.serverTimestamp() }); await chatDocRef.update({ lastUpdated: firebase.firestore.FieldValue.serverTimestamp() }); console.log("Error msg saved."); } catch (saveError) { console.error("Failed save error msg:", saveError); } } }
            finally { setLoadingState(false); if (!isTestMode && !isReviewMode && activeChatId) { setTimeout(() => userInput.focus(), 100); } }
        } // End of handleSendMessage


        // --- Chat Title Generation/Update ---
        // ***** TAMIL *****
        // Chat title functions. மாற்றங்கள் இல்லை.
        function generateChatTitle(sourceText) { /* ... same as v10.1 ... */ if (!sourceText || typeof sourceText !== 'string') return NEW_CHAT_TITLE; const text = sourceText.trim(); if (!text) return NEW_CHAT_TITLE; const title = text.split(/\s+/).slice(0, 5).join(' ').replace(/[.,!?;:]+$/, ''); return title.length > 35 ? title.substring(0, 32) + '...' : title; }
        async function updateActiveChatTitle(newTitle) { /* ... same as v10.1 ... */ if (!currentUser || !activeChatId || !newTitle || typeof newTitle !== 'string' || !newTitle.trim() || newTitle.trim() === NEW_CHAT_TITLE) return; const finalTitle = newTitle.trim(); const chatDocRef = db.collection('chats').doc(activeChatId); try { await chatDocRef.update({ title: finalTitle }); console.log(`Chat ${activeChatId} title updated: "${finalTitle}"`); } catch (error) { console.error("Error updating chat title:", error); } }

        // --- File Reader Helper ---
        function readFileAsBase64(file) { /* ... same as v10.1 ... */ return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = () => resolve(reader.result); reader.onerror = (error) => reject(error); reader.readAsDataURL(file); }); }

        // --- UI & Message Display Helpers ---
        function autoGrowTextarea() { /* ... same as v10.1 ... */ userInput.style.height='auto'; userInput.style.height=(userInput.scrollHeight)+'px'; }
        function handleInputKeydown(event) { /* ... same as v10.1 ... */ if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();if(!sendButton.disabled) handleSendMessage();} }
        function handleSuggestionClick(event) { /* ... same as v10.1 ... */ if(event.target.classList.contains('suggestion-chip')){userInput.value=event.target.dataset.prompt||'';autoGrowTextarea();userInput.focus();} }
        function displayError(text) { /* ... same as v10.1 ... */ console.error("Displaying Error:", text); displayMessage(`${text}`, 'ai', ['error-message']); scrollToBottom(); }
        function scrollToBottom(immediate = false) { /* ... same as v10.1 ... */ chatArea.scrollTo({top:chatArea.scrollHeight,behavior:immediate?'auto':'smooth'}); }
        function removeMessageElement(element) { /* ... same as v10.1 ... */ if(element && element.parentNode === chatArea) { try { chatArea.removeChild(element); } catch(e) { /* ignore */ } } }
        function updateButtonStates(isLoading = false) { /* ... same as v10.1 ... */ const isLoggedIn = !!currentUser; const isSdkFullyReady = isLoggedIn && !!API_KEY && !!genAI && isAISdkReady && !!HarmCategory && !!HarmBlockThreshold; const canUseFileAPI = isSdkFullyReady && !!genAI.files?.upload; const isChatSelected = !!activeChatId; const currentModelInfo = AVAILABLE_MODELS.find(m => m.id === selectedModelId); const canUseCaching = isSdkFullyReady && currentModelInfo?.supportsCaching && !!genAI.caching?.createCachedContent; const isAppReady = isSdkFullyReady; const canSendMessage = isAppReady && isChatSelected && !isLoading && !isRecording; const canUseSidebarControls = isLoggedIn && !isLoading && !isRecording; userInput.disabled = !isAppReady || !isChatSelected || isLoading || isRecording; sendButton.disabled = !canSendMessage; mcqModeCheckbox.disabled = !canSendMessage; imageUploadButton.disabled = !canSendMessage; pdfUploadButton.disabled = !canSendMessage || !canUseFileAPI; audioUploadButton.disabled = !canSendMessage; pdfUploadButton.title = canUseFileAPI ? "Upload PDF(s)" : "PDF Upload disabled"; let recordButtonDisabled = !isAppReady || !isChatSelected || isLoading; if (isRecording) recordButtonDisabled = false; recordAudioButton.disabled = recordButtonDisabled; startChatButton.disabled = !isLoggedIn || isLoading || isRecording; testSearchInput.disabled = !isLoggedIn || isLoading || isRecording; decreaseTextBtn.disabled = isLoading || isRecording || currentTextSizeMultiplier <= MIN_TEXT_SIZE_MULTIPLIER; increaseTextBtn.disabled = isLoading || isRecording || currentTextSizeMultiplier >= MAX_TEXT_SIZE_MULTIPLIER; themeToggleButton.disabled = isLoading || isRecording; modelSelector.disabled = isLoading || isRecording || !isLoggedIn; loginBtn.disabled = isLoading; logoutBtn.disabled = isLoading; }
        function setLoadingState(isLoading, message = "Generating...") { /* ... same as v10.1 ... */ updateButtonStates(isLoading); let placeholderText = ""; const isLoggedIn = !!currentUser; const isSdkFullyReady = isLoggedIn && !!API_KEY && !!genAI && isAISdkReady && !!HarmCategory && !!HarmBlockThreshold; if (isRecording) { placeholderText = "Recording..."; } else if (isLoading) { placeholderText = message; } else if (!isLoggedIn) { placeholderText = "Log in"; } else if (!isSdkFullyReady) { placeholderText = "API/SDK Error."; } else if (!activeChatId) { placeholderText = "Select/create chat"; } else { placeholderText = "Enter prompt, attach media, or paste URL"; } if (userInput.placeholder !== placeholderText) { userInput.placeholder = placeholderText; } }
        function switchView(viewName, cameFromTests = false) { /* ... same as v10.1 ... */ console.log("Switching view:", viewName); chatView.classList.remove('active'); reviewView.classList.remove('active'); testView.classList.remove('active'); appContainer.classList.remove('hidden'); isTestMode = false; isReviewMode = false; cameFromAllTestsList = cameFromTests; saveReviewBtn.style.display = 'none'; exitReviewBtn.style.display = 'none'; if(viewName === 'test'){ appContainer.classList.add('hidden'); testView.classList.add('active'); isTestMode = true; currentTestLanguage = 'en'; // Reset language on entering test view
        testLanguageToggle.textContent = 'தமிழ்'; // Reset toggle text
         } else if(viewName === 'review'){ reviewView.classList.add('active'); isReviewMode = true; exitReviewBtn.style.display = 'inline-block'; exitReviewBtn.textContent = cameFromAllTestsList ? "Back to All Tests" : "Back to Chat"; currentReviewLanguage = 'en'; // Reset language on entering review view
        reviewLanguageToggle.textContent = 'தமிழ்'; // Reset toggle text
         } else { chatView.classList.add('active'); if (currentUser && activeChatId && API_KEY && genAI && !isRecording) { setTimeout(() => userInput.focus(), 100); } } if (viewName !== 'test' && testTimerInterval) { clearInterval(testTimerInterval); testTimerInterval = null; } }
        function displayMessage(text, sender, cssClasses = [], appendHtml = null, messageData = null) { /* ... same as v10.1 ... */ const messageElement = document.createElement('div'); messageElement.classList.add('message', `${sender}-message`); if (cssClasses?.length > 0) messageElement.classList.add(...cssClasses); let hasContent = false; let containsCode = false; if (messageData?.mediaType === 'image' && messageData.mediaData && messageData.mediaData !== '#error') { try { const img = document.createElement('img'); img.src = messageData.mediaData; img.alt = messageData.mediaName || "Uploaded Image"; img.classList.add('uploaded-image'); img.loading = "lazy"; img.onerror = () => { img.alt = "Err"; img.src = ""; }; messageElement.appendChild(img); hasContent = true; } catch (e) { console.error("Err img elem:", e); } } else if (messageData?.mediaType === 'multi-image' && messageData.mediaCount > 0) { try { const indicator = document.createElement('div'); indicator.classList.add('multi-media-indicator'); indicator.textContent = `(${messageData.mediaCount} image${messageData.mediaCount > 1 ? 's' : ''} sent: ${messageData.mediaNames?.join(', ') || ''})`; messageElement.appendChild(indicator); hasContent = true; } catch (e) { console.error("Err multi-img ind:", e); } } else if (messageData?.mediaType === 'multi-pdf' && messageData.mediaCount > 0) { try { const indicator = document.createElement('div'); indicator.classList.add('multi-media-indicator'); indicator.textContent = `(${messageData.mediaCount} PDF${messageData.mediaCount > 1 ? 's' : ''} sent: ${messageData.mediaNames?.join(', ') || ''})`; messageElement.appendChild(indicator); hasContent = true; } catch (e) { console.error("Err multi-PDF ind:", e); } } else if (messageData?.mediaType === 'audio' && messageData.mediaData) { try { const audioContainer = document.createElement('div'); audioContainer.classList.add('chat-audio-player'); const audioPlayer = document.createElement('audio'); audioPlayer.src = messageData.mediaData; audioPlayer.controls = true; audioPlayer.preload = "metadata"; if(messageData.mediaName) audioPlayer.title = messageData.mediaName; audioPlayer.onerror = () => { audioContainer.innerHTML = `<span style='font-size:0.8em; color:var(--error-text);'>(Audio err)</span>`; }; audioContainer.appendChild(audioPlayer); messageElement.appendChild(audioContainer); hasContent = true; } catch (e) { console.error("Err audio elem:", e); } } if (text) { const messageContentContainer = document.createElement('div'); try { const tempDiv = document.createElement('div'); tempDiv.innerText = text; let formattedText = tempDiv.innerHTML; if (messageData?.mediaType !== 'image') { formattedText = formattedText.replace(imageUrlRegex, (match, imgUrl) => `<img src="${imgUrl}" class="chat-image" alt="Chat Image" loading="lazy" onerror="this.alt='Err'; this.src='';">`); } formattedText = formattedText.replace(/```(\w*)\n?([\s\S]*?)```/g, (match, lang, code) => { containsCode = true; const languageClass = lang ? `language-${lang.trim()}` : 'language-plain'; const escapedCode = code.replace(/</g, "&lt;").replace(/>/g, "&gt;"); return `<pre class="${languageClass}"><code class="${languageClass}">${escapedCode}</code></pre>`; }); formattedText = formattedText.replace(/`([^`]+)`/g, (match, code) => `<code>${code.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</code>`); formattedText = formattedText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/(?<!\*)\*(?!\*)(.*?)(?<!\*)\*(?!\*)/g, '<em>$1</em>').replace(/\n/g, '<br>'); messageContentContainer.innerHTML = formattedText; messageElement.appendChild(messageContentContainer); hasContent = true; if (text.includes('$') || text.includes('\\') || text.includes('^') || text.includes('_')) { if (typeof MathJax !== "undefined" && MathJax.typesetPromise) { setTimeout(() => { MathJax.typesetPromise([messageContentContainer]).catch(err => console.error('MathJax error:', err)); }, 50); } } } catch (e) { console.error("Error formatting text:", e); } } if (messageData?.youtubeVideoId) { try { const youtubeEmbedDiv = document.createElement('div'); youtubeEmbedDiv.classList.add('youtube-embed-container'); const iframe = document.createElement('iframe'); iframe.classList.add('chat-video'); iframe.src = `https://www.youtube.com/embed/${messageData.youtubeVideoId}`; iframe.title = "YouTube video"; iframe.allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"; iframe.allowFullscreen = true; iframe.loading = "lazy"; iframe.onerror = () => { youtubeEmbedDiv.innerHTML = `<span style='font-size:0.8em; color:var(--error-text);'>(YT embed err)</span>`; }; youtubeEmbedDiv.appendChild(iframe); messageElement.appendChild(youtubeEmbedDiv); hasContent = true; } catch (e) { console.error("Err YT embed:", e); } } if (messageData?.role === 'model' && messageData?.mcqData?.length > 0) { try { displayMCQOffer(messageData.mcqData, messageData.mcqTitle, messageElement); hasContent = true; } catch (e) { console.error("Err MCQ offer:", e); } } else if (appendHtml) { try { const appendDiv = document.createElement('div'); appendDiv.innerHTML = appendHtml; while (appendDiv.firstChild) { messageElement.appendChild(appendDiv.firstChild); } hasContent = true; } catch (e) { console.error("Err append HTML:", e); } } if (hasContent || cssClasses.includes('thinking') || cssClasses.includes('error-message')) { if (!chatArea.contains(messageElement)) { chatArea.appendChild(messageElement); if (containsCode && typeof Prism !== 'undefined') { setTimeout(() => { try { messageElement.querySelectorAll('pre code').forEach(block => { Prism.highlightElement(block); }); } catch (highlightError) { console.error("Prism error:", highlightError); } }, 50); } } } else { console.warn(`Skipping empty msg. Sender: ${sender}`); } return messageElement; }

        // --- MCQ/Test/Review/All Tests Functions ---
        // ***** TAMIL *****
        // MCQ, Test, Review functions. Bilingual support சேர்க்கப்பட்டுள்ளது.
        function handleChatAreaClick(event) { /* ... same as v10.1 ... */ const startButton = event.target.closest('.start-test-button'); if (startButton) { const mcqDataString = startButton.dataset.mcq; const titleFromButton = startButton.dataset.mcqTitle; let mcqs = null; if (mcqDataString) { try { mcqs = JSON.parse(mcqDataString); } catch (e) { console.error("Failed parse MCQ data:", e); displayError("Could not start test."); return; } } if (mcqs?.length > 0) { startMockTest(mcqs, titleFromButton || null); } else { displayError("MCQ data missing."); } return; } const clickedImage = event.target.closest('img.chat-image, img.uploaded-image'); if (clickedImage?.src && !clickedImage.src.startsWith('#') && clickedImage.src.trim() !== '') { try { if (!clickedImage.src.startsWith('data:image') || clickedImage.src.length < 2 * 1024 * 1024) { window.open(clickedImage.src, '_blank'); } else { console.log("Clicked large b64 image."); } } catch (e) { console.error("Error opening image:", e); } } }
        function displayMCQOffer(mcqData, mcqTitle, aiMessageElement) { /* ... same as v10.1 ... */ if (aiMessageElement.querySelector('.start-test-button')) return; const questionCount = mcqData.length; const button = document.createElement('button'); button.classList.add('start-test-button'); button.textContent = `Start Mock Test (${questionCount} Qs)`; button.title = mcqTitle || `Start generated test`; try { button.dataset.mcq = JSON.stringify(mcqData); if (mcqTitle) { button.dataset.mcqTitle = mcqTitle; } } catch (e) { console.error("Failed stringify MCQ:", e); return; } const buttonContainer = document.createElement('div'); buttonContainer.style.marginTop = '10px'; buttonContainer.appendChild(button); aiMessageElement.appendChild(buttonContainer); }
        function startMockTest(mcqs, title = null) { /* ... same as v10.1 ... */ if (!currentUser || !mcqs?.length) { displayError(currentUser ? "No questions for test." : "Log in first."); return; } console.log("Starting mock test:", mcqs.length, "Qs. Title:", title); currentTestMCQs = mcqs; currentQuestionIndex = 0; userAnswers = new Array(mcqs.length).fill(null); reviewResultsCache = null; switchView('test'); currentTestLanguage = 'en'; // Default to English when starting test
        testLanguageToggle.textContent = 'தமிழ்'; // Set initial toggle text
         displayTestQuestion(0); startTestTimer(); const finalTitle = (title && title.trim()) ? title.trim() : `Mock Test (${mcqs.length} Qs)`; testTitle.textContent = finalTitle; }

        // ***** TAMIL *****
        // Test கேள்விகளை bilingual ஆகக் காட்டுகிறது.
        function displayTestQuestion(index) {
            if (index < 0 || index >= currentTestMCQs.length) return;
            currentQuestionIndex = index;
            const questionData = currentTestMCQs[index];

            // Get text based on current language, fallback to 'en'
            const questionText = questionData.question?.[currentTestLanguage] || questionData.question?.en || "(Question missing)";
            testQuestionNumber.textContent = `Question ${index + 1}`;
            testQuestion.innerHTML = questionText; // Use innerHTML for potential formatting
            testOptionsContainer.innerHTML = '';

            const options = questionData.options || [];
            const optionLetters = ['A', 'B', 'C', 'D'];

            options.forEach((optionObj, optionIndex) => {
                if (optionIndex >= optionLetters.length) return;
                // Get option text based on current language, fallback to 'en'
                const optionText = optionObj?.[currentTestLanguage] || optionObj?.en || '(Option missing)';
                const label = document.createElement('label');
                const input = document.createElement('input');
                input.type = 'radio';
                input.name = `q_${index}`;
                input.value = optionIndex;
                input.checked = (userAnswers[index] === optionIndex);
                input.onchange = () => handleOptionSelect(optionIndex);
                label.appendChild(input);
                // Add space after radio button
                label.appendChild(document.createTextNode(` ${optionLetters[optionIndex]}. ${optionText}`));
                testOptionsContainer.appendChild(label);
            });

            // MathJax typesetting
            try { if (typeof MathJax !== "undefined" && MathJax.typesetPromise) { MathJax.typesetPromise([testQuestion, testOptionsContainer]).catch(err=>console.error('MathJax Test Q Error:', err)); } } catch(e){ console.error("MathJax call failed:", e); }

            prevQuestionBtn.disabled = (index === 0);
            nextQuestionBtn.disabled = (index === currentTestMCQs.length - 1);
            questionCounter.textContent = `Q: ${index + 1} / ${currentTestMCQs.length}`;
        }

        // ***** TAMIL *****
        // Test view-ல் மொழி மாற்றும் function.
        function toggleTestLanguage() {
             currentTestLanguage = (currentTestLanguage === 'en') ? 'ta' : 'en';
             testLanguageToggle.textContent = (currentTestLanguage === 'en') ? 'தமிழ்' : 'English';
             // Re-display the current question in the new language
             displayTestQuestion(currentQuestionIndex);
             console.log("Test language switched to:", currentTestLanguage);
         }

        function handleOptionSelect(optionIndex) { /* ... same as v10.1 ... */ if (currentQuestionIndex >= 0 && currentQuestionIndex < userAnswers.length) { userAnswers[currentQuestionIndex] = optionIndex; console.log(`Answered Q${currentQuestionIndex + 1}: Option ${optionIndex}`); } }
        function handleTestNavigation(direction) { /* ... same as v10.1 ... */ let newIndex = currentQuestionIndex; if (direction === 'prev' && currentQuestionIndex > 0) newIndex--; else if (direction === 'next' && currentQuestionIndex < currentTestMCQs.length - 1) newIndex++; if (newIndex !== currentQuestionIndex) displayTestQuestion(newIndex); }
        function startTestTimer() { /* ... same as v10.1 ... */ if (testTimerInterval) clearInterval(testTimerInterval); testStartTime = Date.now(); testTimer.textContent = `Time: 00:00`; testTimerInterval = setInterval(() => { const elapsed = Math.floor((Date.now() - testStartTime) / 1000); const mins = Math.floor(elapsed / 60).toString().padStart(2, '0'); const secs = (elapsed % 60).toString().padStart(2, '0'); testTimer.textContent = `Time: ${mins}:${secs}`; }, 1000); }
        function submitTest() { /* ... same as v10.1 ... */ if (!confirm("Submit test?")) return; if (testTimerInterval) clearInterval(testTimerInterval); const endTime = Date.now(); const timeTakenMs = testStartTime ? endTime - testStartTime : 0; const results = calculateResults(currentTestMCQs, userAnswers, timeTakenMs); reviewResultsCache = results; switchView('review', false); currentReviewLanguage = 'en'; // Default review language to English
        reviewLanguageToggle.textContent = 'தமிழ்'; // Reset toggle text
         displayReview(results); }

        // ***** TAMIL *****
        // Test முடிவுகளை calculate செய்கிறது. Bilingual data-வையும் சேர்க்கிறது.
        function calculateResults(mcqs, answers, timeMs) {
            let correctCount = 0, incorrectCount = 0, skippedCount = 0;
            const reviewQuestions = []; // Will store simplified review data for display
            mcqs.forEach((q, idx) => {
                const uAIdx = answers[idx];
                const opts = q.options || [];
                const cALtr = q.answer?.trim().toUpperCase();
                const cAIdx = cALtr ? cALtr.charCodeAt(0) - 'A'.charCodeAt(0) : -1;

                // Get English versions for basic review summary
                const cATxtE = (cAIdx >= 0 && cAIdx < opts.length) ? (opts[cAIdx]?.en || '?') : "N/A";
                let uATxtE = "Skipped";
                let st = "skipped";

                if (uAIdx !== null && uAIdx >= 0 && uAIdx < opts.length) {
                    uATxtE = opts[uAIdx]?.en || '?';
                    if (uAIdx === cAIdx) { st = "correct"; correctCount++; }
                    else { st = "incorrect"; incorrectCount++; }
                } else if (uAIdx !== null) {
                    uATxtE = "Invalid"; st = "incorrect"; incorrectCount++;
                } else {
                    skippedCount++;
                }
                // Store basic English summary for quick display calculation
                reviewQuestions.push({
                    question_en: q.question?.en || '?', // Store only English for now, will fetch bilingual in displayReview
                    correctAnswer_en: cATxtE,
                    userAnswer_en: uATxtE,
                    status: st,
                    explanation_en: q.explanation?.en || "N/A"
                });
            });
            const total = mcqs.length; const score = `${correctCount}/${total}`; const timeS = Math.round(timeMs / 1000); const mins = Math.floor(timeS / 60); const secs = timeS % 60; const timeStr = `${mins}m ${secs}s`;
            return {
                 // 'questions' now just holds basic status, English text for summary calculation
                 // We store the full original MCQs with bilingual data separately
                summary: { score, correct: correctCount, incorrect: incorrectCount, skipped: skippedCount, timeString: timeStr },
                testDate: new Date().toISOString(),
                timeTakenMs: timeMs,
                sourceChatId: activeChatId,
                testTitle: testTitle.textContent,
                originalMCQs: mcqs // Store the full original bilingual data here
            };
        }

        // ***** TAMIL *****
        // Review view-வில் bilingual கேள்விகளைக் காட்டுகிறது.
        function displayReview(reviewData) {
            reviewContent.innerHTML = ''; reviewSummary.innerHTML = ''; reviewFilters.style.display = 'none';
            if (!reviewData?.originalMCQs?.length || !reviewData.summary) {
                reviewSummary.innerHTML = "<span>No review data.</span>"; saveReviewBtn.style.display = 'none'; return;
            }
            const { score, correct, incorrect, skipped, timeString } = reviewData.summary;
            reviewSummary.innerHTML = `<span>Score: ${score}</span> <span class="score-correct">Correct: ${correct}</span> <span class="score-incorrect">Incorrect: ${incorrect}</span> <span class="score-skipped">Skipped: ${skipped}</span> <span>Time: ${timeString}</span>`;
            reviewTitle.textContent = reviewData.testTitle || "Test Review";

            reviewData.originalMCQs.forEach((origQ, idx) => {
                if (!origQ) return;
                const userAnswerIndex = userAnswers[idx]; // Get the index the user selected
                const correctAnswerLetter = origQ.answer?.trim().toUpperCase();
                const correctAnswerIndex = correctAnswerLetter ? correctAnswerLetter.charCodeAt(0) - 'A'.charCodeAt(0) : -1;

                let status = 'skipped';
                if (userAnswerIndex !== null && userAnswerIndex >= 0 && userAnswerIndex < (origQ.options?.length || 0)) {
                    status = (userAnswerIndex === correctAnswerIndex) ? 'correct' : 'incorrect';
                } else if (userAnswerIndex !== null) {
                    status = 'invalid'; // Should not happen with radio buttons
                }

                // Get text based on currentReviewLanguage, fallback to 'en'
                const qTxt = origQ.question?.[currentReviewLanguage] || origQ.question?.en || '?';
                const opts = origQ.options || [];
                const cATxt = (correctAnswerIndex >= 0 && correctAnswerIndex < opts.length) ? (opts[correctAnswerIndex]?.[currentReviewLanguage] || opts[correctAnswerIndex]?.en) : "N/A";
                let uATxt = "Skipped";
                 if (status !== 'skipped' && status !== 'invalid') {
                     uATxt = opts[userAnswerIndex]?.[currentReviewLanguage] || opts[userAnswerIndex]?.en || '?';
                 } else if (status === 'invalid') {
                     uATxt = "Invalid Answer";
                 }
                const explTxt = origQ.explanation?.[currentReviewLanguage] || origQ.explanation?.en || "N/A.";

                let iStCls = `status-${status}`; let aDtCls = `user-answer-${status}`;
                const rItem = document.createElement('div');
                rItem.classList.add('review-item', iStCls); rItem.dataset.status = status; // Use calculated status for filtering

                let dHtml = `<span class="${aDtCls}">Your Answer: ${uATxt}</span>`;
                if (status !== 'correct') {
                    dHtml += `<br><span class="correct-answer">Correct Answer: ${cATxt}</span>`;
                }
                dHtml += `<div class="review-item-explanation">Explanation: ${explTxt}</div>`;
                rItem.innerHTML = `<div class="review-item-qnum">Q ${idx + 1}</div> <div class="review-item-question">${qTxt}</div> <div class="review-item-details">${dHtml}</div>`;
                reviewContent.appendChild(rItem);
            });

            if (incorrect > 0 || skipped > 0) reviewFilters.style.display = 'flex'; else reviewFilters.style.display = 'none';
            if (reviewData.savedAt) { saveReviewBtn.textContent = "Saved"; saveReviewBtn.disabled = true; saveReviewBtn.style.display = 'inline-block'; }
            else if (reviewResultsCache && !cameFromAllTestsList) { saveReviewBtn.textContent = "Save Review"; saveReviewBtn.disabled = !currentUser; saveReviewBtn.style.display = 'inline-block'; }
            else { saveReviewBtn.style.display = 'none'; }
            filterReviewItems('all'); reviewFilters.querySelectorAll('button').forEach(btn => { btn.classList.toggle('active-filter', btn.dataset.filter === 'all'); });
            try { if (typeof MathJax !== "undefined" && MathJax.typesetPromise) { MathJax.typesetPromise([reviewContent]).catch(err=>console.error('MathJax Review Error:', err)); } } catch (e) { console.error("MathJax call failed:", e); }
        }

         // ***** TAMIL *****
         // Review view-ல் மொழி மாற்றும் function.
         function toggleReviewLanguage() {
             currentReviewLanguage = (currentReviewLanguage === 'en') ? 'ta' : 'en';
             reviewLanguageToggle.textContent = (currentReviewLanguage === 'en') ? 'தமிழ்' : 'English';
             // Re-display the review content in the new language
             if (reviewResultsCache) {
                 displayReview(reviewResultsCache);
             }
             console.log("Review language switched to:", currentReviewLanguage);
         }

        function handleReviewFilterClick(event) { /* ... same as v10.1 ... */ const button = event.target.closest('button[data-filter]'); if (button) { filterReviewItems(button.dataset.filter); } }
        function filterReviewItems(filter) { /* ... same as v10.1 ... */ reviewFilters.querySelectorAll('button').forEach(btn => { btn.classList.toggle('active-filter', btn.dataset.filter === filter); }); reviewContent.querySelectorAll('.review-item').forEach(item => { const show = (filter === 'all') || item.dataset.status === filter; item.classList.toggle('hidden-by-filter', !show); }); }
        function exitReview() { /* ... same as v10.1 ... */ reviewResultsCache = null; switchView('chat'); reviewSummary.innerHTML = ''; reviewContent.innerHTML = ''; reviewTitle.textContent = 'Review'; }
        async function saveTestReviewToCloud() { /* ... same as v10.1 ... */ if (!currentUser) { alert("Log in to save."); return; } if (!reviewResultsCache || reviewResultsCache.savedAt) { alert("No new data or already saved."); return; } if (!reviewResultsCache.originalMCQs?.length || !reviewResultsCache.summary) { if (!confirm("Warning: Data incomplete. Save anyway?")) { return; } } const dataToSave = { ...reviewResultsCache, userId: currentUser.uid, savedAt: firebase.firestore.FieldValue.serverTimestamp(), }; saveReviewBtn.disabled = true; saveReviewBtn.textContent = "Saving..."; try { const newRef = await db.collection('testReviews').add(dataToSave); console.log("Review saved:", newRef.id); alert("Review saved!"); saveReviewBtn.textContent = "Saved"; if (reviewResultsCache) reviewResultsCache.savedAt = new Date(); } catch (error) { console.error("Error saving review:", error); alert("Failed save review."); saveReviewBtn.disabled = false; saveReviewBtn.textContent = "Save Review"; } }
        function loadAndListenForTests(userId) { /* ... same as v10.1 ... */ if (testListListener) { testListListener(); testListListener = null; } const testsRef = db.collection('testReviews').where('userId', '==', userId).orderBy('savedAt', 'desc'); console.log(`Listening tests for ${userId}`); testListListener = testsRef.onSnapshot(snapshot => { allSavedTestsData = []; snapshot.forEach(doc => { allSavedTestsData.push({ id: doc.id, ...doc.data() }); }); console.log("Got saved tests:", allSavedTestsData.length); renderAllTestsList(allSavedTestsData); filterTestsInSidebar(); }, error => { console.error("Error listening tests:", error); allTestsListContainer.innerHTML = `<div style="padding:10px; color:var(--error-text);">Error loading tests.</div>`; allSavedTestsData = []; }); }
        function renderAllTestsList(tests) { /* ... same as v10.1 ... */ allTestsListContainer.innerHTML = ''; if (!currentUser) { allTestsListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);">Log in.</div>'; return; } if (tests.length === 0) { allTestsListContainer.innerHTML = '<div style="padding:10px;color:var(--text-secondary);">No saved tests.</div>'; } else { tests.forEach(testData => { const item = document.createElement('div'); item.classList.add('test-list-item'); item.dataset.reviewId = testData.id; const title = testData.testTitle || '(Untitled)'; const date = testData.savedAt?.toDate ? testData.savedAt.toDate().toLocaleString() : '?'; const score = testData.summary?.score || 'N/A'; const hasReattemptData = testData.originalMCQs?.length > 0 && testData.originalMCQs.every(q => q?.question?.en && q.options?.length === 4 && q.answer && q.explanation?.en); const infoDiv = document.createElement('div'); infoDiv.classList.add('test-item-info'); const titleSpan = document.createElement('span'); titleSpan.classList.add('test-item-title'); titleSpan.textContent = title; titleSpan.title = title; const detailSpan = document.createElement('span'); detailSpan.classList.add('test-item-details'); detailSpan.textContent = `Saved: ${date} | Score: ${score}`; const controlsDiv = document.createElement('div'); controlsDiv.classList.add('test-item-controls'); const editButton = document.createElement('button'); editButton.innerHTML = EDIT_TEST_ICON; editButton.title = "Edit title"; editButton.dataset.action = "edit-title"; controlsDiv.appendChild(editButton); const deleteButton = document.createElement('button'); deleteButton.innerHTML = DELETE_TEST_ICON; deleteButton.title = "Delete test"; deleteButton.dataset.action = "delete-test"; controlsDiv.appendChild(deleteButton); infoDiv.appendChild(titleSpan); infoDiv.appendChild(detailSpan); infoDiv.appendChild(controlsDiv); const actionsDiv = document.createElement('div'); actionsDiv.classList.add('test-item-actions'); const viewButton = document.createElement('button'); viewButton.textContent = "Details"; viewButton.dataset.action = "view"; actionsDiv.appendChild(viewButton); const reattemptSelect = document.createElement('select'); reattemptSelect.dataset.action = "reattempt"; reattemptSelect.disabled = !hasReattemptData; reattemptSelect.title = hasReattemptData ? "Reattempt test" : "Reattempt N/A"; reattemptSelect.innerHTML = `<option value="" selected>${hasReattemptData ? 'Reattempt...' : 'N/A'}</option><option value="mistaked" ${!hasReattemptData?'disabled':''}>Mistaked</option><option value="skipped" ${!hasReattemptData?'disabled':''}>Skipped</option><option value="both" ${!hasReattemptData?'disabled':''}>Mistaked/Skipped</option><option value="full" ${!hasReattemptData?'disabled':''}>Full Test</option>`; reattemptSelect.addEventListener('change', (e) => { const selectedMode = e.target.value; if (selectedMode) { const reviewId = e.target.closest('.test-list-item')?.dataset.reviewId; if (reviewId) startReattempt(reviewId, selectedMode); e.target.value = ""; } }); actionsDiv.appendChild(reattemptSelect); item.appendChild(infoDiv); item.appendChild(actionsDiv); allTestsListContainer.appendChild(item); }); } }
        function filterTestsInSidebar() { /* ... same as v10.1 ... */ const searchTerm = testSearchInput.value.toLowerCase().trim(); const items = allTestsListContainer.querySelectorAll('.test-list-item'); let visibleCount = 0; const noResultsMsg = allTestsListContainer.querySelector('.no-search-results'); if (noResultsMsg) noResultsMsg.remove(); items.forEach(item => { const title = item.querySelector('.test-item-title')?.textContent.toLowerCase() || ''; const details = item.querySelector('.test-item-details')?.textContent.toLowerCase() || ''; const isMatch = title.includes(searchTerm) || details.includes(searchTerm); item.classList.toggle('hidden-by-search', !isMatch); if (isMatch) visibleCount++; }); if (visibleCount === 0 && searchTerm !== '' && items.length > 0) { const msgDiv = document.createElement('div'); msgDiv.textContent = "No saved tests match search."; msgDiv.classList.add('no-search-results'); allTestsListContainer.appendChild(msgDiv); } }
        async function handleAllTestsListClick(event) { /* ... same as v10.1 ... */ const button = event.target.closest('button[data-action], select[data-action]'); if (!button || button.tagName === 'SELECT') return; const action = button.dataset.action; const listItem = button.closest('.test-list-item'); const reviewId = listItem?.dataset.reviewId; if (!reviewId) { console.error("No review ID for action:", action); return; } switch (action) { case "view": const reviewData = allSavedTestsData.find(t => t.id === reviewId); if (reviewData) { reviewResultsCache = reviewData; switchView('review', true); currentReviewLanguage = 'en'; reviewLanguageToggle.textContent = 'தமிழ்'; displayReview(reviewData); } else { alert("Error: Could not find review data."); } break; case "edit-title": enterTestTitleEditMode(listItem, reviewId); break; case "delete-test": const testTitle = listItem.querySelector('.test-item-title')?.textContent || 'this test'; if (confirm(`Delete test "${testTitle}"?`)) deleteSavedTest(reviewId, listItem); break; } }
        function enterTestTitleEditMode(listItem, reviewId) { /* ... same as v10.1 ... */ const infoDiv = listItem.querySelector('.test-item-info'); const titleSpan = infoDiv.querySelector('.test-item-title'); const detailSpan = infoDiv.querySelector('.test-item-details'); const controlsDiv = infoDiv.querySelector('.test-item-controls'); const currentTitle = titleSpan.textContent; titleSpan.style.display = 'none'; detailSpan.style.display = 'none'; if(controlsDiv) controlsDiv.style.display = 'none'; if (infoDiv.querySelector('.test-item-edit-mode')) return; const editContainer = document.createElement('div'); editContainer.classList.add('test-item-edit-mode'); const input = document.createElement('input'); input.type = 'text'; input.value = currentTitle; input.maxLength = 100; input.addEventListener('keydown', (e) => { if (e.key === 'Enter') saveTestTitle(listItem, reviewId, input.value); else if (e.key === 'Escape') exitTestTitleEditMode(listItem, currentTitle); }); const saveButton = document.createElement('button'); saveButton.textContent = 'Save'; saveButton.onclick = () => saveTestTitle(listItem, reviewId, input.value); const cancelButton = document.createElement('button'); cancelButton.textContent = 'Cancel'; cancelButton.onclick = () => exitTestTitleEditMode(listItem, currentTitle); editContainer.appendChild(input); editContainer.appendChild(saveButton); editContainer.appendChild(cancelButton); infoDiv.appendChild(editContainer); input.focus(); input.select(); }
        function exitTestTitleEditMode(listItem, originalTitle = null) { /* ... same as v10.1 ... */ const infoDiv = listItem.querySelector('.test-item-info'); const titleSpan = infoDiv.querySelector('.test-item-title'); const detailSpan = infoDiv.querySelector('.test-item-details'); const controlsDiv = infoDiv.querySelector('.test-item-controls'); const editContainer = infoDiv.querySelector('.test-item-edit-mode'); if (editContainer) editContainer.remove(); if (originalTitle !== null && titleSpan) { titleSpan.textContent = originalTitle; titleSpan.title = originalTitle; } if(titleSpan) titleSpan.style.display = ''; if(detailSpan) detailSpan.style.display = ''; if(controlsDiv) controlsDiv.style.display = ''; }
        async function saveTestTitle(listItem, reviewId, newTitle) { /* ... same as v10.1 ... */ const trimmedTitle = newTitle.trim(); if (!trimmedTitle) { alert("Title cannot be empty."); return; } if (trimmedTitle.length > 100) { alert("Title too long."); return; } const docRef = db.collection('testReviews').doc(reviewId); try { await docRef.update({ testTitle: trimmedTitle }); console.log("Test title updated:", reviewId); const titleSpan = listItem.querySelector('.test-item-title'); if (titleSpan) { titleSpan.textContent = trimmedTitle; titleSpan.title = trimmedTitle; } const testIndex = allSavedTestsData.findIndex(t => t.id === reviewId); if (testIndex > -1) allSavedTestsData[testIndex].testTitle = trimmedTitle; exitTestTitleEditMode(listItem); } catch (error) { console.error("Error updating title:", error); alert("Failed update title."); } }
        async function deleteSavedTest(reviewId, listItem) { /* ... same as v10.1 ... */ if (!currentUser || !reviewId) return; listItem.style.opacity = '0.5'; listItem.style.pointerEvents = 'none'; const docRef = db.collection('testReviews').doc(reviewId); try { await docRef.delete(); console.log("Saved test deleted:", reviewId); allSavedTestsData = allSavedTestsData.filter(t => t.id !== reviewId); alert("Saved test deleted."); } catch (error) { console.error("Error deleting test:", error); alert("Failed delete test."); listItem.style.opacity = '1'; listItem.style.pointerEvents = 'auto'; } }
        async function startReattempt(reviewId, mode) { /* ... same as v10.1 ... */ console.log(`Reattempt: ${reviewId}, Mode: ${mode}`); const reviewData = allSavedTestsData.find(t => t.id === reviewId); if (!reviewData) { alert("Error: Could not find saved data."); return; } const originalMCQs = reviewData.originalMCQs; const hasValidData = originalMCQs?.length > 0 && originalMCQs.every(q => q?.question?.en && q.options?.length === 4 && q.answer && q.explanation?.en); if (!hasValidData) { alert("Error: Invalid original data."); return; } const userAnswersFromReview = reviewData.userAnswers || userAnswers; // Need userAnswers from the time of saving, or current if not saved? Let's assume it was saved or use current test's
        let questionsForReattempt = []; switch (mode) { case 'mistaked': questionsForReattempt = originalMCQs.filter((mcq, index) => (userAnswersFromReview[index] !== null) && (mcq.answer.charCodeAt(0) - 'A'.charCodeAt(0) !== userAnswersFromReview[index])); break; case 'skipped': questionsForReattempt = originalMCQs.filter((mcq, index) => userAnswersFromReview[index] === null); break; case 'both': questionsForReattempt = originalMCQs.filter((mcq, index) => userAnswersFromReview[index] === null || ((mcq.answer.charCodeAt(0) - 'A'.charCodeAt(0) !== userAnswersFromReview[index]))); break; case 'full': default: questionsForReattempt = [...originalMCQs]; break; } if (questionsForReattempt.length === 0) { alert(`No questions found for reattempt mode ('${mode}').`); return; } const originalTitle = reviewData.testTitle || 'Test'; const reattemptTitle = `${originalTitle} (Reattempt: ${mode})`; startMockTest(questionsForReattempt, reattemptTitle); }

    </script>

</body>
</html>
